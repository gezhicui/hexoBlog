<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie和Session的使用</title>
    <url>/MyBlog/2020/07/22/Cookie%E5%92%8CSession%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="cookie和session概念"><a href="#cookie和session概念" class="headerlink" title="cookie和session概念"></a>cookie和session概念</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>&emsp;&emsp;cookie是浏览器在电脑硬盘中开辟的一块空间，主要供服务器端存储数据。</p>
<ul>
<li>cookie中的数据是以域名的形式进行区分的。</li>
<li>cookie中的数据是<strong>有过期时间</strong>的，超过时间数据会被浏览器<strong>自动删除</strong>。</li>
<li>cookie中的数据会随着请求被<strong>自动发送</strong>到服务器端。</li>
</ul>
<h2 id="如何查看cookie"><a href="#如何查看cookie" class="headerlink" title="如何查看cookie"></a>如何查看cookie</h2><p>&emsp;&emsp;我们访问百度，在浏览器的开发者模式下Application中就可以查看百度给我们的cookie<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%99%BE%E5%BA%A6cookie.png" alt=""></p>
<a id="more"></a>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>&emsp;&emsp;session实际上就是一个对象，存储在服务器端的内存中，在session对象中也可以存储多条数据，每一条数据都有一个<code>sessionid</code>做为唯一标识。</p>
<h2 id="cookie和session关系"><a href="#cookie和session关系" class="headerlink" title="cookie和session关系"></a>cookie和session关系</h2><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/cookie%E5%92%8Csession%E5%85%B3%E7%B3%BB.png" alt=""></p>
<h1 id="在Nodejs中使用"><a href="#在Nodejs中使用" class="headerlink" title="在Nodejs中使用"></a>在Nodejs中使用</h1><p>&emsp;&emsp;在node.js中需要借助express-session实现session功能。</p>
<blockquote>
<p>npm install express-session</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模块为Express官方提供 是express的中间件函数</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>) ;</span><br><span class="line">app.use(session(&#123;<span class="attr">secret</span> :<span class="string">'secret key'</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>在用户登陆成功后，保存session值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在用户登录密码比对成功后</span></span><br><span class="line"><span class="keyword">if</span> (isValid ==<span class="literal">true</span> )&#123;</span><br><span class="line">    <span class="comment">//登录成功</span></span><br><span class="line">    <span class="comment">//在session对象中添加了一个username属性</span></span><br><span class="line">    <span class="comment">// 原代码  req.username = user. username; 这里的用户名是昵称，邮箱才是   登录账号</span></span><br><span class="line">    req.session.username = user.username;</span><br><span class="line">    res.send( req.session.username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户再进行登录时，判断用户登录状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截请求判断用户登录状态</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>, (req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.url != <span class="string">'/login'</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        <span class="comment">//判断用户访问的是否是登录页面</span></span><br><span class="line">        <span class="comment">//判断用户的登录状态</span></span><br><span class="line">        <span class="comment">//如果用户是登录的将请求放行</span></span><br><span class="line">        <span class="comment">//如果用户不是登录的将请求重定向到登录页面</span></span><br><span class="line">        res.redirect( <span class="string">' /admin/ login'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用户是登录状态将请求放行</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（一） 基本使用</title>
    <url>/MyBlog/2020/07/20/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Express框架是什么"><a href="#Express框架是什么" class="headerlink" title="Express框架是什么"></a>Express框架是什么</h1><p>&emsp;&emsp;Express是一个基于<strong>Node平台</strong>的<strong>web应用开发框架</strong>，它提供了一系列的强大特性，帮助你<strong>创建各种Web应用</strong>。<br>我们可以使用<code>npm install express</code>命令进行下载。</p>
<h2 id="Express框架特性"><a href="#Express框架特性" class="headerlink" title="Express框架特性"></a>Express框架特性</h2><ul>
<li>提供了方便简洁的路由定义方式</li>
<li>对获取HTTP请求参数进行了简化处理</li>
<li>对模板引擎支持程度高，方便渲染动态HTML页面</li>
<li>提供了中间件机制有效控制HTTP请求</li>
<li>拥有大量第三方中间件对功能进行扩展</li>
</ul>
<h1 id="Express框架基本使用"><a href="#Express框架基本使用" class="headerlink" title="Express框架基本使用"></a>Express框架基本使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#123;<span class="attr">name</span>:<span class="string">'张三'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>
<p>在express框架中，我们用res.send()方法来取代res.end()</p>
<ul>
<li>send方法内部会检测响应内容的类型</li>
<li>send方法会自动设置http状态码</li>
<li>send方法会帮我们自动设置响应的内容类型及编码</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><ul>
<li>JSON.parse()方法可以将字符串类型转换成对象类型</li>
<li>JSON.stringify()方法可以将对象类型转换成字符串类型</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（二） 中间件</title>
    <url>/MyBlog/2020/07/21/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h1><p>&emsp;&emsp;中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p>
<a id="more"></a>

<p>&emsp;&emsp;中间件主要由两部分构成，中间件方法以及请求处理函数。中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'请求路径'</span>,<span class="string">'处理函数'</span>)<span class="comment">//接收并处理get请求</span></span><br><span class="line">app.post(<span class="string">'请求路径'</span>,<span class="string">'处理函数'</span>)<span class="comment">//接收并处理post请求</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以针对同一个请求设置多个中间件，对<strong>同一个请求进行多次处理</strong>。   默认情况下，请求从上到下依次匹配中间件，<strong>一旦匹配成功，终止匹配</strong>。   可以调用<code>next</code>方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get (<span class="string">'/request'</span>, (req, res, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">//为req添加一个name属性</span></span><br><span class="line">    req.name =<span class="string">"张三"</span>;</span><br><span class="line">    <span class="comment">//权限控制函数，继续向下执行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/request'</span>,(reg, res)=&gt;&#123;</span><br><span class="line">    res.send (req.name);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="app-use中间件用法"><a href="#app-use中间件用法" class="headerlink" title="app.use中间件用法"></a>app.use中间件用法</h1><p>&emsp;&emsp;app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应所有路径的请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();<span class="comment">//next一定要写</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>app.use第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应admin路径的请求</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req, res, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h1><h2 id="路由保护"><a href="#路由保护" class="headerlink" title="路由保护"></a>路由保护</h2><p>&emsp;&emsp;客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p>
<p>来举个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">//模拟用户登录状态</span></span><br><span class="line">    <span class="keyword">let</span> islogin == <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(islogin)&#123;</span><br><span class="line">        <span class="comment">//如果用户登录，请求继续向下执行</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用户没有登录，对客户端做出响应</span></span><br><span class="line">        res.send(<span class="string">'您还没有登录，无法访问'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/admin'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'已经登录，可以访问当前页面'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="网站维护公告"><a href="#网站维护公告" class="headerlink" title="网站维护公告"></a>网站维护公告</h2><p>&emsp;&emsp;在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">'网站正在维护...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自定义404界面"><a href="#自定义404界面" class="headerlink" title="自定义404界面"></a>自定义404界面</h2><p>&emsp;&emsp;在所有路由的最后面定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">404</span>)</span><br><span class="line">    res.send(<span class="string">'当前访问页面不存在'</span>)</span><br><span class="line">    <span class="comment">//还可以用链式调用的写法</span></span><br><span class="line">    <span class="comment">//res.status(404).send('当前访问页面不存在')</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h1><p>&emsp;&emsp;在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'index'</span>(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//手动构造错误并抛出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'程序崩溃'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;错误处理中间件只能捕获同步任务，异步任务需要手动触发错误处理中间件</p>
<p>&emsp;&emsp;当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'index'</span>(req,res,next)=&gt;&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./demo.txt'</span>,<span class="string">'utf8'</span>,(err,result)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)&#123;</span><br><span class="line">           next(err)<span class="comment">//next()没有传递参数时，是把控制权交给下一个中间件，但是传递了参数，表示要触发错误处理中间件</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.send(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="异步函数捕获错误"><a href="#异步函数捕获错误" class="headerlink" title="异步函数捕获错误"></a>异步函数捕获错误</h1><p>&emsp;&emsp;在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢?</p>
<p>&emsp;&emsp;try catch可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误(如回调函数)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">'util'</span>).promisify</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)<span class="comment">//把readFile变成异步方法</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>,<span class="keyword">async</span>(reg, res, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> readFile(<span class="string">'./aaa.js'</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        next(ex);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（三） 请求处理</title>
    <url>/MyBlog/2020/07/21/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="创建路由的基础方法"><a href="#创建路由的基础方法" class="headerlink" title="创建路由的基础方法"></a>创建路由的基础方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router();</span><br><span class="line"><span class="comment">//将路由和请求路径进行匹配，当客户端请求路径是home时，使用home这个路由对象进行处理，具体请求处理需要在二级路由中去进行</span></span><br><span class="line">app.use(<span class="string">'/home'</span>,home) ;</span><br><span class="line"><span class="comment">//在home路由下继续创建二级路由</span></span><br><span class="line">home.get(<span class="string">'/index'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">// /home/index</span></span><br><span class="line">    res.send (<span class="string">'欢迎来到博客展示页面'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)<span class="comment">//端口监听</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h1><p>模块化路由基本实现：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1.png" alt=""></p>
<h1 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h1><p>&emsp;&emsp;Express框架中使用<code>req.query</code>即可获取GET参数，框架内部会将GET参数转换为对象并返回。我们就不需要使用原生语法中的url模块了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收地址栏中问号后面的参数</span></span><br><span class="line"><span class="comment">//例如: http://localhost:3000/?name=zhangsan&amp;aqe=30</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log (req.query); <span class="comment">//&#123; "name" : "zhangsan" ，, "age" : "30"&#125;</span></span><br><span class="line">    res.send(req.query)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h1><p>&emsp;&emsp;Express中接收post请求参数需要借助第三方包<code>body-parser</code>。npm下载即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>( <span class="string">'body-parser'</span>);</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截所有请求</span></span><br><span class="line"><span class="comment">// extended: false方法内部使用querystring模块处理请求参数的格式</span></span><br><span class="line"><span class="comment">// extended: true方法内部使用第三方模块qs处理请求参数的格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/add'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//body属性是bodyParser在req中添加的属性，值为post请求参数</span></span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//端口监听</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// localhost: 3000/find/123</span></span><br><span class="line">app.get(<span class="string">'/index/:id'</span>,(req, res) =&gt;&#123;</span><br><span class="line">    <span class="comment">//req.parmas接收post请求参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params); <span class="comment">// &#123;id: 123&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h1><p>&emsp;&emsp;通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如img、CSS、JavaScript文件等。</p>
<blockquote>
<p>app.use(express.statuc(‘public’))</p>
</blockquote>
<p>现在，public目录下面的文件就可以访问了。</p>
<ul>
<li><a href="http://localhost:3000/css/style.css" target="_blank" rel="noopener">http://localhost:3000/css/style.css</a></li>
<li><a href="http://localhost:3000/js/app.js" target="_blank" rel="noopener">http://localhost:3000/js/app.js</a></li>
<li><a href="http://localhost:3000/images/bg.png" target="_blank" rel="noopener">http://localhost:3000/images/bg.png</a></li>
<li><a href="http://localhost:3000/hello.html" target="_blank" rel="noopener">http://localhost:3000/hello.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（一） 安装及环境配置</title>
    <url>/MyBlog/2020/07/18/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="MongoDB数据库和可视化软件的下载"><a href="#MongoDB数据库和可视化软件的下载" class="headerlink" title="MongoDB数据库和可视化软件的下载"></a>MongoDB数据库和可视化软件的下载</h2><ul>
<li>下载地址: <a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%98%E7%BD%91.png" alt=""></p>
<a id="more"></a>
<p>按照这个下载，然后再来下载mongodb可视化软件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BD%AF%E4%BB%B6.png" alt=""></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、mongodb的安装</p>
<p>在这我们选择自定义安装，一路next<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/momgodb%E5%AE%89%E8%A3%85.png" alt=""></p>
<p>在这里选择默认值，让他作为服务去运行就行了</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%89%E8%A3%852.png" alt=""></p>
<p>由于我们已经下载过可视化软件，这里就不下载了</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%89%E8%A3%853.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt=""></p>
<p>2、可视化软件的安装</p>
<p>下载之后直接打开就已经安装完成了，点击Star Using Compass开始使用<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%89%E8%A3%85.png" alt=""></p>
<h1 id="MongoDB的使用"><a href="#MongoDB的使用" class="headerlink" title="MongoDB的使用"></a>MongoDB的使用</h1><h2 id="下载MongoDB第三方包"><a href="#下载MongoDB第三方包" class="headerlink" title="下载MongoDB第三方包"></a>下载MongoDB第三方包</h2><ul>
<li>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose</li>
<li>使用<code>npm install mongoose</code>命令下载<h2 id="在node环境中使用"><a href="#在node环境中使用" class="headerlink" title="在node环境中使用"></a>在node环境中使用</h2>1、启动MongoDB</li>
</ul>
<p>在命令行工具中运行<code>net start mongoDB</code>即可启动MongoDB，否则MongoDB将无法连接。同时，也可以用<code>net stop mongoDB</code>停止服务</p>
<p>2、连接MongoDB</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%BF%9E%E6%8E%A5MongoDB.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs中http请求与响应处理</title>
    <url>/MyBlog/2020/06/30/Nodejs%E4%B8%ADhttp%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>首先，我们先来创建一个网站服务器</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/node%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt=""></p>
<p>其中，当有请求来的时候，会触发request这个事件，然后执行后面的事件处理函数。我们可以通过res.end对客户端进行响应</p>
<a id="more"></a>
<h1 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h1><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><ul>
<li>Get请求数据</li>
<li>Post请求数据<h2 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h2><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80.png" alt=""><br>我们可以通过<code>req.url</code>来获取客户端请求地址，通过<code>req.headers</code>获取请求报文，<code>req.methods</code>获取请求方法(get/post)</li>
</ul>
<h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><ul>
<li>200请求成功</li>
<li>404请求的资源没有被找到</li>
<li>500 服务器端错误</li>
<li>400客户端请求有语法错误<h2 id="响应内容类型"><a href="#响应内容类型" class="headerlink" title="响应内容类型"></a>响应内容类型</h2></li>
<li>text/html</li>
<li>text/css</li>
<li>application/javascript</li>
<li>image/jpeg</li>
<li>application/json</li>
</ul>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>客户端向服务器端发送请求时，有时需要携带一些客户信息, 客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p>
<h2 id="get请求参数"><a href="#get请求参数" class="headerlink" title="get请求参数"></a>get请求参数</h2><ul>
<li>参数被放置在浏览器地址栏中，例如: <a href="http://localhost:3000/?name=" target="_blank" rel="noopener">http://localhost:3000/?name=</a> zhangsan&amp;age= 20</li>
</ul>
<p>那么怎么拿到get的参数呢？<br>node为我们提供了一个内置模块</p>
<blockquote>
<p>const url = require(‘url)</p>
</blockquote>
<p>在url模块中，有一个parse()方法可以处理url，我们只需要将想解析的url传给url.parse()方法进行解析，最终，这个方法会返回一个对象。我们来console.log一下<code>url.parse(req.url)</code></p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/urlparse%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>现在，我们把查询参数转换成对象。</p>
<blockquote>
<p>url.parse(req.url,true)</p>
</blockquote>
<ul>
<li>第一个参数是要解析的url地址</li>
<li>第二个参数表示把查询参数解析成对象形式。</li>
</ul>
<p>此时，url.paesr中的query参数会变成一个对象 <code>query:&#39;name=zhangsan ,age=&#39;20&#39;</code><br>这个时候，我们就可以通过<code>url.parse(res.url,true).query</code>拿到这个对象</p>
<blockquote>
<p>let params = url.parse(res.url,true).query</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cocnsole.log(params.name)<span class="comment">//zhangsan</span></span><br><span class="line">cocnsole.log(params.age)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在parse()方法中，还有一个pathname属性可以帮我们获取到不包含请求参数的请求地址。这样，我们就可以通过对象结解构的方式拿到query和pathname</p>
<blockquote>
<p>let {query, pathname} = url.parse(res.url,true)</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/parse%E6%96%B9%E6%B3%95.png" alt=""></p>
<h2 id="post请求参数"><a href="#post请求参数" class="headerlink" title="post请求参数"></a>post请求参数</h2><p>我们可以通过表单方式提交一个post请求，post方式是通过事件的方式接收的。<strong>当请求传递参数时触发data事件</strong>，<strong>当传递完成时触发end事件</strong></p>
<p>我们通过querystring这个内置模块来处理post的请求参数</p>
<blockquote>
<p>const querystring = require(‘querystring’);</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/querystring%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86post.png" alt=""></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p><a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a></p>
<p><a href="http://localhost:3000/login" target="_blank" rel="noopener">http://localhost:3000/login</a></p>
<p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p>
<p>实现路由的核心代码</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81.png" alt=""></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（二） CRUD</title>
    <url>/MyBlog/2020/07/19/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="MongoDB-CRUD操作"><a href="#MongoDB-CRUD操作" class="headerlink" title="MongoDB CRUD操作"></a>MongoDB CRUD操作</h1><p>我们先来看看MongoDB中的相关概念</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.png" alt=""></p>
<p>在mysql中分别对应数据库、表、行、字段</p>
<a id="more"></a>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>&emsp;&emsp;创建集合分为两步，一是对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88.png" alt=""></p>
<h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><p>创建文档实际上就是<strong>向集合中插入数据。</strong><br>分为两步</p>
<ul>
<li>创建集合实例。</li>
<li>调用实例对象下的save方法将数据保存到数据库中。<h3 id="创建文档方法一"><a href="#创建文档方法一" class="headerlink" title="创建文档方法一"></a>创建文档方法一</h3><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3.png" alt=""></li>
</ul>
<p>此时，数据库就已经创建成功</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8F%92%E5%85%A5%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h3 id="创建文档方法二"><a href="#创建文档方法二" class="headerlink" title="创建文档方法二"></a>创建文档方法二</h3><p>在集合的构造函数下有一个create方法，可以通过<code>Course.create</code>的方法创建文档</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/createCourse.png" alt=""></p>
<p>注意：<strong>对数据库的所有操作都是异步操作</strong></p>
<p>所以，还可以这么写：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><h3 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h3><p>先来用find的基本方法查询一下所有的文档</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/find%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3.png" alt=""></p>
<p>同时，find()中还可以传递一个对象作为参数，这个对象实际上就是查找条件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p><code>.findOne()</code>方法返回一条文档，默认返回第一条</p>
<h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><p>1、我们用<code>$gt</code>表示大于，<code>$lt</code>表示小于<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p>2、我们用<code>$in</code>表示包含<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8C%85%E5%90%AB%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p>3、选择要查询的字段<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2.png" alt=""><br>如果不想查询某个字段，只需要在该字段前面加个<code>-</code> ，如<code>select(&#39;email name -_id&#39;)</code></p>
<p>4、排序<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97.png" alt=""></p>
<p>5、skip和limit</p>
<ul>
<li>skip()跳过多少条数据</li>
<li>limit()限制查询数量</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/skip%E5%92%8Climit.png" alt=""></p>
<p>6、查询用户数据的总数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用在分页</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="keyword">await</span> User.countDocuments(&#123;&#125;)</span><br><span class="line"><span class="comment">//和 skip()、limit()一起使用</span></span><br><span class="line"><span class="comment">//总页数</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="built_in">Math</span>.ceil(count / pagesize);</span><br><span class="line"><span class="comment">//页码对应的数据查询开始位置</span></span><br><span class="line"><span class="keyword">let</span> start = (page - <span class="number">1</span>)* pagesize;</span><br><span class="line"><span class="comment">//将用户信息从数据库中查询出来</span></span><br><span class="line"><span class="comment">//渲染用户列表模块</span></span><br><span class="line"><span class="keyword">let</span> users = <span class="keyword">await</span> User.find(&#123;&#125;).limit(pagesize).skip(start)</span><br></pre></td></tr></table></figure>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除id为12345的数据，若匹配到多个，则删除第一个</span></span><br><span class="line">User.findOneAndDelete(&#123;<span class="attr">_id</span>:<span class="string">'12345'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有文档 </span></span><br><span class="line">User.deleteMany(&#123;&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除多个id为12345的文档</span></span><br><span class="line">User.deleteMany(&#123;<span class="attr">_id</span>:<span class="string">'12345'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新单个 </span></span><br><span class="line"><span class="comment">//更新条件： (&#123;查询条件&#125;,&#123;更新后的值&#125;)</span></span><br><span class="line">User.updateOne(&#123;<span class="attr">name</span>:<span class="string">'李四'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'李狗蛋'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新多个 把所有的age改成65</span></span><br><span class="line">User.updateMany(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="string">'65'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>
<h1 id="mongodb获取前端数据并处理"><a href="#mongodb获取前端数据并处理" class="headerlink" title="mongodb获取前端数据并处理"></a>mongodb获取前端数据并处理</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res, next) =&gt;&#123;</span><br><span class="line">    <span class="comment">//接收客户端传递过来的请求参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username,email, role, state &#125; = req.body;</span><br><span class="line">    <span class="comment">//即将要修改的用户id</span></span><br><span class="line">    <span class="keyword">const</span> id = req.query.id;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    Let user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>: id&#125;);</span><br><span class="line">    <span class="comment">//密码比对</span></span><br><span class="line">    <span class="keyword">const</span> isValid = <span class="keyword">await</span> bcrypt.compare(req.body.password,user.  password);</span><br><span class="line">    <span class="comment">//密码比对成功</span></span><br><span class="line">    <span class="keyword">if</span> (isValid)&#123;</span><br><span class="line">        res.send(<span class="string">'密码比对成功'</span>);</span><br><span class="line">        <span class="comment">//将用户信息更新到数据库中</span></span><br><span class="line">        <span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>: id&#125;,&#123;</span><br><span class="line">            username:username,</span><br><span class="line">            email:email,</span><br><span class="line">            role: role,</span><br><span class="line">            state: state</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">'密码比对失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h1><ul>
<li>required: true必传字段</li>
<li>minlength: 3 字符串最小长度</li>
<li>maxlength: 20 字符串最大长度</li>
<li>min:2 数值最小为2</li>
<li>max: 100 数值最大为100</li>
<li>enum:[‘html’, ‘css’. - ‘javascript’, ‘node.js’]</li>
<li>trim: true 去除字符串两边的空格</li>
<li>validate: 自定义验证器</li>
<li>default: 默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建集合规则时，加入验证,非必填</span></span><br><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> userschema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,<span class="comment">//类型为string</span></span><br><span class="line">        <span class="built_in">require</span>:<span class="literal">true</span>,<span class="comment">//必填字段</span></span><br><span class="line">        minlrngth:<span class="number">2</span>,<span class="comment">//最小长度为2</span></span><br><span class="line">        maxkength:<span class="number">5</span>,<span class="comment">//最大长度为5</span></span><br><span class="line">        trim:<span class="literal">true</span><span class="comment">//去除两边字符串</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,<span class="comment">//最小数字</span></span><br><span class="line">        max:<span class="number">100</span><span class="comment">//最大数字</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publishData:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now<span class="comment">//默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    category:&#123;<span class="comment">//分类</span></span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//枚举  列举出当前字段可以拥有的值</span></span><br><span class="line">        enum:[<span class="string">'html'</span>,<span class="string">'css'</span>,<span class="string">'js'</span>]<span class="comment">//只允许传递这里面的值</span></span><br><span class="line">        <span class="comment">//如果自定义错误信息，还可以这么写：</span></span><br><span class="line">        enum:&#123;</span><br><span class="line">            values:[<span class="string">'html'</span>,<span class="string">'css'</span>,<span class="string">'js'</span>],</span><br><span class="line">            message:<span class="string">'分类信息需在范围之内'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//自定义验证规则</span></span><br><span class="line">        validate:&#123;</span><br><span class="line">            validator:<span class="function"><span class="params">v</span>=&gt;</span>&#123;<span class="comment">//v为传入的值</span></span><br><span class="line">                <span class="keyword">return</span> v &amp;&amp; v.length &gt; <span class="number">4</span><span class="comment">//传入了一个值且这个值的长度大于4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            messgae:<span class="string">'传入的值不符合验证规则'</span><span class="comment">//自定义报错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此时，若插入空数据，如<code>Course.create({})</code>,则插入失败</p>
<p>同时，还能在第二个参数自定义错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userschema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">require</span>:[<span class="literal">true</span>,<span class="string">'请输入文章标题'</span>],</span><br><span class="line">        maxlength:[<span class="number">2</span>,<span class="string">'文章长度最大不能超过2'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="获取错误信息对象"><a href="#获取错误信息对象" class="headerlink" title="获取错误信息对象"></a>获取错误信息对象</h1><p>在插入数据错误时，在错误信息中我们通常可以看到一大串信息，如现在<code>category</code>和<code>author</code>报错，报错信息如下：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt=""></p>
<p>我们现在只想获取报错对象中的<code>errors</code>中的<code>message</code>属性，来更直观的看到哪里有错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = mongoose.model(<span class="string">'Post'</span>, postschema);</span><br><span class="line">Post.create(&#123;<span class="attr">title</span>: <span class="string">'aa'</span>, <span class="attr">age</span>: <span class="number">60</span>,<span class="attr">category</span>: <span class="string">'java'</span>, <span class="attr">author</span>: <span class="string">'bd'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//获取错误信息对象</span></span><br><span class="line">        <span class="keyword">const</span> err = error.errors;</span><br><span class="line">        <span class="comment">//循环错误信息对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> err)&#123;</span><br><span class="line">            <span class="comment">//打印</span></span><br><span class="line">            consoLe.log(err[attr][ <span class="string">'message'</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>现在就能方便的看到具体的报错信息<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%85%B7%E4%BD%93%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（三）集合关联</title>
    <url>/MyBlog/2020/07/20/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h1><p>通常<strong>不同集合的数据之间是有关系的</strong>，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的<br>，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p>
<ul>
<li>使用id对集合进行关联</li>
<li>使用populate方法进行关联集合查询</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94.png" alt=""></p>
<a id="more"></a>

<h2 id="集合关联实现"><a href="#集合关联实现" class="headerlink" title="集合关联实现"></a>集合关联实现</h2><pre><code class="js"><span class="comment">//我们先定义两个集合</span>
<span class="comment">//用户集合  </span>
<span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>,<span class="keyword">new</span> mongoose.schema({<span class="attr">name</span>:{<span class="attr">type</span>:string )}));<span class="comment">//我们之前是单独给集合规则赋给一个对象，但其实可以直接写在里面</span>

<span class="comment">//文章集合</span>
<span class="keyword">const</span> Post = mongoose.model(<span class="string">'Post'</span>, <span class="keyword">new</span> mongoose.schema({
    title:{
        type: <span class="built_in">String</span>
    },
    <span class="comment">//使用ID将文章集合和作者集合进行关联</span>
    author: {
        type: mongoose.schema.Types.ObjectId, 
        ref:<span class="string">'User'</span><span class="comment">//当前字段要关联的集合</span>
    }
}));

<span class="comment">//创建用户</span>
User.create({<span class="attr">name</span>:<span class="string">'yang'</span>} ).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));<span class="comment">//自动生成id为12321412312</span>
<span class="comment">//创建文章</span>
Post.create({<span class="attr">titile</span>:<span class="string">'123'</span>，author:<span class="string">'12321412312'</span>}).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));


<span class="comment">//联合查询</span>
Post.find()<span class="comment">//查询post信息</span>
    .then(<span class="function">(<span class="params">err, result</span>)=&gt;</span><span class="built_in">console</span>.log(result));<span class="comment">//查出来的author是id</span>

Post.find()<span class="comment">//查询post信息</span>
    .populate(<span class="string">'author'</span>)
    .then(<span class="function">(<span class="params">err, result</span>)=&gt;</span><span class="built_in">console</span>.log(result));<span class="comment">//查出来的author是一个对象，对象中是author的具体内容</span></code></pre>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs中的密码加密bcrypt</title>
    <url>/MyBlog/2020/07/22/Nodejs%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86bcrypt/</url>
    <content><![CDATA[<h1 id="密码加密bcrypt"><a href="#密码加密bcrypt" class="headerlink" title="密码加密bcrypt"></a>密码加密bcrypt</h1><p>&emsp;&emsp;哈希加密是单程加密方式:1234 =&gt; abcd，无法解密。但是，在加密的密码中加入随机字符串可以增加密码被破解的难度。</p>
<p>先看一个小demo介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入bcrypt模块</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span> (<span class="string">'bcrypt'</span>) ;</span><br><span class="line">    <span class="comment">//生成随机字符串</span></span><br><span class="line">    <span class="comment">// genSalt方法接收一个数值作为参数</span></span><br><span class="line">    <span class="comment">//数值越大生成的随机字符串复杂度越高</span></span><br><span class="line">    <span class="comment">//数值越小生成的随机字符串复杂度越低</span></span><br><span class="line">    <span class="comment">//默认值是10</span></span><br><span class="line">    <span class="comment">//返回生成的随机字符串</span></span><br><span class="line"><span class="keyword">let</span> salt = <span class="keyword">await</span> bcrypt.gensalt(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//对密码进行加密</span></span><br><span class="line">    <span class="comment">//第一个参数．要进行加密的明文</span></span><br><span class="line">    <span class="comment">//第二个参数．随机字符串</span></span><br><span class="line">    <span class="comment">//返回值是加密后的密码</span></span><br><span class="line"><span class="keyword">let</span> pass = <span class="keyword">await</span> bcrypt.hash (<span class="string">'明文密码,'</span>salt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码比对</span></span><br><span class="line"><span class="keyword">let</span> isEqual = <span class="keyword">await</span> bcrypt.compare(<span class="string">'明文密码'</span>,<span class="string">'加密密码'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="bcrypt安装"><a href="#bcrypt安装" class="headerlink" title="bcrypt安装"></a>bcrypt安装</h1><blockquote>
<p>npm install bcrypt</p>
</blockquote>
<h2 id="bcrypt依赖的其他环境-需要提前安装"><a href="#bcrypt依赖的其他环境-需要提前安装" class="headerlink" title="bcrypt依赖的其他环境(需要提前安装)"></a>bcrypt依赖的其他环境(需要提前安装)</h2><ul>
<li>python 2.x<blockquote>
<p>去官网安装</p>
</blockquote>
</li>
<li>node-gyp<blockquote>
<p>npm install -g node-gyp</p>
</blockquote>
</li>
<li>windows-build-tools<blockquote>
<p>npm install –global –production windows-build-tools</p>
</blockquote>
</li>
</ul>
<h1 id="bcrypt的使用"><a href="#bcrypt的使用" class="headerlink" title="bcrypt的使用"></a>bcrypt的使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在model下的user.js中</span></span><br><span class="line"><span class="comment">//创建用户集合</span></span><br><span class="line"><span class="comment">//引入mongoose第三方模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">//导入bcrypt</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>( <span class="string">'bcrypt'</span>);</span><br><span class="line"><span class="comment">//创建用户集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    username:<span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    password:<span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//创建集合</span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>,userSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> pass = <span class="keyword">await</span> bcrypt.hash(<span class="string">'123456'</span>,salt);</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">        username:<span class="string">'yang'</span>,</span><br><span class="line">        email: <span class="string">'yang@qq.cn'</span>,</span><br><span class="line">        password: pass,</span><br><span class="line">        role: <span class="string">'admin'</span>,</span><br><span class="line">        state:<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">creatUser()</span><br></pre></td></tr></table></figure>
<h2 id="在验证登录逻辑中加上密码的比对"><a href="#在验证登录逻辑中加上密码的比对" class="headerlink" title="在验证登录逻辑中加上密码的比对"></a>在验证登录逻辑中加上密码的比对</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现登录功能</span></span><br><span class="line">admin.post(<span class="string">'/login'</span>, <span class="keyword">async</span>(req,res）=&gt;&#123;</span><br><span class="line">    <span class="comment">//接收请求参数 解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123;email,password&#125; = req.body;</span><br><span class="line">    <span class="comment">//如果用户没有输入邮件地址</span></span><br><span class="line">    <span class="keyword">if</span> (email.trim().length == <span class="number">0</span> || password.trim().length = <span class="number">0</span>) <span class="keyword">return</span> res.status(<span class="number">400</span>).send(<span class="string">'请输入邮件地址或密码'</span>)</span><br><span class="line">    <span class="comment">//根据邮箱地址查询用户信息</span></span><br><span class="line">    <span class="comment">//如果查询到了用户user变量的值是对象类型对象中存储的是用户信息</span></span><br><span class="line">    <span class="comment">//如果没有查询到用户user变量为空</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123;email&#125;);</span><br><span class="line">    <span class="comment">//查询到了用户</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;  </span><br><span class="line">        <span class="comment">//将客户端传递过来的密码和用户信息中的密码进行比对</span></span><br><span class="line">        <span class="comment">// true比对成功</span></span><br><span class="line">        <span class="comment">// false对比失败</span></span><br><span class="line">        <span class="keyword">let</span> isValid = <span class="keyword">await</span> bcrypt.compare(password,user.password)</span><br><span class="line">        <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">            <span class="comment">//比对成功</span></span><br><span class="line">            res.send(<span class="string">'登录成功'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//密码不一样</span></span><br><span class="line">            res.status(<span class="number">400</span>).render(<span class="string">'admin/error'</span>, &#123;<span class="attr">msg</span>:<span class="string">'邮箱地址或者密码错误'</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//没查到</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.status(<span class="number">400</span>).render(<span class="string">'admin/error'</span>, &#123;<span class="attr">msg</span>:<span class="string">'邮箱地址或者密码错误'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="密码加密传入数据库"><a href="#密码加密传入数据库" class="headerlink" title="密码加密传入数据库"></a>密码加密传入数据库</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对密码进行加密处理</span></span><br><span class="line"><span class="comment">//生成随机字符串</span></span><br><span class="line"><span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="comment">//替换密码</span></span><br><span class="line">req.body.password = password;</span><br><span class="line"><span class="comment">//将用户信息添加到数据库中,用户信息就是post请求传过来的req.body中的数据</span></span><br><span class="line"><span class="keyword">await</span> User.create(req.body);</span><br><span class="line"><span class="comment">//将页面重定向到用户列表页面</span></span><br><span class="line">res.redirect(<span class="string">'/admin/user'</span>);</span><br><span class="line"><span class="keyword">const</span> password = <span class="keyword">await</span> bcrypt.hash(req.body.password,salt);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>密码加密</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（一） React的组件和props</title>
    <url>/MyBlog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><font color="red" size="4px"><strong>ATTATION!</font>本文由于html代码无法高亮显示，用   ``  包裹，实际代码没有这个符号</strong></p>
<p>react的组件分为3个部分</p>
<ul>
<li>属性 props</li>
<li>状态state</li>
<li>生命周期</li>
</ul>
<h1 id="组件的创建"><a href="#组件的创建" class="headerlink" title="组件的创建"></a>组件的创建</h1><h2 id="函数组件-无状态组件"><a href="#函数组件-无状态组件" class="headerlink" title="函数组件/无状态组件"></a>函数组件/无状态组件</h2><p>无状态组件的创建方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx代码</span></span><br><span class="line">      <span class="string">`&lt;div&gt;我是一个无状态组件&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组件就是自定义标签</span></span><br><span class="line"><span class="comment">//调用组件</span></span><br><span class="line"><span class="keyword">let</span> com=<span class="string">`&lt;MyCom/&gt;`</span></span><br><span class="line">ReactDOM.render(com,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果想要多次调用的话，就必须加一个父容器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> com=<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom/&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom/&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br></pre></td></tr></table></figure>
<p>父子组件：多个组件在在一个组件里多次调用来进行组合拼装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCom1</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx代码</span></span><br><span class="line">        <span class="string">`&lt;div&gt;我是一个无状态组件1&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCom2</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx代码</span></span><br><span class="line">        <span class="string">`&lt;div&gt;我是一个无状态组件2&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCom3</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx代码</span></span><br><span class="line">        <span class="string">`&lt;div&gt;我是一个无状态组件3&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父组件调用子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom1/&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom2/&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom3/&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(Com,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><p>创建一个类组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须通过一个render方法return一个jsx</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;类组件&lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> com=<span class="string">`&lt;MyCom/&gt;`</span></span><br><span class="line">ReactDOM.render(com,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>props是react中一个重要的属性，是组件对外的接口。我们props就可以从组件的外部向组件的内部进行数据的传递。也可以完成父组件给子组件的数据传递</p>
<p><strong>注意:无论是无状态组件还是类组件我们都不能修改自身的props</strong></p>
<h2 id="无状态组件的props使用"><a href="#无状态组件的props使用" class="headerlink" title="无状态组件的props使用"></a>无状态组件的props使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//想使用props，必须在无状态组件的函数的形参中写上props</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params">props </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;我是一 个无状态组------ 外部传递数据是: &#123;props.text&#125;&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM. render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">" 我是传递给Com的props数据"</span>/&gt;</span></span> , <span class="built_in">document</span>.getElementById( <span class="string">"demoReact"</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//提升下难度，把text中的数据放在外面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params">props </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;我是一 个无状态组------ 外部传递数据是: &#123;props.text&#125;&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> demo=<span class="string">"我是数据"</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">&#123;demo&#125;/</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById( <span class="string">"demoReact"</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//再提升难度，当我们调用多个数据时，把数据放到对象中，再使用扩展运算符来传递属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params">props </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;我是一 个无状态组------ 外部传递数据是: &#123;props.text&#125;--&#123;props.age&#125;&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    text:<span class="string">"我是text"</span>,</span><br><span class="line">    age:<span class="string">"我是age"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM. render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">&#123;...obj&#125;/</span>&gt;</span></span> , <span class="built_in">document</span>.getElementById( <span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="类组件props使用"><a href="#类组件props使用" class="headerlink" title="类组件props使用"></a>类组件props使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须通过一个render方法return一个jsx</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                类组件---&#123;this.props.name&#125;--&#123;this.props.num&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    name:<span class="string">"i am name"</span>,</span><br><span class="line">    num:<span class="string">"i am num"</span></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyCom</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="无状态组件的props默认值"><a href="#无状态组件的props默认值" class="headerlink" title="无状态组件的props默认值"></a>无状态组件的props默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.无状态组件的props验证和 默认值</span></span><br><span class="line"><span class="comment">//默认值需要defaultProps </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;我是无状态组件----&#123; props.name&#125;&lt;/div&gt; `</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">Com.defaultProps=&#123;</span><br><span class="line">    name:<span class="string">"我是props中name的默认值"</span></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span> <span class="attr">name</span>=<span class="string">"我是name的数据"</span>/&gt;</span></span>，<span class="built_in">document</span>.getElementById( <span class="string">"demoReact"</span>);</span><br><span class="line"><span class="comment">//如果没有传值，则显示  我是props中name的默认值</span></span><br><span class="line"><span class="comment">//否则，像例子中传了值，显示  我是name的数据</span></span><br></pre></td></tr></table></figure>
<h2 id="类组件的props默认值"><a href="#类组件的props默认值" class="headerlink" title="类组件的props默认值"></a>类组件的props默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须通过一个render方法return一个jsx</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                类组件---&#123;this.props.name&#125;--&#123;this.props.num&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Com.defaultProps=&#123;</span><br><span class="line">    name:<span class="string">"我是props中name的默认值"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    num:<span class="string">"i am num"</span></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyCom</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br><span class="line"><span class="comment">//显示类组件---我是props中name的默认值--i am num</span></span><br></pre></td></tr></table></figure>

<h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><p>之前的数据都是存在组件内部，如果我想道染外部传递进来props的数据怎么办？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> MyCom=<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            我是子组件 </span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                props.arr.map((v,i)=&gt;&#123;</span></span><br><span class="line"><span class="string">                    return &lt;p&gt;&#123;v&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dataArr=[<span class="string">"寒冰"</span>,<span class="string">"盖伦"</span>,<span class="string">"蛮王"</span>];</span><br><span class="line"><span class="keyword">let</span> Com=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            我是父组件</span></span><br><span class="line"><span class="string">            &lt;MyCom arr=&#123;dataArr&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )       </span><br><span class="line">&#125;</span><br><span class="line">ReactDOM. render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span> /&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">"demoReact"</span>));</span><br></pre></td></tr></table></figure>
<p>来看一个修改过的例子：</p>
<p>当我点击页面中的lol英雄展示的时候下面的内容隐藏，点击之后在显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool=<span class="literal">true</span>;<span class="comment">// 控制变量用来保存当前的内容显示和隐藏的状态</span></span><br><span class="line"><span class="keyword">let</span> MyCom=<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div style=&#123; &#123;display : bool?"block":"none"&#125;&#125;&gt;</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                props.arr.map((v,i)=&gt;&#123;</span></span><br><span class="line"><span class="string">                return &lt;p&gt;&#123;v&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dataArr=[<span class="string">"寒冰"</span>,<span class="string">"盖伦"</span> ,<span class="string">"蛮王"</span>];</span><br><span class="line"><span class="keyword">let</span> Com=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;h1 onClick=&#123;()=&gt;&#123;boo1 =! bool;console.log(bool);render()&#125;&#125; &gt;</span></span><br><span class="line"><span class="string">                LOL英雄展示</span></span><br><span class="line"><span class="string">            &lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;MyCom arr=&#123;dataArr&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ReactDOM. render(<span class="string">`&lt;Com /&gt;`</span> ,<span class="built_in">document</span>.getElementById(<span class="string">" demoReact"</span> ));</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（三）脚手架</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>create-react-app是facebook官方退出的一款react的脚手架，安装前确保电脑有node环境并安装到最新版本</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>npm install -g create-react-app</p>
</blockquote>
<p>等待安装，安装结束执行</p>
<blockquote>
<p>create-react-app –version</p>
</blockquote>
<p>可查看版本<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%89%8B%E6%9E%B6%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>cd到项目文件夹中，执行代码新建一个项目</p>
<blockquote>
<p>create-react-app 项目名</p>
</blockquote>
<p>然后执行npm start启动项目</p>
<blockquote>
<p>npm start</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/start%E6%88%90%E5%8A%9F.png" alt=""></p>
<a id="more"></a>

<h1 id="文件夹目录"><a href="#文件夹目录" class="headerlink" title="文件夹目录"></a>文件夹目录</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%AE%E5%BD%95.png" alt=""></p>
<ul>
<li>public 静态资源文件</li>
<li>src 代码文件</li>
</ul>
<p>我们在src中创建components文件夹来存放自己写的组件</p>
<h1 id="快速使用组件"><a href="#快速使用组件" class="headerlink" title="快速使用组件"></a>快速使用组件</h1><p>现在我们想快速创建一个组件，来到vscode插件市场中，搜索ES7</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/react%E6%8F%92%E4%BB%B6.png" alt=""></p>
<p>下载安装，此时，我们用<code>rcc</code>就可以快速创建一个组件模板<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/rcc.png" alt=""></p>
<p>然后来到<code>App.js</code>文件下，把该删除的都删干净，导入自己写的组件文件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/app.js.png" alt=""></p>
<p>点击运行，自己写的组件就正常调用了</p>
<h1 id="导入本地图片"><a href="#导入本地图片" class="headerlink" title="导入本地图片"></a>导入本地图片</h1><p>导入本地图片有三种方法</p>
<h2 id="第一种导入图片路径"><a href="#第一种导入图片路径" class="headerlink" title="第一种导入图片路径"></a>第一种导入图片路径</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Img <span class="keyword">from</span> <span class="string">"./images/1.png"</span></span><br><span class="line">&lt;img src=&#123;Img&#125; alt=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="第二种直接获取图片"><a href="#第二种直接获取图片" class="headerlink" title="第二种直接获取图片"></a>第二种直接获取图片</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#123;<span class="built_in">require</span>(<span class="string">"./images/1.png"</span>)&#125; alt=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="如果是背景图的话操作style"><a href="#如果是背景图的话操作style" class="headerlink" title="如果是背景图的话操作style"></a>如果是背景图的话操作style</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">style=&#123;&#123;<span class="attr">background</span>:<span class="string">`url(<span class="subst">$&#123;<span class="built_in">require</span>(<span class="string">"./images/1.png"</span>)&#125;</span>)`</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>${} 为字符串模板,要用反引号``</p>
</blockquote>
<h1 id="脚手架-props与state"><a href="#脚手架-props与state" class="headerlink" title="脚手架 props与state"></a>脚手架 props与state</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>我们先来创建一个 <code>News.js</code>组件当做<code>Home.js</code>组件的子组件</p>
<p>在home组件中引入News.js<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/home%E5%BC%95%E5%85%A5news.png" alt=""></p>
<p>此时，想在home组件给news组件传一个值，那么，<strong>News</strong>组件就要接收这个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//News组件</span></span><br><span class="line">News---&#123;<span class="keyword">this</span>.props.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Home组件</span></span><br><span class="line">&lt;News text = <span class="string">"我是父组件传过来的值"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>和本地模式一样，详见<strong><a href="http://yang_yu_xiang.gitee.io/myblog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/#more" target="_blank" rel="noopener">React学习笔记（二）</a></strong></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（五）React router dom路由基础</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>根据url的不同来切换对应的组件实现spa(单页面应用)在页面切换的时候不会刷新，更加接近原生体验</p>
<h2 id="路由的下载"><a href="#路由的下载" class="headerlink" title="路由的下载"></a>路由的下载</h2><p>下载</p>
<blockquote>
<p>npm install –save react-router-dom</p>
</blockquote>
<ul>
<li>router-router    只提供了一些核心的API</li>
<li>router-router-dom    提供更多的一些选项</li>
</ul>
<p>路由模式:</p>
<ul>
<li>hash HashRouter (hash模式带#号，刷新的时候页面不会丢失)</li>
<li>browser BrowserRouter 历史记录模式，没有#号，他是通过历史记录api来进行路由切换的。刷新会丢失，本地模式不会<a id="more"></a>

</li>
</ul>
<h2 id="引用路由"><a href="#引用路由" class="headerlink" title="引用路由"></a>引用路由</h2><p>在index.js中导入包</p>
<blockquote>
<p>import {BrowserRouter} from ‘react-router-dom’</p>
</blockquote>
<p>路由模式包裹根组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在index.js中</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>在App.js中导入包</p>
<blockquote>
<p>import {Route,Link} from ‘react-router-dom’<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/routerLink.png" alt=""></p>
</blockquote>
<p>除了Link的方法，还有一个<code>NavLink</code>，可以动态设置类名，当路由被激活时，被激活的路由会被添加一个<code>class=&quot;active&quot;</code>的类名</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在导入的包中加上Redirect</p>
<blockquote>
<p>import {Route,Link,Redirect} from ‘react-router-dom’</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">"/"</span> <span class="attr">to</span> "/<span class="attr">home</span>" <span class="attr">exact</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于Route的exact,加上exact代表当前路由path的路径采用精确匹配，比如说Home的path如果不加上exact,那么path=”/home”将会匹配他自己与path=”/“这两个，所以一般path=”/“这个路由一般会加上exact</p>
<h1 id="history、location、match"><a href="#history、location、match" class="headerlink" title="history、location、match"></a>history、location、match</h1><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>来介绍一下如何使用history插件管理浏览记录</p>
<p>React Router中很重要的一部分就是history package，他给react router提供了主要的功能。首先需要安装</p>
<blockquote>
<p>npm install –save history</p>
</blockquote>
<p>&emsp;&emsp;History能够确保SPA Project在<code>client-side</code>方便的添加基于位置的导航。一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。</p>
<p>&emsp;&emsp;在React Router中一共有三种类型的history，分别是<code>BrowserHistory</code> <code>HashHistory</code> <code>MemoryHistory</code>，React Router会自动的帮你创建这些history。<br><strong>What Is History?</strong></p>
<p>&emsp;&emsp;History可以是一个Object，不论是哪一种类型的history，产生的history object包含的属性都是一样的。Object 中要分成两部分：</p>
<ul>
<li>Location properties(下一小节)</li>
<li>Navigation(导航) Method</li>
</ul>
<p>&emsp;&emsp;History记录了整个访问历史中所有的location，维护了一个location的数组，并且还有一个index指向数组中当前的location。但是为了安全性你无法获取到这个location的数组，只能访问到当前的location。</p>
<ul>
<li><code>push</code>：这个方法允许你jump到一个新的location。这时候会push一个新的location到history数组。</li>
</ul>
<p>&emsp;&emsp;<code>history.push({ pathname: &#39;/new-place&#39; })</code>参数可以是location object也可以是一个url但是只有前者可以传数据。</p>
<p>&emsp;&emsp;当你click on a <Link> 将会使用<code>history.push</code>做navigation。</p>
<p>&emsp;&emsp;除此之外还有<code>Replace({ pathname: &#39;/go-here-instead&#39; });</code>,<code>goBack()</code>, <code>goForward()</code>, <code>go(-3)</code> 等Navigation的方式。</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>Location是一个Object，描述的是当你的spa停留的位置。Location Object是一个形如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//location对象表示当前的路由位置信息，主要包含如下属性</span></span><br><span class="line">&#123;</span><br><span class="line">  pathname: <span class="string">'/here'</span>,</span><br><span class="line">  search: <span class="string">'?key=value'</span>,</span><br><span class="line">  hash: <span class="string">'#extra-information'</span>,</span><br><span class="line">  state: &#123; <span class="attr">modal</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  key: <span class="string">'abc123'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>pathname</code> <code>search</code> <code>hash</code> 这三个都从URL中获取到的，注意为了安全性，history5 api只能获取到当前页面所在的location信息。</p>
<p>&emsp;&emsp;key：每一个Location都会有一个独一无二的key，唯一的代表一个Location，也用于存储数据到某一个对应的location。</p>
<p>&emsp;&emsp;state：想要传递数据给一个Location除了使用query将数据放在URL中带过来，也可以使用state，这个state相当于是放在这个location上的数据，这些数据不会出现在URL中。</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//match对象表示当前的路由地址是怎么跳转过来的，包含的属性如下</span></span><br><span class="line">&#123;</span><br><span class="line">    isExact: <span class="literal">true</span>, <span class="comment">// 表示匹配到当前路径是否是完全匹配</span></span><br><span class="line">    params: &#123;&#125;, <span class="comment">// 表示路径的动态参数值</span></span><br><span class="line">    path: <span class="string">'/c'</span>, <span class="comment">// 匹配到的原始路径</span></span><br><span class="line">    url: <span class="string">'/c'</span> <span class="comment">// 匹配到的实际路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















<h1 id="高阶组件withRouter"><a href="#高阶组件withRouter" class="headerlink" title="高阶组件withRouter"></a>高阶组件withRouter</h1><p>&emsp;&emsp;参数是一个组件，同时返回的也是一个组件。这类组件我们成为高阶组件(HOC)</p>
<p>&emsp;&emsp;withRouter作用：让不是路由切换的组件将react-router 的 history、location、match 三个对象传入props对象上</p>
<p>&emsp;&emsp;默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面</p>
<p>&emsp;&emsp;然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>&emsp;&emsp;比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法调用props中的<code>history</code>、<code>location</code>、<code>match</code>等属性。</p>
<p>设置withRouter很简单只需要两步：</p>
<ul>
<li>1.引入 </li>
<li>2.将App组件 withRouter() 一下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Switch,Route,NavLink,Redirect,withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span> <span class="comment">//引入withRouter</span></span><br><span class="line"><span class="keyword">import</span> One <span class="keyword">from</span> <span class="string">'./One'</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">'./NotFound'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时才能获取this.props,包含（history, match, location）三个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);  <span class="comment">//输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125;</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div className='app'&gt;</span></span><br><span class="line"><span class="string">            &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">            &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">            &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt;</span></span><br><span class="line"><span class="string">                &lt;Redirect from='/' to='/one' exact /&gt;</span></span><br><span class="line"><span class="string">                &lt;Route component=&#123;NotFound&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(App);  <span class="comment">//这里要执行一下WithRouter</span></span><br></pre></td></tr></table></figure>
<h2 id="介绍一个简单应用"><a href="#介绍一个简单应用" class="headerlink" title="介绍一个简单应用"></a>介绍一个简单应用</h2><p>可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。</p>
<p>仍然是App.js组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Switch,Route,NavLink,Redirect,withRouter&#125; <span class="keyword">from</span>  <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> One <span class="keyword">from</span> <span class="string">'./One'</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">'./NotFound'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">                <span class="keyword">super</span>(props);</span><br><span class="line">                props.history.listen(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123;  <span class="comment">//在这里监听location对象</span></span><br><span class="line">                        <span class="built_in">console</span>.log(location.pathname);  <span class="comment">//切换路由的时候输出"/one/users"和"/one/companies"</span></span><br><span class="line">                        <span class="keyword">switch</span>(location.pathname)&#123;   <span class="comment">//根据路径不同切换不同的浏览器title</span></span><br><span class="line">                                <span class="keyword">case</span> <span class="string">'/one/users'</span> : <span class="built_in">document</span>.title = <span class="string">'用户列表'</span>; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">'/one/companies'</span> : <span class="built_in">document</span>.title = <span class="string">'公司列表'</span>; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="string">`&lt;div className='app'&gt;</span></span><br><span class="line"><span class="string">                        &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">                        &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">                        &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                                &lt;Route path='/one/:type?'  component=&#123;One&#125; /&gt;</span></span><br><span class="line"><span class="string">                                &lt;Redirect from='/' to='/one' exact /&gt;</span></span><br><span class="line"><span class="string">                                &lt;Route component=&#123;NotFound&#125; /&gt;</span></span><br><span class="line"><span class="string">                        &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span></span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(App);</span><br></pre></td></tr></table></figure>
<p>同时，我们可以进行编程式导航：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/home")&#125;&#125;&gt;点我去home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/phone")&#125;&#125;&gt;点我去phone<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user")&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h1><h2 id="params方式进行传参"><a href="#params方式进行传参" class="headerlink" title="params方式进行传参"></a>params方式进行传参</h2><ul>
<li>1.需要在路由规则中设置传递的接受参数   :xxx</li>
<li>2.发送参数,直接在跳转路径后进行编写</li>
<li>3.接受:props.match.params.参数名</li>
</ul>
<p><strong>优势:刷新地址,参数依然存在</strong></p>
<p><strong>缺点:只能传递字符中,并且参数过多的时候url会变得比较丑陋</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/phone/:id")&#125;&#125;&gt;点我去phone<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user/我是参数")&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子路由中接受 --&gt;</span></span><br><span class="line">let id = this.props.match.params</span><br></pre></td></tr></table></figure>
<h2 id="query方式进行传参"><a href="#query方式进行传参" class="headerlink" title="query方式进行传参"></a>query方式进行传参</h2><ul>
<li>1.不需要再路由规则中进行传递参数的配置</li>
<li>2.直接发送数据</li>
<li>3.使用 this.props.location.query.xxx<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/phone",query:&#123;name:"小明"&#125;)&#125;&#125;&gt;点我去phone<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user",query:&#123;name:"小刚"&#125;)&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子路由中接受 --&gt;</span></span><br><span class="line">let name = this.props.location.query.name</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（二）组件的状态state、ref转发</title>
    <url>/MyBlog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><font color="red" size="4px"><strong>ATTATION!</font>本文由于html代码无法高亮显示，用   ``  包裹，实际代码没有这个符号</strong></p>
<h1 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h1><h2 id="state-和props的区别"><a href="#state-和props的区别" class="headerlink" title="state 和props的区别"></a>state 和props的区别</h2><ul>
<li>props是组件对外的接口</li>
<li>state是组件对内的接口</li>
</ul>
<p>&emsp;&emsp;组件内可以引用其他组件，组件之间的引用就形成了一个树状的接口。如果下层组件需要使用上层组件的数据，上层组件就可以通过下层组件中props来进行数据的传递。因此props就是组件对外的接口</p>
<p>&emsp;&emsp;组件除了使用上层组件传递的数据之外，他自身也可能有需要管理的数据。这个对内管理数据的属性就是state</p>
<p>&emsp;&emsp;react中我们只需要关心的是数据。当数据改变的时候页面就会自动的发生改变。状态等同于页面中的数据；状态/数据改变了，页面中对应的数据绑定内容就会被react自动的进行改变</p>
<p>主要区别：</p>
<ul>
<li>state是 可变的</li>
<li>props对于当前页面的组件来说他是只读。如果我们想修改props中的数据那么我们要修改传递给当前组件数据的父组件中的内容</li>
</ul>
<p><strong>如果想使用状态，不能使用无状态组件（函数组件）</strong></p>
<a id="more"></a>
<h2 id="创建state入门代码"><a href="#创建state入门代码" class="headerlink" title="创建state入门代码"></a>创建state入门代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span> . <span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="comment">//在ES6中不管子类写不写constructor 在new实例的时候都会补上constructor</span></span><br><span class="line"><span class="comment">//我们可以不写但是如果我们写了constructor 之后就必须在其中写上super() 就是指向父类的构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="comment">//如果想在consternation使用props那么super中必须写上props</span></span><br><span class="line">        <span class="keyword">super</span>(props )</span><br><span class="line">        <span class="comment">//定义state</span></span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            name :<span class="string">"西西"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;我是一个组件--- &#123;this.state.name&#125;&lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="string">`&lt;Com /&gt;`</span>,documen.getElementById(<span class="string">" demoReact"</span>));</span><br></pre></td></tr></table></figure>
<p>如果我们想要改变state中的数据，就要用到<code>setState</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="comment">// this. setState( &#123;key:newValue&#125;)是异步的 当我们触发了setState后，react就会自动的触发render进行数据的渲染</span></span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;&#123;this.setState( &#123;name :"哈哈"&#125;&#125;&#125;&gt;点我改变state的数据 &lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;我是一个组件-----&#123;this.state.name&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="state进阶"><a href="#state进阶" class="headerlink" title="state进阶"></a>state进阶</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.setState()是异步的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props) </span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            name:<span class="string">"西西"</span>,</span><br><span class="line">            newHtml:<span class="string">"&lt;p&gt;我是state中的内容&lt;/p&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">        fun=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                name : <span class="string">"haha"</span></span><br><span class="line">        &#125;,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;button onClick=&#123;this.fun&#125;&gt;点我修改&lt;/button&gt;</span></span><br><span class="line"><span class="string">                &#123;this.state.name&#125;</span></span><br><span class="line"><span class="string">                &lt;div&gt;&#123;this.state.newHtml&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">                 //输出&lt;p&gt;我是state中的内容&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &#123;/*字符串标签插入的话 dangerouslySetInnderHTML=&#123;&#123;_HTML:你要插入的字符串&#125;&#125;*/&#125;</span></span><br><span class="line"><span class="string">                &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: this.state .newHtm1&#125;&#125;&gt;&lt;/ div&gt;</span></span><br><span class="line"><span class="string">                //输出 我是state中的内容 </span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>转发refs</p>
<p>react当中提供了一个ref的数据，表示当前组件的真正实例的引用，他会返回绑定当前属性的元素。他能标识组件内部的元素，方便我们查找</p>
<p>但是<strong>不能在无状态组件当中进行使用</strong>，因为无状态组件没有实例。</p>
<p>react给我们3种方式进行ref的使用</p>
<ul>
<li>字符串的方式</li>
<li>回调函数(推荐)</li>
<li>React.createRef() (react16.3新提供的一种方式)</li>
</ul>
<h2 id="字符串方式"><a href="#字符串方式" class="headerlink" title="字符串方式"></a>字符串方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    fun=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.demoInput.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是组件</span><br><span class="line">                &lt;input type=<span class="string">" text"</span> ref=<span class="string">"demoInput"</span> placeholder=<span class="string">" 请输入"</span>/&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.fun&#125;&gt;点我得到输入框的值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回调函数方式（推荐）"><a href="#回调函数方式（推荐）" class="headerlink" title="回调函数方式（推荐）"></a>回调函数方式（推荐）</h2><p>就是在dom节点上或者组件上挂载函数，函数的形参是dom结点，他的效果和字符串的方式是一样的，都是获取值的引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    fun=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.textInput.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                我是组件</span></span><br><span class="line"><span class="string">                &lt;input type=" text" ref=&#123;(input)=&gt;&#123;this.textInput=input&#125; placeholder=" 请输入"/&gt;</span></span><br><span class="line"><span class="string">                // 这里的input代表当前元素</span></span><br><span class="line"><span class="string">                &lt;button onClick=&#123;this.fun&#125;&gt;点我得到输入框的值&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef()"></a>React.createRef()</h2><p>把值赋给一个变量，通过ref挂载在节点或者组件上。使用ref的current属性拿到这个节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.myRef=React.creatRef()</span><br><span class="line">    &#125;</span><br><span class="line">    fun=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.myRef.current.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                我是组件</span></span><br><span class="line"><span class="string">                &lt;input type=" text" ref=&#123;this.myRef&#125; placeholder=" 请输入"/&gt;</span></span><br><span class="line"><span class="string">                // 这里的input代表当前元素</span></span><br><span class="line"><span class="string">                &lt;button onClick=&#123;this.fun&#125;&gt;点我得到输入框的值&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*<em>官方当中建议我们不要过度的使用refs对逻辑进行处理,需要优先考虑state<br>*</em></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（六）hook、redux</title>
    <url>/MyBlog/2020/07/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h1><p>Hook是react中16.7新增的一个特性，主要是用来让无状态组件可以使用状态。在react开发中状态的管理是必不可少的，以前 为了进行状态管理，需要使用类组件或者redux等来管理</p>
<h2 id="在类组件中使用状态："><a href="#在类组件中使用状态：" class="headerlink" title="在类组件中使用状态："></a>在类组件中使用状态：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">        text:<span class="string">"我是状态数据"</span></span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                hello----&#123;this.state.text&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="在无状态组件中使用状态："><a href="#在无状态组件中使用状态：" class="headerlink" title="在无状态组件中使用状态："></a>在无状态组件中使用状态：</h2><p>可以使用react Hook 中的<code>useState</code>来进行实现</p>
<ul>
<li><code>useState</code>是来定义一个状态的，他与类组件的状态不同，函数组件的状态可以是对象也可以是基础类型数据。</li>
<li><code>useState</code>返回的是一个<strong>数组</strong>。第一个参数是<strong>当前的状态值</strong>。第二个参数是对象，表明<strong>用于更改状态的函数</strong>(类似于setstate )</li>
</ul>
<p>1、先来导包</p>
<blockquote>
<p>import {useState} from ‘react’</p>
</blockquote>
<p>2、具体用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [val, setVal] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//解构赋值到val，setVal上</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div className= "App"&gt; </span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">            使用数据:&#123;val&#125;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、如果有多个状态怎么办？</p>
<ul>
<li>1.声明对象类型的状态</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [val, setVal] = useState(&#123;</span><br><span class="line">        vala:<span class="number">1</span>,</span><br><span class="line">        valb:<span class="number">2</span>,</span><br><span class="line">        valc:<span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div className= "App"&gt; </span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">            使用数据:&#123;val.vala&#125;---&#123;val.valb&#125;---&#123;val.valc&#125;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改&lt;/button&gt;</span></span><br><span class="line"><span class="string">            // 至于修改，要用其他方式</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.多次声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [vala, setVala] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> [valb, setValb] = useState(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> [valc, setValc] = useState(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`&lt;div className= "App"&gt; </span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">            使用数据:&#123;val.vala&#125;---&#123;val.valb&#125;---&#123;val.valc&#125;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改&lt;/button&gt;</span></span><br><span class="line"><span class="string">            // 至于修改，要用其他方式</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>&emsp;&emsp;<code>redux</code> 是javascript提供的一个可预测性<code>(我们给个固定的输入 那么必定可以等到一个结果)</code>的状态容器。<code>redux</code>是个专门的状态管理库，并不是react独有的。在vue等当中也可以使用 但是在react中会比较多。</p>
<p>&emsp;&emsp;<code>redux</code>的作用就是集中的管理react中多个组件的状态</p>
<h2 id="需求场景："><a href="#需求场景：" class="headerlink" title="需求场景："></a>需求场景：</h2><ul>
<li>某个组件的状态需要共享的时候</li>
<li>个组件需要改变另外一个组件状态的时候</li>
<li>组件中的状态需要在任何地方都可以拿到<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2></li>
</ul>
<p><strong>1.单一数据源</strong> </p>
<p>&emsp;&emsp;整个react中的状态都会被统一的管理到<code>store</code></p>
<p><strong>2.state是只读的</strong></p>
<p>&emsp;&emsp;我们不能够直接改变<code>state</code>而是要通过触发<code>redux</code>中的特定方法来进行修改</p>
<p><strong>3.使用纯函数来执行修改操作</strong> </p>
<p>&emsp;&emsp;我们要用<code>action</code>来改变redux中的state</p>
<h2 id="redux的使用"><a href="#redux的使用" class="headerlink" title="redux的使用"></a>redux的使用</h2><p>1、下载</p>
<blockquote>
<p>npm install –save redux</p>
</blockquote>
<p>2、首先在src下新建一个<code>redux</code>目录，在该目录下创建一个<code>reducer.js</code>文件</p>
<p>&emsp;&emsp;它有点像一个指挥中心，根据传进来的类型分配任务。它负责接收组件传递的<code>action</code>，根据<code>action</code>的类型来进行数据的修改，函数接收两个参数，第一个<code>state</code>,为store存储的状态，可以给它赋初始值，第二个为<code>action</code>（动作）,action是一个对象，可以传递type和其他的值进去</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/reducer.png" alt=""></p>
<p>3、在redux文件夹下新建一个<code>store.js</code>文件，导入刚刚的<code>reducer.js</code>文件。</p>
<p>&emsp;&emsp;<code>store.js</code>接收<code>reducer.js</code>的导出为参数并使用redux提供的<code>createStore()</code>方法创建一个数据源<code>store</code>，在<code>store.js</code>中写代码：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/store.png" alt=""></p>
<p>4、在components文件夹下的<code>Home.js</code>组件中使用store中的值<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/store%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt=""></p>
<p><strong>修改操作</strong><br>1、所有的修改操作都要调用一个action，所以，我们在redux文件夹下新建一个文件<code>action.js</code></p>
<p>2、设置操作</p>
<p>在<code>action.js</code>中定义两个如下操作</p>
<p>&emsp;&emsp;<code>action.js</code>中定义一些方法用于Home组件的动作分发(<code>dispatch()</code>)，这里的<code>type</code>其实就是对应<code>reducer.js</code>的<code>action.type</code><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/action.js.png" alt=""></p>
<p>3、回到reducer.js文件添加对action的判断<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BF%AE%E6%94%B9reducer.js.png" alt=""></p>
<p>4、在组件中调用dispatch()更新方法来进行data数据的修改<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/action%E8%B0%83%E7%94%A8%E6%88%90%E5%8A%9F.png" alt=""><br>dispatch作用：发送用户请求并去更新state</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs异步编程</title>
    <url>/MyBlog/2020/07/01/Nodejs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="同步api-异步api"><a href="#同步api-异步api" class="headerlink" title="同步api,异步api"></a>同步api,异步api</h1><p>同步API:只有当前API执行完成后,才能继续执行下一个API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line"><span class="comment">//输出before after</span></span><br></pre></td></tr></table></figure>
<p>异步API:当前API的执行不会阻塞后续代码的执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>) ;</span><br><span class="line">setTimeout (</span><br><span class="line">    () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'last'</span>) ;</span><br><span class="line">&#125;，<span class="number">2000</span>) ;</span><br><span class="line"><span class="built_in">console</span>. log(<span class="string">'after'</span>) ;</span><br><span class="line"><span class="comment">//输出after before</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="同步api，异步api的区别（获取返回值）"><a href="#同步api，异步api的区别（获取返回值）" class="headerlink" title="同步api，异步api的区别（获取返回值）"></a>同步api，异步api的区别（获取返回值）</h1><p>同步API可以从返回值中拿到API执行的结果，但是异步API是不可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">n1, n2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = sum (<span class="number">10</span>， <span class="number">20</span>) ;</span><br><span class="line"><span class="comment">//输出30</span></span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">msg</span>: <span class="string">'Hello Node. js'</span> &#125;</span><br><span class="line">    &#125;，<span class="number">2000</span>) ;</span><br><span class="line"><span class="keyword">const</span> msg = getMsg() ;</span><br><span class="line"><span class="comment">//msg=undefined</span></span><br></pre></td></tr></table></figure>
<p>那么，异步api的返回值要怎么拿到呢？可以通过回调函数</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>自己定义，让别人去调用<br>来看一个简单的栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'callback函数被调用了'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>把函数当做参数传递，我们还可以给传递的函数再加一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback(<span class="string">'123'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'callback函数被调用了'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>如果getData这个函数内部有异步操作，那么在异步操作执行完成的时候，就会调用回调函数，并且把异步api执行的结果通过参数的形式传递给callback，那么在getData里面的回调函数里面就能拿到这个异步api执行的结果</strong><br>来看一个定时器的异步例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(&#123;</span><br><span class="line">            msg: <span class="string">'hello node.js'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">getMsg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="异步编程代码执行顺序分析"><a href="#异步编程代码执行顺序分析" class="headerlink" title="异步编程代码执行顺序分析"></a>异步编程代码执行顺序分析</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">'代码开始执行'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2s'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">setTimeout (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'0s'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span> . log( <span class="string">'代码结束执行'</span>)</span><br><span class="line"><span class="comment">//输出结果：代码开始执行  代码结束执行 0s 2s</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt=""></p>
<p>当同步代码执行结束后，开始执行异步代码，0秒执行的定时器先执行完，系统调用他的回调函数</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F1.png" alt=""></p>
<p>然后，2秒钟之后执行的定时器也执行完，加入到执行队列中</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F2.png" alt=""></p>
<p>大功告成！</p>
<h1 id="Node-js中的异步api"><a href="#Node-js中的异步api" class="headerlink" title="Node.js中的异步api"></a>Node.js中的异步api</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./demo. txt'</span>,(err, result) =&gt;&#123;&#125;) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http. createServer() ;</span><br><span class="line">server.on(<span class="string">' request'</span>，(req, res) =&gt; &#123;&#125;) ;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢?</p>
<p>现在，我们有个需求：依次读取A文件、B文件、C文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span> );</span><br><span class="line"></span><br><span class="line">fs. readFile(<span class="string">'./1.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result1 )</span><br><span class="line">    fs .readFile(<span class="string">'./2.txt'</span>, <span class="string">'utf8'</span>, (err, result2) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>. log(result2)</span><br><span class="line">        fs.readFile(<span class="string">'./3.txt'</span>, <span class="string">' utf8'</span>, (err, result3) =&gt;</span><br><span class="line">            <span class="built_in">console</span> . log(result3)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们无限嵌套下去，发生了回调地狱。ES6为我们提供了一个promise的方法来解决回调地狱</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise出现的目的是解决Nodejs异步编程中回调地狱的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            resolve (&#123;<span class="attr">name</span>: <span class="string">'张三'</span> &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'失败了'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="number">2000</span>) ;</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure>
<ul>
<li>当异步api有返回结果时，可以调用resolve函数，并把异步api的执行结果通过参数形式传递</li>
<li>当异步api执行失败，我们就可以调用reject这个函数，把这个失败的结果传递到promise外面</li>
</ul>
<p>我们在promise外面怎么拿到异步api的执行结果呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then (<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result) ; <span class="comment">// (name: '张三'&#125;</span></span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error) ;<span class="comment">// 失败了)</span></span><br></pre></td></tr></table></figure>
<p>对promise有个了解后，我们来实现需求,先读取一个文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>( <span class="string">'fs'</span> );</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    fs.readFile(<span class="string">'./1. txt'</span>, <span class="string">'utf8'</span>, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(result); </span><br><span class="line">            <span class="comment">//异步api执行成功后调用resolve，其实就是调用then里面的()=&gt;&#123;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们改造一下，利用promise解决回调地狱</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./1.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result1)</span><br><span class="line">             <span class="comment">//异步api执行成功后调用resolve，其实就是调用then里面的()=&gt;&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./2.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result2)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./3.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="keyword">return</span> p2();<span class="comment">//这里的p2是一个promise对象，相当于return了一个promise对象，然后对这个promise对象调用.then方法</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result2)</span><br><span class="line">    <span class="keyword">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result3</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><p>异步函数是ES7中新增方法，异步函数是异步编程语法的终极解决方案,它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套,使代码变得清晰明了。<br><strong>async关键字</strong></p>
<ul>
<li>在普通函数前面加上async关键字，普通函数就变成了异步函数</li>
<li>异步函数默认返回值是promise对象</li>
<li>在异步函数内部使用return关键字进行结果返回结果会被包裹的promise对象中return关键字代替了resolve方法</li>
<li>在异步函数内部使用throw关键字抛出程序异常</li>
<li>调用异步函数再链式调用then方法获取异步函数执行结果</li>
<li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li>
</ul>
<p><strong>await关键字</strong></p>
<ul>
<li>它只能出现在异步函数中</li>
<li>await  promise它可以暂停异步函数的执行等待promise对象返回结果后再向下执行</li>
<li>await promise await后面只能写promise对象，写其他类型的API是不可以的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p1'</span>;</span><br><span class="line">    <span class="comment">//async修饰的函数返回一个promise对象</span></span><br><span class="line">    <span class="comment">//return promise&#123;'p1'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> p1()</span><br><span class="line">    <span class="keyword">let</span> r2 = <span class="keyword">await</span> p2()</span><br><span class="line">    <span class="keyword">let</span> r3 = <span class="keyword">await</span> p3()</span><br><span class="line">    <span class="built_in">console</span>.log(r1)</span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(r2)</span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(r3)</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"><span class="comment">//输出 p1 p2 p3 把异步操作写成了同步代码</span></span><br></pre></td></tr></table></figure>
<p>现在，我们用async、await改造读取文件顺序输出需求</p>
<p>&emsp;&emsp;首先，我们知道，<code>fs.readFile()</code>方法是通过返回值的方法来获取文件的读取结果，也就是说，他不返回promise对象，没办法加async/await关键字,后来，nodejs为我们提供了一个<code>promisify</code>方法，可以对现有的异步api进行包装，让方法返回promise对象，以支持异步函数语法</p>
<blockquote>
<p>const promisify = require(‘util’).promisify</p>
</blockquote>
<p>我们开始</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//改造现有异步函数api让其返回promise对象从而支持异步函数语法</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>( <span class="string">'util'</span> ).promisify;</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs. readFile);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(r1)</span><br><span class="line">    <span class="built_in">console</span>.log(r2)</span><br><span class="line">    <span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（四）json-server与axios、跨域请求</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server可以开启一个端口模拟服务端的数据</p>
<h2 id="安装json-server"><a href="#安装json-server" class="headerlink" title="安装json-server"></a>安装json-server</h2><blockquote>
<p>npm install json-server -g</p>
</blockquote>
<p>安装完成后，我们来创建一个data.json文件放在mock文件夹中<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/datejson.png" alt=""></p>
<a id="more"></a>
<p>cd到mock文件夹下，启动json-server</p>
<blockquote>
<p>json-server json数据名字 –port 5000</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/datajson%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt=""><br>启动成功，我们进到浏览器或者用postman测试接口<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%B5%8B%E8%AF%95jsonserver.png" alt=""></p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>安装</p>
<blockquote>
<p>npm install –save axios</p>
</blockquote>
<p>引入axios</p>
<blockquote>
<p>import axios from ‘axios’</p>
</blockquote>
<p>在钩子函数componentDidMount()中使用axios</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/axios%E5%AF%BC%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8.png" alt=""><br>请求成功！<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/axios%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F.png" alt=""></p>
<h1 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h1><ul>
<li>1、正向代理–开发环境</li>
</ul>
<p>&emsp;&emsp;一个位于客户端和目标服务器之间的代理服务器。为了获取到目标服务器的内容，客户端向代理服务器发送一个请求，代理服务器帮助我们去目标服务器里面获取数据且并返回给我们</p>
<ul>
<li>2、反向代理–上线环境</li>
</ul>
<p>&emsp;&emsp;可以通过代理服务器来接受网络上的请求连接，然后将这个请求转发给内部的网络服务器上并且把这个服务器上得到的数据返回给网络请求的客户端。这个时候代理服务器对外的表现就是一个反向代理</p>
<p>模拟请求真实的网络接口:中国天气网中的数据<br>找到文件项目\node modules\react-scripts\config\webpackDevServer.config.js</p>
<p>找到proxy进行修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy:&#123;</span><br><span class="line">    <span class="string">"/api"</span>:&#123;</span><br><span class="line">    target:<span class="string">"http://www.weather.com.cn/data/cityinfo"</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span> ,</span><br><span class="line">    <span class="string">"pathRewrite"</span>:&#123;</span><br><span class="line">    <span class="string">"^/api"</span>:<span class="string">"/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在需要的axios请求中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">"/api/161320101.html"</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的原型和原型链</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>在ES6之前，面向对象是通过构造函数来实现的。构造函数的方法很好用，但是存在一个<strong>浪费内存</strong>的问题。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gouzaohanshu.png" alt=""></p>
<p>如图，每创建一个对象，都要开辟一个新的内存区域，<strong>我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？</strong></p>
<h1 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h1><a id="more"></a>
<p> &emsp;&emsp;构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。<br> JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。称为<strong><em>原型对象</em></strong></p>
<p> &emsp;&emsp;我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。这就是原型的作用</p>
<p> &emsp;&emsp;举个栗子<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决构造函数的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">star</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把sing方法挂载到原型上</span></span><br><span class="line">star.prototype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> star(<span class="string">'张学友'</span>, <span class="number">18</span>);</span><br><span class="line">ldh.sing()</span><br><span class="line">zxy.sing()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型<strong>proto</strong></h1><p> &emsp;&emsp;对象都会有一个属性<strong>proto</strong>指向构造数的prototype原型对象，之 以我们对可以使用构造函数prototype原型对象的性和方法，就是因为对象 <strong>proto</strong>原型的存在。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(ldh.__proto__===star.prototype);</span><br><span class="line"> <span class="comment">//输出结果为true</span></span><br><span class="line"> <span class="comment">//方法的查找规则：首先先看1dh对象身上是否有sing方法，如果有就执行这个对象上的sing</span></span><br><span class="line"><span class="comment">//如果么有sing这个方法，因为有_proto的存在，就去构造函数原型对象prototype身上去查找sing这个方法I</span></span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;proto对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/proto.png" alt=""></p>
<hr>
<h1 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h1><p>&emsp;&emsp;对象原型（ <em>proto</em> ）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(star.prototype.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(ldh.__proto__.constructor);</span><br><span class="line"><span class="comment">//输出的都是star这个构造函数</span></span><br></pre></td></tr></table></figure>
<p>当我们想在prototype上添加多个方法的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.prototype=&#123;</span><br><span class="line">    sing:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    movie:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会演电影'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个时候，protptype被完全覆盖掉了</strong><br>我们就要添加一个语句让prototype重新指回构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>: star</span><br><span class="line">//如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用<span class="keyword">constructor</span>指回原来的构造函数</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png" alt=""></p>
<hr>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>&emsp;&emsp;<strong>只要是对象就有_proto原型，指向原型对象</strong></p>
<p>一张图看懂原型链：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li><p>我们star原型对象里面的_proto_原型指向的是Object.prototype</p>
</li>
<li><p>我们object.prototype原型对象里面的_proto_原型指向为null</p>
</li>
</ul>
<hr>
<h1 id="JavaScript的成员查找机制（规则）"><a href="#JavaScript的成员查找机制（规则）" class="headerlink" title="JavaScript的成员查找机制（规则）"></a>JavaScript的成员查找机制（规则）</h1><ul>
<li><p>当访问一个对象的属性（包括方法）时，首先找这个<strong>对象自身</strong>有没有该属性。</p>
</li>
<li><p>如果没有就查找它的原型（也就是_proto_指向的（<strong>prototype原型对象</strong>）。</p>
</li>
<li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p>
</li>
<li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p>
</li>
</ul>
<hr>
<h1 id="原型对象中的this指向问题"><a href="#原型对象中的this指向问题" class="headerlink" title="原型对象中的this指向问题"></a>原型对象中的this指向问题</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.protptype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sing'</span>)</span><br><span class="line">    that = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment">//在构造函数中，里面this指向的是对象实例ldh</span></span><br><span class="line">ldh.sing();</span><br><span class="line"><span class="built_in">console</span>.log(that === <span class="keyword">this</span>) </span><br><span class="line"><span class="comment">//输出结果为true</span></span><br><span class="line"><span class="comment">//原型对象函数里面的this 指向的是实例对象ldh</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>js中字符串常用方法</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>1、toLowerCase(): 把字符串转为小写，返回新的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toLowerCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<p>2、toUpperCase(): 把字符串转为大写，返回新的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//HELLO WORLD</span></span><br></pre></td></tr></table></figure>
<hr>
<p>3、charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charAt(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>4、charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charCodeAt(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.charCodeAt(<span class="number">-2</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//101</span></span><br></pre></td></tr></table></figure>
<hr>
<p>5、indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.indexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.indexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.indexOf(<span class="string">"o"</span>,str1+<span class="number">1</span>);<span class="comment">//注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//4 默认只找第一个关键字位置，从下标0开始查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1 没有找到</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<hr>
<p>6、lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.lastIndexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.lastIndexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.lastIndexOf(<span class="string">"o"</span>,str1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//注意：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>7、slice(): 返回字符串中提取的子字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.slice(<span class="number">2</span>); <span class="comment">//如果只有一个参数，则提取开始下标到结尾处的所有字符串</span></span><br><span class="line"><span class="keyword">var</span> str2=str.slice(<span class="number">2</span>,<span class="number">7</span>); <span class="comment">//两个参数，提取下标为2，到下标为7但不包含下标为7的字符串</span></span><br><span class="line"><span class="keyword">var</span> str3=str.slice(<span class="number">-7</span>,<span class="number">-2</span>); <span class="comment">//如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//llo W</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//o Wor</span></span><br></pre></td></tr></table></figure>
<hr>
<p>8、substring(): 提取字符串中介于两个指定下标之间的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substring(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substring(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substring(<span class="number">2</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//如果两个参数相等，返回长度为0的空串</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//llo W</span></span><br><span class="line"><span class="comment">//注意：substring()用法与slice()一样，但不接受负值的参数。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>9、substr(): 返回从指定下标开始指定长度的的子字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substr(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substr(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substr(<span class="number">-3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//ello World </span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//ell</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//rl</span></span><br><span class="line"><span class="comment">//注意：如果没有指定length,返回从下标开始处结尾处的所有字符串。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>10、split(): 把字符串分割成字符串数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"AA BB CC DD"</span>;</span><br><span class="line"><span class="keyword">var</span> string1=<span class="string">"1:2:3:4:5"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.split(<span class="string">""</span>);<span class="comment">//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割</span></span><br><span class="line"><span class="keyword">var</span> str2=str.split(<span class="string">" "</span>); <span class="comment">//以空格为分隔符</span></span><br><span class="line"><span class="keyword">var</span> str3=str.split(<span class="string">""</span>,<span class="number">4</span>); <span class="comment">//4指定返回数组的最大长度</span></span><br><span class="line"><span class="keyword">var</span> str4=string1.split(<span class="string">":"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//["AA" "BB" "CC" "DD"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//["A", "A", " ", "B"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str4); <span class="comment">// ["1", "2", "3", "4", "5"]</span></span><br></pre></td></tr></table></figure>
<hr>
<p>11、replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello WORLD"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/o/ig</span>; <span class="comment">//o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。</span></span><br><span class="line"><span class="keyword">var</span> str1=str.replace(reg,<span class="string">"**"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hell** W**RLD</span></span><br></pre></td></tr></table></figure>
<hr>
<p>12、match(): 返回所有查找的关键字内容的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"To be or not to be"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/to/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//["To", "to"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="string">"Hello"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>原文地址：<a href="https://www.cnblogs.com/Yimi/p/10362214.html" target="_blank" rel="noopener">JS字符串常用方法总结</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的常用数组方法</title>
    <url>/MyBlog/2020/06/18/js%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>JavaScript中创建数组有两种方式</strong></p>
<ul>
<li>使用 Array 构造函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// 创建一个包含20项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(“lily”,“lucy”,“Tom”); <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
<li>使用数组字面量表示法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = []; <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">20</span>]; <span class="comment">// 创建一个包含1项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [“lily”,“lucy”,“Tom”]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数组的方法有数组原型方法，也有从object对象继承来的方法，这里我们只介绍数组的原型方法，数组原型方法主要有以下这些:</strong></p>
<a id="more"></a>
<h1 id="1、join"><a href="#1、join" class="headerlink" title="1、join()"></a>1、join()</h1><p>join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"-"</span>)); <span class="comment">// 1-2-3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2、push-和pop"><a href="#2、push-和pop" class="headerlink" title="2、push()和pop()"></a>2、push()和pop()</h1><ul>
<li>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</li>
<li>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack", "Sean"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Sean</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="3、shift-和-unshift"><a href="#3、shift-和-unshift" class="headerlink" title="3、shift() 和 unshift()"></a>3、shift() 和 unshift()</h1><ul>
<li>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。</li>
<li>unshift:将参数添加到原数组开头，并返回数组的长度 。<br>这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//["Jack", "Sean", "Lily", "lucy", "Tom"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Sean", "Lily", "lucy", "Tom"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="4、sort"><a href="#4、sort" class="headerlink" title="4、sort()"></a>4、sort()</h1><p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。<br>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort()); <span class="comment">// ["a", "b", "c", "d"]</span></span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [13, 24, 3, 51]</span></span><br><span class="line"><span class="comment">//[1,2,3,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [13, 24, 3, 51](原数组被改变)</span></span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>
<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [51, 24, 13, 3]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="5、reverse"><a href="#5、reverse" class="headerlink" title="5、reverse()"></a>5、reverse()</h1><p>reverse()：反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); <span class="comment">//[3, 51, 24, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure>
<h1 id="6、concat"><a href="#6、concat" class="headerlink" title="6、concat()"></a>6、concat()</h1><p>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.concat(<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); <span class="comment">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure>
<p>从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrCopy2 = arr.concat([<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2); <span class="comment">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2[<span class="number">5</span>]); <span class="comment">//[11, 13]</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p>
<hr>
<h1 id="7、slice"><a href="#7、slice" class="headerlink" title="7、slice()"></a>7、slice()</h1><ul>
<li>slice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</li>
<li>使用 start（包含） 和 end（不包含） 参数来指定字符串提取的部分。</li>
<li>字符串中第一个字符位置为 0, 第二个字符位置为 1, 以此类推。</li>
</ul>
<p>提示： 如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取所有字符串:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//Hello world! </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置提取字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo world! </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置到第8个位置直接的字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo wo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只提取第1个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//H </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取最后一个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//!</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="8、splice"><a href="#8、splice" class="headerlink" title="8、splice()"></a>8、splice()</h1><p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。<br>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrRemoved = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved); <span class="comment">//[1, 3]</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 7, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved2); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved3); <span class="comment">//[7]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="9、indexOf-和-lastIndexOf"><a href="#9、indexOf-和-lastIndexOf" class="headerlink" title="9、indexOf()和 lastIndexOf()"></a>9、indexOf()和 lastIndexOf()</h1><ul>
<li>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的开头（位置 0）开始向后查找。</li>
<li>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>)); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>,<span class="number">2</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>,<span class="number">4</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">"5"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="10、forEach"><a href="#10、forEach" class="headerlink" title="10、forEach()"></a>10、forEach()</h1><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：value(每个元素)；index（该元素索引）；arry（该数组本身）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11、map"><a href="#11、map" class="headerlink" title="11、map()"></a>11、map()</h1><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>下面代码利用map方法实现数组中每个数求平方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12、filter"><a href="#12、filter" class="headerlink" title="12、filter()"></a>12、filter()</h1><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || value &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="13、every"><a href="#13、every" class="headerlink" title="13、every()"></a>13、every()</h1><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">10</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="14、some"><a href="#14、some" class="headerlink" title="14、some()"></a>14、some()</h1><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">1</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="15、reduce-和-reduceRight"><a href="#15、reduce-和-reduceRight" class="headerlink" title="15、reduce()和 reduceRight()"></a>15、reduce()和 reduceRight()</h1><ul>
<li>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</li>
<li>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</li>
<li>传给 reduce()和 reduceRight()的函数接收 4 个参数：<strong>前一个值</strong>、<strong>当前值</strong>、<strong>项的索引</strong>和<strong>数组对象</strong>。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</li>
</ul>
<p>下面代码用reduce()实现数组求和，数组一开始<strong>加了一个初始值10</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的学习使用</title>
    <url>/MyBlog/2020/06/12/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%86%B2%E5%86%B2%E5%86%B2/</url>
    <content><![CDATA[<h1 id="杨雨翔"><a href="#杨雨翔" class="headerlink" title="杨雨翔"></a>杨雨翔</h1><h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>

<ul>
<li>列表1</li>
<li>列表2<br>  a 子列表<br>  b 子列表</li>
<li>列表3</li>
</ul>
<hr>
<hr>
<p><a href="https://gitee.com/yang_yu_xiang">我的gitee导航</a><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/psb.jpg" alt="插入图片"></p>
<p><em>字体变成斜的</em><br><strong>字体加粗了呀</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>哈哈嘻嘻</code></p>
<blockquote>
<p>我的内容是引用的哈哈</p>
</blockquote>
<p><code>在视频连接中插入 class=&quot;bilibili&quot;</code></p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=286039785&bvid=BV1mf4y1y7pp&cid=202160057&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解js的防抖和节流</title>
    <url>/MyBlog/2020/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>&emsp; 防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，处理不当或者放任不管就容易会加重浏览器和服务器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 </p>
<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p><code>函数防抖（debounce）</code>：当<strong>持续触发事件</strong>时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就<strong>重新开始延时</strong>。</p>
<p>一起来实现个简单的debounce</p>
<a id="more"></a>
<h2 id="防抖debounce代码："><a href="#防抖debounce代码：" class="headerlink" title="防抖debounce代码："></a>防抖debounce代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">"debounce"</span>);</span><br><span class="line">    myDebounce.addEventListener(<span class="string">"click"</span>,debounce(sayDebounce));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖功能函数，接受传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//每次当用户点击、输入的时候，把前一个定时器消除</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">//创建一个新的setTimeout，这样能保证点击按钮后的间隔内，</span></span><br><span class="line">        <span class="comment">//如果用户还点击的话，就不会执行fn函数</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖事件的处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p><code>函数节流（throttle）</code>：当<strong>持续触发事件</strong>时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如<strong>持续触发scroll事件时，并不立即执行scroll事件触发的函数，每隔一定时间才会执行一次scorll事件触发的函数</strong>。</p>
<h2 id="节流throttle代码（定时器）："><a href="#节流throttle代码（定时器）：" class="headerlink" title="节流throttle代码（定时器）："></a>节流throttle代码（定时器）：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">"throttle"</span>);</span><br><span class="line">    myThrottle.addEventListener(<span class="string">"click"</span>,throttle(sayThrottle));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在函数开头判断标志是否为true，不为true则中断函数</span></span><br><span class="line">        <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将canRun设置为false，防止执行之前再被执行</span></span><br><span class="line">        canRun  = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//定时器</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">//执行完事件(例如调用完接口)之后，重新将这个标志设true</span></span><br><span class="line">            canRun  = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要节流的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h1><p>讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景：</p>
<ul>
<li>搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。</li>
<li>页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）</li>
</ul>
<p>参考文章：<a href="https://segmentfault.com/a/1190000018428170" target="_blank" rel="noopener">浅谈js的防抖和节流</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的闭包</title>
    <url>/MyBlog/2020/06/19/%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量根据作用域的不同分为两种:全局变量和局部变量。</p>
<ul>
<li>1.函数内部可以使用全局变量。</li>
<li>2.函数外部不可以使用局部变量。</li>
<li>3.当函数执行完毕,本作用域内的局部变量会销毁。</li>
</ul>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p><strong>闭包( closure )</strong>指有权访问另一个函数作用域中变量的<strong>函数</strong>。—– JavaScript 高级程序设计</p>
<p>通俗点说，闭包就是一个函数（一个作用域可以访问另一个函数的局部变量）</p>
<p>简单理解就是,一个作用域可以访问另外一个函数内部的局部变量。<strong><em>被访问的局部变量所在的函数我们成为闭包函数</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);<span class="comment">//fun()访问到了fn()中的局部变量，满足闭包条件，产生闭包</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(); </span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>让fn外面的作用域可以访问fn内部的局部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">    retuen fun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>我们可以简化一下写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line"><span class="comment">//相当于 var f = function()&#123;</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p><strong>闭包的主要作用：延伸了变量的作用域</strong></p>
<h1 id="闭包案例1"><a href="#闭包案例1" class="headerlink" title="闭包案例1"></a>闭包案例1</h1><p>闭包应用-点击li输出当前li的索引号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>大猪蹄子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>臭豆腐<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>鲱鱼罐头<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1.我们可以利用动态添加属性的方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span> ). querySelectorAll( <span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].index = i</span><br><span class="line">    lis[i] .onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(<span class="keyword">this</span>.index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.利用闭包方式得到 li 索引号<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用 for 循环创建了4个立即执行数</span></span><br><span class="line">    <span class="comment">// 立即执行函数 也称为小闭包  因立即执函数里面的任何一个函数都可使用他 的 i量</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;<span class="comment">//把当前循环到的i传入立即执行函数</span></span><br><span class="line">        <span class="comment">// console.log(i);</span></span><br><span class="line">        lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);<span class="comment">//这里必须写传入的参数，函数才能获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个例子中，点击事件触发的函数的i是从立即执行函数中获取来的，所以这个立即执行函数是一个闭包函数</span></span><br></pre></td></tr></table></figure>
需求更改：闭包应用-3秒钟之后，打印所有li 元素的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectornav.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(lis[i].innerHTML);</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="闭包案例2"><a href="#闭包案例2" class="headerlink" title="闭包案例2"></a>闭包案例2</h1></li>
<li>闭包应用-计算打车价格</li>
<li>打车起步价13（3公里内），之后每多一公里增加5块钱.用户输入公里数就可以计算打车价格</li>
<li>如果有拥堵情况，总价格多收取18块钱拥堵费<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">13</span>; <span class="comment">// 起步价 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>; <span class="comment">// 总价 局部变量</span></span><br><span class="line">        <span class="comment">// 正常的价格</span></span><br><span class="line">        price: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                total = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = start + (n <span class="number">3</span>) * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拥堵之后的价格</span></span><br><span class="line">        yd: <span class="function"><span class="keyword">function</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag ? total + <span class="number">1</span>: total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">5</span>)); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">true</span>)); <span class="comment">// 33</span></span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">1</span>)); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">false</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
price和yd函数用了立即执行函数中的局部变量，所以立即执行函数是一个闭包函数</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</span><br></pre></td></tr></table></figure>
<p>有点乱？不要急  我们来拆解一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f =robject.getNameFunc( );</span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">f(),即</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;()<span class="comment">//这是一个立即执行函数，this指向window 那么this中的name就是window全局作用域下的name</span></span><br><span class="line"><span class="comment">//输出the window</span></span><br></pre></td></tr></table></figure>
<p>这段代码中没有访问到局部变量，没有闭包产生</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span> ;<span class="comment">//此时，this指向object，即that=object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;<span class="comment">//that用了getNameFunc的局部变量，产生了闭包，这里getNameFunc是闭包函数</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log (object.getNameFunc()())<span class="comment">//my object</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的路由</title>
    <url>/MyBlog/2020/07/28/Vue%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h2><ul>
<li>概念:根据不同的用户URL请求，返回不同的内容</li>
<li>本质:URL请求地址与服务器资源之间的对应关系<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2></li>
<li>概念:根据不同的用户事件，显示不同的页面内容</li>
<li>本质:用户事件与事件处理函数之间的对应关系</li>
</ul>
<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>&emsp;&emsp;vue Router(官网: <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a> )是Vue.js官方的路由管理器。</p>
<a id="more"></a>
<h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><ul>
<li>1.引入相关的库文件</li>
<li>2.添加路由链接</li>
<li>3.添加路由填充位</li>
<li>4.定义路由组件</li>
<li>5.配置路由规则并创建路由实例</li>
<li>6.把路由挂载到Vue根实例中</li>
</ul>
<p>我们来看最简单的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 被vm实例所控制的区域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">" /user"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--路由占位符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义路由组件</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;User 组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Register = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;Register 组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    <span class="comment">// routes是路由规则数组</span></span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//每个路由规则都是一个配置对象，其中至少包含path和component两个属性:</span></span><br><span class="line">    <span class="comment">//path表示当前路由规则匹配的hash地址</span></span><br><span class="line">    <span class="comment">// component表示当前路由规则对应要展示的组件</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/user'</span>, <span class="attr">component</span>: User&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>: Register&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//把路由挂载到Vue根实例中</span></span><br><span class="line"><span class="comment">//创建vm实例对象</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//指定控制的区域</span></span><br><span class="line">    el: <span class="string">'#app'</span>，</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">    <span class="comment">//挂载路由实例对象</span></span><br><span class="line">    <span class="comment">// router: router  可简写</span></span><br><span class="line">    router</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>路由重定向指的是∶用户在访问地址A的时候，强制用户跳转到地址c，从而展示特定的组件页面;<br>通过路由规则的<code>redirect</code>属性，指定一个新的路由地址，可以很方便地设置路由的重定向:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//其中，path表示需要被重定向的原地址，redirect表示将要被重定向到的新地址</span></span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/user'</span>&#125;，</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/user'</span>, <span class="attr">component</span>: user&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/ register'</span>, <span class="attr">component</span>: Register&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由功能分析</p>
<ul>
<li>点击父级路由链接显示模板内容</li>
<li>模板内容中又有子级路由链接</li>
<li>点击子级路由链接显示子级模板内容</li>
</ul>
<p>如图<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt=""></p>
<h3 id="父路由组件模板"><a href="#父路由组件模板" class="headerlink" title="父路由组件模板"></a>父路由组件模板</h3><ul>
<li>父级路由链接</li>
<li>父组件路由填充位<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">routir-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控制组件的显示位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="子级路由模板"><a href="#子级路由模板" class="headerlink" title="子级路由模板"></a>子级路由模板</h3></li>
<li>子级路由链接</li>
<li>子级路由填充位<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Register =&#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Register组件&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;hr/&gt;</span></span><br><span class="line"><span class="string">    &lt;router-link to=" /register/tab1" &gt;Tab1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;router-link to=" /register/tab2" &gt;Tab2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;!--子路由填充位置 --&gt;</span></span><br><span class="line"><span class="string">    &lt;router-view /&gt;</span></span><br><span class="line"><span class="string">    &lt;/ div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">corst Tab1 = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;tab1子组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Tab2 = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;tab2子组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套路由配置"><a href="#嵌套路由配置" class="headerlink" title="嵌套路由配置"></a>嵌套路由配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父级路由通过children属性配置子级路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter ([</span><br><span class="line">    routes:[</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">component</span>: User &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/register'</span>,<span class="attr">component</span>: Register,<span class="attr">children</span>:[</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/register/tab1'</span>, <span class="attr">component</span>: Tab1 &#125;，</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/register/tab2'</span>, <span class="attr">component</span>: Tab2 &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">&#125;) <span class="comment">//通过children属性，为/register添加子路由规则</span></span><br></pre></td></tr></table></figure>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2>应用场景:通过动态路由参数的模式进行路由匹配<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//动态路径参数以冒号开头</span></span><br><span class="line">    path:&#123;<span class="string">'/user/:id'</span>, <span class="attr">component</span>: user &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    <span class="comment">//路由组件中通过$route.params获取路由参数</span></span><br><span class="line">    template: <span class="string">'&lt;div&gt;user的id为：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>&emsp;&emsp;刚刚说了利用动态路由匹配可以进行路由的传参，但是$route与对应路由形成高度耦合，不够灵活，所以可以使用<code>props</code>将组件和路由解耦</p>
<h3 id="props的值为布尔类型"><a href="#props的值为布尔类型" class="headerlink" title="props的值为布尔类型"></a>props的值为布尔类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props被设置为true，route.params将会被设置为组件属性</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>,<span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props: [<span class="string">'id'</span>],<span class="comment">//使用props接收路由参数,就不需要通过$route.params</span></span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户ID:&#123;&#123; id &#125;&#125;&lt;/div&gt;'</span><span class="comment">//使用路由参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-props的值为对象类型"><a href="#2-props的值为对象类型" class="headerlink" title="2.props的值为对象类型"></a>2.props的值为对象类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter ( &#123;</span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//如果props是一个对象，它会被按原样设置为组件属性</span></span><br><span class="line">    ( path: <span class="string">'/user/:id'</span>,<span class="attr">component</span>: User,<span class="attr">props</span>: &#123; <span class="attr">uname</span>: <span class="string">'lisi'</span>，age: <span class="number">12</span> &#125;&#125;<span class="comment">//此时，无法访问id的值</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[<span class="string">'uname '</span>, <span class="string">'age'</span> ],</span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户信息:&#123; uname + '</span>---<span class="string">' + age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="props的值为函数类型"><a href="#props的值为函数类型" class="headerlink" title="props的值为函数类型"></a>props的值为函数类型</h3><p>我们现在又想获取id的值，又想获取name和age，怎么办呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">constrouter =<span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props 是一个函数，则这个函数接收route对象为自己的形参</span></span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/user/ :id'</span>,</span><br><span class="line">        component: User,</span><br><span class="line">        <span class="comment">//route为动态参数对象。在路由url后面有几个参数项，route里就有几个参数值</span></span><br><span class="line">        props: <span class="function"><span class="params">route</span> =&gt;</span>([ uname: <span class="string">'zs'</span>，age: <span class="number">20</span>,<span class="attr">id</span>: route.params.id &#125;)&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[ <span class="string">'uname '</span>, <span class="string">'age'</span>, <span class="string">'id'</span>]，</span><br><span class="line">    template: <span class="string">'div&gt;用户信息:[&#123; uname + '</span>---<span class="string">' + age + '</span>---<span class="string">' + id]]&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link to="/user"&gt;User&lt;/router-link&gt; 传统路由 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">routir-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'user',params:&#123;id:3&#125;&#125;"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name:路由名称  params:路由需要携带的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控制组件的显示位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">constrouter =<span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props 是一个函数，则这个函数接收route对象为自己的形参</span></span><br><span class="line">        &#123;   </span><br><span class="line">            name:<span class="string">'user'</span><span class="comment">//**给路由起一个名字**</span></span><br><span class="line">            path:<span class="string">'/user/ :id'</span>,</span><br><span class="line">            component: User,</span><br><span class="line">            <span class="comment">//route为动态参数对象。在路由url后面有几个参数项，route里就有几个参数值</span></span><br><span class="line">            props: <span class="function"><span class="params">route</span> =&gt;</span>([ uname: <span class="string">'zs'</span>，age: <span class="number">20</span>,<span class="attr">id</span>: route.params.id &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[ <span class="string">'uname '</span>, <span class="string">'age'</span>, <span class="string">'id'</span>]，</span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户信息:&#123;&#123; uname + '</span>---<span class="string">' + age + '</span>---<span class="string">' + id&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由的编程式导航"><a href="#路由的编程式导航" class="headerlink" title="路由的编程式导航"></a>路由的编程式导航</h1><h2 id="页面导航的两种方式："><a href="#页面导航的两种方式：" class="headerlink" title="页面导航的两种方式："></a>页面导航的两种方式：</h2><ul>
<li><p>声明式导航:通过点击链接实现导航的方式，叫做声明式导航<br>例如:普通网页中的<a></a>链接或vue中的<router-link></router-link></p>
</li>
<li><p>编程式导航:通过调用JavaScript形式的API实现导航的方式，叫做编程式导航<br>例如:普通网页中的location.href<br>心</p>
</li>
</ul>
<h2 id="编程式导航基本用法"><a href="#编程式导航基本用法" class="headerlink" title="编程式导航基本用法"></a>编程式导航基本用法</h2><p>常用的编程式导航API如下:</p>
<ul>
<li>this.$router.push(‘hash地址’)</li>
<li>this.$router.go(n)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//push的用法</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click="goRegister"&gt;跳转到注册页面&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    goRegister: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用编程的方式控制路由跳转</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/register'</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go的用法</span></span><br><span class="line"><span class="keyword">const</span> Register = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Register组件&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click="goBack"&gt;后退&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        goBack()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编程式导航的参数规则"><a href="#编程式导航的参数规则" class="headerlink" title="编程式导航的参数规则"></a>编程式导航的参数规则</h2><code>router.push()</code>方法的参数规则<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串(路径名称)</span></span><br><span class="line">router.push( <span class="string">'/home'</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">router.push( &#123; <span class="attr">path</span>: <span class="string">'/home'</span> &#125;)</span><br><span class="line"><span class="comment">//命名的路由(传递参数)</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"><span class="comment">//带查询参数，变成/register?uname=lisi</span></span><br><span class="line">router.push( &#123; <span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">query</span>: &#123; <span class="attr">uname</span>: <span class="string">'lisi'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由传参param与query两种方式的区别</title>
    <url>/MyBlog/2020/07/28/Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82param%E4%B8%8Equery%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h1><p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>,<span class="attr">component</span>:Login&#125;,</span><br></pre></td></tr></table></figure>
<p>1.页面携带query参数跳转(path,name指定跳转到Login时都可以携带query参数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: <span class="keyword">this</span>.id &#125; )</span><br></pre></td></tr></table></figure>
<p>query相当与发送了一次get请求，请求参数会显示在浏览器地址栏中</p>
<p>2.页面携带params参数跳转(携带params参数跳转时只能使用name指定)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>:<span class="string">'Login'</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="keyword">this</span>.id &#125; )</span><br></pre></td></tr></table></figure>
<p>params相当与发送了一次post请求，请求参数则不会显示，并且刷新页面之后参数会消失</p>
<a id="more"></a>
<p>当路由配置更改为</p>
<p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login/:id'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>,<span class="attr">component</span>:Login&#125;</span><br></pre></td></tr></table></figure>

<p>并且再次发送请求，请求数据不会随着页面的刷新而消失</p>
<p>获取请求参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.params.id</span><br><span class="line"><span class="keyword">this</span>.$route.query.id</span><br></pre></td></tr></table></figure>
<p>注: </p>
<p>&emsp;&emsp;<code>router</code>是<code>VueRoute</code>r的一个对象，通过<code>Vue.use(VueRouter)</code>和<code>VueRouter</code>构造函数得到一个<code>router</code>的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。</p>
<p>&emsp;&emsp;<code>$router.push({path:&#39;login&#39;})</code>;本质是向<code>history</code>栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个<code>history</code>记录;</p>
<p>&emsp;&emsp;而<code>route</code>是一个跳转的路由对象，每一个路由都会有一个<code>route</code>对象，是一个局部的对象，可以获取对应的<code>name,path,params,query</code>等</p>
<h1 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h1><h2 id="用法上的"><a href="#用法上的" class="headerlink" title="用法上的"></a>用法上的</h2><p>&emsp;&emsp;<code>query</code>要用<code>path</code>来引入，<code>params</code>要用<code>name</code>来引入，接收参数都是类似的，分别是<code>this.$route.query.name</code>和<code>this.$route.params.name</code>。</p>
<p>注意接收参数的时候，已经是<code>$route</code>而不是<code>$router</code>了哦！！</p>
<h2 id="展示上的"><a href="#展示上的" class="headerlink" title="展示上的"></a>展示上的</h2><p>&emsp;&emsp;query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p>query:<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/query%E8%B7%AF%E7%94%B1.png" alt=""><br>params:<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/params%E8%B7%AF%E7%94%B1.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化规范</title>
    <url>/MyBlog/2020/07/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h1><p>&emsp;&emsp;CommonJS的核心思想是通过require方法来同步加载依赖的其他模块，通过module.exports导出需要暴露的接口。根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<h2 id="module-exports和require"><a href="#module-exports和require" class="headerlink" title="module.exports和require"></a>module.exports和require</h2><p>采用 CommonJS 导入及导出的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入 </span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span> (<span class="string">'./moduleA'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; test，demo，flag &#125; = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> _mA = <span class="built_in">require</span>(<span class="string">' moduleA '</span>);</span><br><span class="line"><span class="keyword">let</span> test = _mA.test;</span><br><span class="line"><span class="keyword">let</span> demo = _mA.demo;</span><br><span class="line"><span class="keyword">let</span> flag = _mA.f1ag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出  </span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    flag: <span class="literal">true</span>,</span><br><span class="line">    test(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;，</span><br><span class="line">    demo(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="exoprts"><a href="#exoprts" class="headerlink" title="exoprts"></a>exoprts</h2><p>&emsp;&emsp;为了方便，Node为每个模块提供一个<strong>exports变量</strong>，<strong>指向module.exports</strong>。这等同在每个模块头部，有一行这样的命令。</p>
<blockquote>
<p>let exports = module.exports;</p>
</blockquote>
<p><strong>这里要注意！！！</strong><br>&emsp;&emsp;不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exports = <span class="built_in">module</span>.exports</span><br><span class="line"><span class="keyword">let</span> appid = <span class="string">'123456'</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">exports = &#123;</span><br><span class="line">	appid</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">exports.appid = appid</span><br></pre></td></tr></table></figure>

<h1 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h1><p>&emsp;&emsp;ES6模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以一个个导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">'leo'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,mum2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以一起导出，两种写法都一样</span></span><br><span class="line"><span class="keyword">let</span> name= <span class="string">'leo'</span>;</span><br><span class="line"><span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,mum2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里为增强写法，原写法为name:name,age:age</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    name, </span><br><span class="line">    age,</span><br><span class="line">    sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入多个导出  名字必须为export的名字</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age ,sum&#125; <span class="keyword">from</span> <span class="string">'./模块名'</span> </span><br><span class="line"><span class="comment">//导入模块的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化多个导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mydata <span class="keyword">from</span> <span class="string">'./模块名'</span></span><br><span class="line"><span class="built_in">console</span>.log(mydata.name)</span><br><span class="line"><span class="built_in">console</span>.log(mydata.age)</span><br><span class="line"><span class="built_in">console</span>.log(mydata.sum(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="default-export"><a href="#default-export" class="headerlink" title="default export"></a>default export</h2><p>&emsp;&emsp;某些情况下，一个模块中包含某个的功能，在别的地方导入时必须以导出的名字命名，我们并不希望给这个功能命名，而且让导入者可以自己来按自己的想法命名。这个时候就可以使用export default</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="keyword">const</span> address =<span class="string">'福州市'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> address</span><br><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">'./模块名'</span><span class="comment">//可以不使用address</span></span><br><span class="line"><span class="built_in">console</span>.log(addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导入函数</span></span><br><span class="line"><span class="keyword">import</span> myfun <span class="keyword">from</span> <span class="string">'./模块名'</span></span><br><span class="line">myfun(<span class="string">'你好啊'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意！！！</strong></p>
<p>export default在同一个模块中，<strong>不允许同时存在多个</strong>。因为这样，导入的时候就不知道你命名的到底是哪个导出的东西。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack（一） 基本使用和loader</title>
    <url>/MyBlog/2020/07/30/Webpack%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h1><p>来看看官方的解释：</p>
<p>&emsp;&emsp;At its core, webpack is a static module bundler for modern JavaScript applications.</p>
<p>&emsp;&emsp;从本质上来讲，webpack是一个现代的JavgScript应用的静态<strong>模块打包</strong>工具。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/webpack.png" alt=""></p>
<p>&emsp;&emsp;他把所有资源打包压缩成浏览器认识的语法，从而更好的放在服务器上部署，按我的理解就是：大概webpack类似于一个翻译软件，但是它内部是用google翻译（即node）进行翻译的。<br>翻译是为了让我们写的代码能被计算机所识别。</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>！Webpack为了可以正常运行，必须依赖node环境</strong></p>
<h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><blockquote>
<p>npm install webpack -g</p>
</blockquote>
<p>指定版本：</p>
<blockquote>
<p>npm install <a href="mailto:webpack@4.42.0">webpack@4.42.0</a> -g</p>
</blockquote>
<h2 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h2><p>–save-dev是开发时依赖，项目打包后不需要继续使用的。</p>
<blockquote>
<p>npm install webpack –save-dev</p>
</blockquote>
<h1 id="Webpack的基本使用规则"><a href="#Webpack的基本使用规则" class="headerlink" title="Webpack的基本使用规则"></a>Webpack的基本使用规则</h1><p>&emsp;&emsp;在浏览器中，浏览器并不认识commonjs的模块化规范，只认识ES6模块化规范，这个时候，我们就可以用webpack打包模块，让浏览器可以识别。另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mathutil.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 *num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,</span><br><span class="line">    mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;add,mul&#125; =reguire(<span class="string">'./mathutils.js'</span>)l</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>，<span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>，<span class="number">30</span>));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在HTML文件中引入main.js部署到服务器上时，浏览器无法解析commonjs的module.exports，这个时候我们需要通过webpack打包</p>
<blockquote>
<p>webpack ./src/main.js -o ./dist/bundle.js –mode development</p>
</blockquote>
<p>&emsp;&emsp;这时，我们在index.html中引入./dist/bundle.js  就可以访问到这两个方法并使用了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Webpack的配置"><a href="#Webpack的配置" class="headerlink" title="Webpack的配置"></a>Webpack的配置</h1><p>&emsp;&emsp;为了更方便的使用webpack，我们可以定义一个<code>webpack.config.js</code>文件来管理我们需要的命令</p>
<p>&emsp;&emsp;在任何项目中，当需要运用到node环境时，我们都需要执行下面的命令来初始化node的配置</p>
<blockquote>
<p>npm init  || npm init -y<br>就会生成 <code>package.json</code>这个文件，这个文件主要描述了当前项目里的一些信息</p>
</blockquote>
<p>然后，我们就可以在<code>webpack.config.js</code>中配置打包文件的入口和出口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入path模块，使用__dirname来拼接绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = reguire(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="comment">//入口文件  即需要打包的文件</span></span><br><span class="line">    entry:<span class="string">'./src/main.js'</span>,</span><br><span class="line">    <span class="comment">//出口文件 即打包好的文件路径和文件名</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="package-json中自定义启动"><a href="#package-json中自定义启动" class="headerlink" title="package.json中自定义启动"></a>package.json中自定义启动</h1><p>来看一个package.json 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"meetwebpack"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:<span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"main"</span>:<span class="string">"index.js"</span>,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>:<span class="string">"webpack"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">"author"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"license"</span>:<span class="string">"ISC"</span>,</span><br><span class="line">    <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>:<span class="string">"^3.6.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每次执行都敲这么一长串webpack命令很不方便。OK，我们可以在package.json的scripts中定义自己的执行脚本。</p>
<p>&emsp;&emsp;package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<ul>
<li><p>首先，会寻找本地的node_modules/.bin路径中对应的命令。</p>
</li>
<li><p>如果没有找到，会去全局的环境变量中寻找。</p>
</li>
<li><p>如何执行我们的build指令呢?</p>
<blockquote>
<p>npm run build</p>
</blockquote>
</li>
</ul>
<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>&emsp;&emsp;<code>loader</code>是webpack中一个非常核心的概念。</p>
<p>&emsp;&emsp;在我们上面的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</p>
<p>&emsp;&emsp;但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</p>
<p>&emsp;&emsp;对于webpack本身的能力来说，对于这些转化是不支持的。那怎么办呢?给webpack扩展对应的loader就可以啦。</p>
<p>loader使用过程∶</p>
<ul>
<li>步骤一︰通过npm安装需要使用的loader</li>
<li>步骤二︰在webpack.config.js中的modules关键字下进行配置</li>
</ul>
<p>大部分loader我们都可以在<strong>webpack的官网</strong>中找到，并且学习对应的用法。</p>
<h2 id="webpack中使用css文件的配置"><a href="#webpack中使用css文件的配置" class="headerlink" title="webpack中使用css文件的配置"></a>webpack中使用css文件的配置</h2><p>&emsp;&emsp;我们想把所有的js/css文件都打包在bundle.js中，我们就需要在入口文件中添加相关的依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中添加</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./css/index.css'</span>)</span><br></pre></td></tr></table></figure>
<p>安装css-loader: 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</p>
<blockquote>
<p>npm install –save-dev css-loader</p>
</blockquote>
<p>安装style-loader: 将模块的导出作为样式添加到 DOM 中</p>
<blockquote>
<p>npm install –save-dev style-loader</p>
</blockquote>
<p>在<code>webpack.config.json</code> 的<code>module.exports</code>中添加如下配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入path模块，使用__dirname来拼接绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = reguire(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    entry:<span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">//css-loader只负责将css文件进行加裁</span></span><br><span class="line">            &#123;   <span class="comment">//匹配所有的css文件</span></span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">//css-loader只负责将css文件进行加载  style-loader将样式添加到 DOM 中</span></span><br><span class="line">                <span class="comment">//使用多个loader时，是从右向左，所以先加载css文件，css-loader写在右边</span></span><br><span class="line">                use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果在<code>package.json</code>中定义了<code>build</code>，那么现在就可以运行 <code>npm run build</code>进行打包了</p>
<h2 id="webpack中使用less文件的配置"><a href="#webpack中使用less文件的配置" class="headerlink" title="webpack中使用less文件的配置"></a>webpack中使用less文件的配置</h2><p>&emsp;&emsp;如果我们希望在项目中使Hess、scss.stylus来写样式，webpack是否可以帮助我们处理呢?</p>
<p>&emsp;&emsp;我们这里以less为例，其他也是一样的。</p>
<p>我们还是先创建一个less文件index.less，依然放在css文件夹中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* index.less */</span></span><br><span class="line">@fontsize:50px;</span><br><span class="line">@fontColor:orange;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:@fontsize;</span><br><span class="line">    <span class="attribute">color</span>: @fontcolor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在入口文件main.js中添加依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中添加</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./css/index.less'</span>)</span><br></pre></td></tr></table></figure>
<p>安装less-roader</p>
<blockquote>
<p>npm install less-loader –save-dev</p>
</blockquote>
<p>在<code>webpack.config.js</code>的<code>module</code>的<code>rules</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">         use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h2><p>我们在index.css中引入一张图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"../img/test.jpg"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们采用url引入的图片，所以我们用url-roader</p>
<p>安装</p>
<blockquote>
<p>npm install url-loader –save-dev</p>
</blockquote>
<p>在<code>webpack.config.js</code>的<code>module</code>的<code>rules</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">//可以一个loader写成一个对象形式，这样方便我们添加参数如options</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">///当加载的图片，小于limit时，会将图片编译成base64字符串形式.limit可自行修改</span></span><br><span class="line">        <span class="comment">//当加载的图片，大于limit时，需要使用file-loader模块进行加载.npm安装就行，不需要配置</span></span><br><span class="line">        limit: <span class="number">8192</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现webpack在dist文件夹下自动帮助我们生成一个非常长的名字,这是一个32位hash值，目的是防止名字重复<br>&emsp;&emsp;但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>&emsp;&emsp;比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</p>
<p>所以，我们可以在options中添加上如下选项:</p>
<ul>
<li>img :文件要打包到的文件夹</li>
<li>name:获取图片原来的名字，放在该位置</li>
<li>hash:8:为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext:使用图片原来的扩展名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  limit: <span class="number">8192</span>,</span><br><span class="line">  name:<span class="string">'images/[name].[hash:8].[ext]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行<code>npm run build</code>。现在，我们就在dist下有一个images文件夹存放着我们刚刚打包的图片了</li>
</ul>
<h2 id="ES6语法处理-最新版浏览器可以忽略"><a href="#ES6语法处理-最新版浏览器可以忽略" class="headerlink" title="ES6语法处理(最新版浏览器可以忽略)"></a>ES6语法处理(最新版浏览器可以忽略)</h2><p>&emsp;&emsp;如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。<br>&emsp;&emsp;在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用bapel.<br>&emsp;&emsp;而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<blockquote>
<p>npm install -D babel-loader @babel/core @babel/preset-es2015 webpack</p>
</blockquote>
<p>配置webpack.config.js文件下的rules</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">    <span class="comment">//exclude:排除</span></span><br><span class="line">    exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">       loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中父子组件传值和访问</title>
    <url>/MyBlog/2020/07/26/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>在开发中，往往一些数据确实需要从上层传递到下层∶</p>
<p>&emsp;&emsp;比如在一个页面中，我们从服务器请求到了很多的数据。</p>
<p>&emsp;&emsp;其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</p>
<p>&emsp;&emsp;这个时候，并不会让子组件再次发送一个网络请求，而是直接让<strong>大组件(父组件)</strong>将数据传递给<strong>小组件(子组件)</strong>。</p>
<p>如何进行父子组件间的通信呢?Vue官方提到</p>
<ul>
<li>通过<code>props</code>向子组件传递数据</li>
<li>通过事件向父组件发送消息</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt=""></p>
<a id="more"></a>
<h1 id="父传子-props"><a href="#父传子-props" class="headerlink" title="父传子 props"></a>父传子 props</h1><p>&emsp;&emsp;在组件中，使用选项props来声明需要从父级接收到的数据。props的值有两种方式:</p>
<ul>
<li>方式一:字符串数组，数组中的字符串就是传递时的名称。</li>
<li>方式二∶对象，对象可以设置传递时的类型，也可以设置默认值等。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传递动态props --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cmovies</span>=<span class="string">"movies"</span> <span class="attr">:message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传递静态props --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">cmovies</span>=<span class="string">"鳄鱼洗澡"</span> <span class="attr">message</span>=<span class="string">"hshshsh"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入数字、布尔值、数组、对象时，都需要用v-bind --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span> = <span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;cmovies&#125;&#125;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in cmovies"</span>&gt;</span>&#123;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">    template:<span class="string">'#cpn'</span>,</span><br><span class="line">    <span class="comment">//数组写法</span></span><br><span class="line">    props: [ <span class="string">'cmovies'</span>,<span class="string">'message'</span>],</span><br><span class="line">    <span class="comment">//对象写法（推荐）</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        cmovies:<span class="built_in">Array</span>,</span><br><span class="line">        <span class="comment">//还可以设置默认值，如果没传参，则显示默认值</span></span><br><span class="line">        messgae:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="string">'哈哈哈'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="comment">//return</span></span><br><span class="line">    &#125;，</span><br><span class="line">    methods:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化vue实例 父组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message:<span class="string">'你好啊'</span>，</span><br><span class="line">        movies:[<span class="string">'海王'</span>，<span class="string">'海贼王'</span>，<span class="string">'海尔兄弟'</span>]</span><br><span class="line">    &#125;，</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn<span class="comment">//cpn:cpn的简写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时，父组件中的movies和message已经传递到子组件中并可以展示了</p>
<h1 id="子传父-emit"><a href="#子传父-emit" class="headerlink" title="子传父 $emit"></a>子传父 $emit</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 监听子组件发射事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">itemClick</span>=<span class="string">"cpnClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span> = <span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击触发切换子组件事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">"item in categories"</span> @<span class="attr">click</span>=<span class="string">"btnClick(item)"</span>&gt;</span>&#123;&#123;item.name&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">    template:<span class="string">'#cpn'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            categories:[</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'aaa'</span>,name=<span class="string">'热门推荐'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'bbb'</span>,name=<span class="string">'手机数码'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'ccc'</span>,name=<span class="string">'家用家电'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'ddd'</span>,name=<span class="string">'电脑办公'</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btnClick(item)&#123;</span><br><span class="line">            <span class="comment">//给父组件传值，告诉父组件这个按钮被点击了</span></span><br><span class="line">            <span class="comment">//发射事件</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'itemClick'</span>)</span><br><span class="line">            <span class="comment">//同时，也可以携带参数</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'itemClick'</span>,item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化vue实例 父组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    &#125;，</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn<span class="comment">//cpn:cpn的简写</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="comment">//若无参数,item不写</span></span><br><span class="line">        cpnClick(item)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"接收到子组件的点击事件"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>原文链接：<a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">vue官方文档：单向数据流</a></p>
<p>&emsp;&emsp;所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>&emsp;&emsp;额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>&emsp;&emsp;这里有两种常见的试图变更一个 prop 的情形：</p>
<ul>
<li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用</strong>。在这种情况下，最好<strong>定义一个本地的 data property</strong>并将这个 prop 用作其初始值：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>这个 prop 以一种原始的值传入且需要进行转换</strong>。在这种情况下，最好<strong>使用这个 prop 的值来定义一个计算属性</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="vue中父子组件访问"><a href="#vue中父子组件访问" class="headerlink" title="vue中父子组件访问"></a>vue中父子组件访问</h1><h2 id="父子组件访问子组件方式：-children"><a href="#父子组件访问子组件方式：-children" class="headerlink" title="父子组件访问子组件方式：$children"></a>父子组件访问子组件方式：$children</h2>&emsp;&emsp;有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件。</li>
<li>父组件访问子组件:使用$children或$refs  (reference 引用)</li>
<li>子组件访问父组件∶使用$parent</li>
</ul>
<p>&emsp;&emsp;我们先来看下$children的访问</p>
<ul>
<li>this.$children是一个数组类型，它包含所有子组件对象。</li>
<li>我们这里通过一个遍历，取出所有子组件的message状态。</li>
</ul>
<p>现在，我们想在父组件中调用子组件的方法，就可以用$children</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们先定义一个子组件</span></span><br><span class="line">components:&#123;</span><br><span class="line">    cpn:&#123;</span><br><span class="line">        template:<span class="string">'#cpn'</span>,</span><br><span class="line">        data()&#123;    </span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                name:<span class="string">'我是子组件的name'</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showMessage()&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'showMessage'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件如下：</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message:<span class="string">'你好啊'</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btnclick()&#123;</span><br><span class="line">            <span class="comment">//重要的在这里！！！ 我们访问$children,就是访问组件对象</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children);</span><br><span class="line">            <span class="comment">//访问第一个组件对象的showmessage方法，输出'showmessage'</span></span><br><span class="line">            <span class="keyword">this</span>.$children[<span class="number">0</span>].showMessage()</span><br><span class="line">            <span class="comment">//访问第一个子组件的name属性</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[<span class="number">0</span>].name)</span><br><span class="line">            <span class="comment">//循环访问子组件的name</span></span><br><span class="line">            (<span class="keyword">let</span> c <span class="keyword">of</span> <span class="keyword">this</span>.$children)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(c.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">在html中定义模板</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnclick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="父子组件访问子组件方式-ref"><a href="#父子组件访问子组件方式-ref" class="headerlink" title="父子组件访问子组件方式 $ref"></a>父子组件访问子组件方式 $ref</h2><p>&emsp;<strong>但是，在普通的开发中，我们一般使用$ref而不是用$children,</strong>因为会有可能我们在开发中插入了一个子组件，这样this.$chilren[n]就有可能会出错,我们就可以用到$ref指定访问的组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对上一小节中的html模板改造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnclick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在btnclick这个方法中访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methids:&#123;</span><br><span class="line">    btnClick()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs);</span><br><span class="line">            <span class="comment">//访问第一个组件对象的showmessage方法，输出'showmessage'</span></span><br><span class="line">            <span class="keyword">this</span>.$refs.aaa.showMessage()</span><br><span class="line">            <span class="comment">//访问第一个子组件的name属性</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$ref.aaa.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子组件访问父组件方式-parent"><a href="#子组件访问父组件方式-parent" class="headerlink" title="子组件访问父组件方式$parent"></a>子组件访问父组件方式$parent</h2><p>我们写一个父子组件的嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">    cpn:&#123;</span><br><span class="line">        template: <span class="string">'#cpn'</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                name:<span class="string">'我是cpn组件的name'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        components: &#123;</span><br><span class="line">            ccpn:&#123;</span><br><span class="line">                template: <span class="string">'#ccpn'</span>,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    btnclick()&#123;</span><br><span class="line">                    <span class="comment">// 1.访问父组件$parent</span></span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent);</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.name);<span class="comment">//输出'我是cpm组件的name'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在开发中并<strong>不建议使用</strong>，因为组件本来就是为了复用，如果这样写就必须要求父组件中有对应的方法，<strong>降低了复用性</strong>。</p>
<h2 id="访问根组件-root"><a href="#访问根组件-root" class="headerlink" title="访问根组件 $root"></a>访问根组件 $root</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack（二）plugin</title>
    <url>/MyBlog/2020/07/30/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><h2 id="plugin是什么"><a href="#plugin是什么" class="headerlink" title="plugin是什么?"></a>plugin是什么?</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</p>
<h2 id="loader和plugin区别"><a href="#loader和plugin区别" class="headerlink" title="loader和plugin区别"></a>loader和plugin区别</h2><ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li>
</ul>
<h2 id="plugin的使用过程∶"><a href="#plugin的使用过程∶" class="headerlink" title="plugin的使用过程∶"></a>plugin的使用过程∶</h2><ul>
<li>步骤一∶通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li>
<li>步骤二︰在webpack.config.js中的plugins中配置插件。webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。   </li>
</ul>
<p>&emsp;&emsp;我们下面就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让webpack变得更加好用。</p>
<a id="more"></a>
<h1 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h1><p>&emsp;&emsp;我们先来使用一个最简单的插件，为打包的文件添加版权声明。该插件名字叫<code>BannerPlugin</code>，属于webpack自带的插件。<br>&emsp;&emsp;按照下面的方式来修改webpack.config.js的文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack =<span class="built_in">require</span>( <span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'最终版权归yang所有'</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打包程序:查看bundle.js文件的头部，看到如下信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!最终版权归yang所有*/</span></span><br><span class="line"><span class="comment">//bundle.js主体内容</span></span><br></pre></td></tr></table></figure>
<h1 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h1><p>&emsp;&emsp;目前，我们的index.html文件是存放在项目的根目录下的。<br>&emsp;&emsp;我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件<br>&emsp;&emsp;<code>HtmlWebpackPlugin</code>插件可以为我们做这些事情:</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件</p>
<blockquote>
<p>npm install html-webpack-plugin –save-dev</p>
</blockquote>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'最终版权归yang所有'</span>)，</span><br><span class="line">    <span class="keyword">new</span> htmlwebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)，</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里的template表示根据什么模板来生成index.html</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue脚手架</title>
    <url>/MyBlog/2020/07/30/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="VueCLI"><a href="#VueCLI" class="headerlink" title="VueCLI"></a>VueCLI</h1><p>CLI是什么意思?</p>
<p>&emsp;&emsp;CLI是Command-Line Interface,翻译为命令行界面,但是俗称脚手架.Vue CLI是一个官方发布vue.js项目脚手架<br>&emsp;&emsp;使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置.</p>
<p><strong>！VueCLI使用前必须安装node环境和webpack</strong></p>
<h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>可以直接在官方网站中下载安装。网址: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><blockquote>
<p>npm install webpack -g</p>
</blockquote>
<h2 id="VueCLI的安装"><a href="#VueCLI的安装" class="headerlink" title="VueCLI的安装"></a>VueCLI的安装</h2><p>安装vue脚手架：(全局安装)</p>
<blockquote>
<p>npm install -g @vue/cli</p>
</blockquote>
<a id="more"></a>
<h1 id="VueCLI的使用"><a href="#VueCLI的使用" class="headerlink" title="VueCLI的使用"></a>VueCLI的使用</h1><p>初始化项目可以用两个命令：</p>
<blockquote>
<p>vue create 项目名称<br>vue ui 进入图形化界面</p>
</blockquote>
<h2 id="create创建过程"><a href="#create创建过程" class="headerlink" title="create创建过程"></a>create创建过程</h2><p> <img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%84%9A%E6%89%8B%E6%9E%B6create.png" alt=""></p>
<h2 id="创建项目的文件目录"><a href="#创建项目的文件目录" class="headerlink" title="创建项目的文件目录"></a>创建项目的文件目录</h2><p> <img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt=""></p>
<h1 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h1><p>&emsp;&emsp;由于vue-cli3将webpack的基础配置全部内嵌了，这就导致我们初始化项目完成之后发现原先的webpack的config配置全部都消失不见了，那该怎么办呢？别慌，vue-cli早就考虑到了这一点，它预留了一个vue.config.js的js文件供我们对webpack进行自定义配置。</p>
<h2 id="在项目根目录下新建vue-config-js文件与package-json同级"><a href="#在项目根目录下新建vue-config-js文件与package-json同级" class="headerlink" title="在项目根目录下新建vue.config.js文件与package.json同级"></a>在项目根目录下新建vue.config.js文件与package.json同级</h2><p>&emsp;&emsp;这里的vue.config.js会和脚手架创建的webpack合并，成为最终配置</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/MyBlog/2020/08/11/axios/</url>
    <content><![CDATA[<p>axios(官网: <a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a> )是一个基于Promise用于浏览器和node.js的HTTP客户端。<br>它具有以下特征:</p>
<ul>
<li>支持浏览器和node.js心</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>npm install axios -S</p>
</blockquote>
<h1 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/data'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// data属性名称是固定的，用于获取后台响应的数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="axios常用API"><a href="#axios常用API" class="headerlink" title="axios常用API"></a>axios常用API</h1><ul>
<li>get :查询数据</li>
<li>post:添加数据</li>
<li>put :修改数据</li>
<li>delete:删除数据</li>
</ul>
<h1 id="axios的参数传递"><a href="#axios的参数传递" class="headerlink" title="axios的参数传递"></a>axios的参数传递</h1><h2 id="get参数传递"><a href="#get参数传递" class="headerlink" title="get参数传递"></a>get参数传递</h2><ul>
<li>通过URL传递参数</li>
<li>通过params选项传递参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过url传参(第一种)</span></span><br><span class="line">axios.get( <span class="string">'/adata?id=123'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log (res.data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.get(<span class="string">'/adata'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">"axios get 传递参数"</span>+ req.query.id)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过url传参(第二种)</span></span><br><span class="line">axios.get( <span class="string">'/adata/123'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log (res.data) </span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.get(<span class="string">'/adata/:id'</span>, (req，res) =&gt;&#123;</span><br><span class="line">res.send(<span class="string">'axios get (Restful）传递参数'</span>+req.params.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过params属性传参（params用于传递get参数）</span></span><br><span class="line">axios.get(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    params : &#123;</span><br><span class="line">        id: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="delete参数传递"><a href="#delete参数传递" class="headerlink" title="delete参数传递"></a>delete参数传递</h2>传递方式与get类似 也是通过url和param，我这里实现一下params<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过params属性传参</span></span><br><span class="line">axios.delete(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    params : &#123;</span><br><span class="line">        id: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.delete(<span class="string">'/axios'</span>,(req，res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios get传递参数'</span>+req.query.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="post参数传递"><a href="#post参数传递" class="headerlink" title="post参数传递"></a>post参数传递</h2></li>
<li>通过选项传递参数（默认传递的是json格式的数据）</li>
<li>通过URLSearchParams传递参数(application/x-www-form-urlencoded)(了解就好)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    uname: <span class="string">'tom'</span>,</span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.post(<span class="string">"/axios"</span>, (req,res) =&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios post传递参数'</span>+req.body.uname + <span class="string">'---'</span>+req.body.pwd)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="put参数传递"><a href="#put参数传递" class="headerlink" title="put参数传递"></a>put参数传递</h2>与post类似 但是一般会在url后面跟上具体要修改的内容的id<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/adata/123'</span>,&#123;<span class="comment">//123为要修改的信息的id</span></span><br><span class="line">    uname: <span class="string">'tom'</span>,<span class="comment">//要修改的对应id的信息</span></span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.post(<span class="string">"/axios/:id"</span>, (req,res) =&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios put传递参数'</span>+req.params.id + <span class="string">'---'</span>+req.body.uname + <span class="string">'---'</span>+req.body.pwd)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="axios的全局配置"><a href="#axios的全局配置" class="headerlink" title="axios的全局配置"></a>axios的全局配置</h1></li>
<li>axios.defaults.timeout = 3000//超时时间</li>
<li>axios.defaults.baseURL = ‘<a href="http://localhost:3000/app&#39;;//默认地址" target="_blank" rel="noopener">http://localhost:3000/app&#39;;//默认地址</a></li>
<li>axios.defaults.headers[‘mytoken’]= ‘aqwerwqwerqwer2ewrwe23eresdf23’//设置请求头</li>
</ul>
<h1 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h1><h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>在请求发出之前设置一些信息<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在请求发出之前进行一些信息设置</span></span><br><span class="line">    <span class="built_in">console</span>.log(config.url)<span class="comment">//判断url需不需要加请求头</span></span><br><span class="line">    config.headers.mytoken = <span class="string">'nihao'</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h2><p>在获取数据之前对数据做一些加工处理<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里对返回的数据进行处理 这里把data拆解出来</span></span><br><span class="line">    <span class="keyword">var</span> data = res.data</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="异步终极解决方案-async-await"><a href="#异步终极解决方案-async-await" class="headerlink" title="异步终极解决方案 async/await"></a>异步终极解决方案 async/await</h1><ul>
<li>async/await是ES7引入的新语法，可以更加方便的进行异步操作</li>
<li>async关键字用于函数上(async函数的返回值是Promise实例对象)</li>
<li>await关键字用于async函数当中(await可以得到异步的结果)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then和回调函数，await可以直接返回结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">&#125;</span><br><span class="line">queryData();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你想把结果中的res.data return出去，那么这个return出去的东西是一个peomise对象，可供后面链式调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then，await直接返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">&#125;</span><br><span class="line">queryData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    consolr.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
await后面需要跟上一个异步对象，如果是我们自己写的promise对象想用async和await，如下<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then，await直接返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">&#125;</span><br><span class="line">queryData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    consolr.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的监听器和过滤器</title>
    <url>/MyBlog/2020/08/12/Vue%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器可以监听数据的变化，当某个数据改变时，可以触发某个函数</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%9B%91%E5%90%AC%E5%99%A8.png" alt=""></p>
<p>来看看监听器的简单用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数据  在html中用v-model绑定   </span></span><br><span class="line">data&#123;</span><br><span class="line">    firstName:<span class="string">'xxx'</span></span><br><span class="line">    lastName:<span class="string">'yyy'</span></span><br><span class="line">    fullName:<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">    <span class="comment">//监听firstname变化</span></span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// val表示变化之后的值</span></span><br><span class="line">        <span class="keyword">this</span>.fullName = val + <span class="keyword">this</span>.lastName ;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//监听lastname变化</span></span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">&lt;!-- more --&gt;</span></span><br><span class="line"><span class="string">其实，对于这个例子，我们用计算属性也可以实现</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">computed:&#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName +<span class="string">''</span>+ <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>反而计算属性更简单。对于这些<strong>字符串操作，更适合计算属性做</strong>，<strong>监听器的使用场景主要在异步操作和弹窗提示</strong>等功能中</p>
<p>&emsp;&emsp;现在我们来做一个小案例，需求:输入框中输入姓名，<strong>失去焦点</strong>时验证是否存在，如果已经存在，提示从新输入，如果不存在，提示可以使用。<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%9B%91%E5%90%AC%E5%99%A8%E6%A1%88%E4%BE%8B.png" alt=""><br>我们需要做到以下东西：</p>
<ul>
<li>通过v-model实现数据绑定</li>
<li>需要提供提示信息</li>
<li>需要侦听器监听输入信息的变化</li>
<li>需要修改触发的事件</li>
</ul>
<p>我们先写个表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"uname"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;tip&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后来写监听器，注意以下几点</p>
<ul>
<li>采用侦听器监听用户名的变化</li>
<li>调用后台接口进行验证</li>
<li>根据验证的结果调整提示信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        uname:<span class="string">''</span>,</span><br><span class="line">        tip:<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    checkName: <span class="function"><span class="keyword">function</span>(<span class="params">uname</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//调用接口，但是可以使用定时任务的方式模拟接口调用</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;<span class="comment">//可以用箭头函数</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//模拟接调用</span></span><br><span class="line">            <span class="keyword">if</span>(uname == <span class="string">'admin'</span>)&#123;</span><br><span class="line">                that.tip =<span class="string">'用户名己经存在，请更换一个'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                that.tip =<span class="string">'用户名可以使用'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">        uname: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//调用后台接口验证用户名的合法性</span></span><br><span class="line">            <span class="keyword">this</span>.checkName(val)</span><br><span class="line">            <span class="keyword">this</span>.tip = <span class="string">'正在验证...'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="过滤器的作用是什么"><a href="#过滤器的作用是什么" class="headerlink" title="过滤器的作用是什么?"></a>过滤器的作用是什么?</h2><p>格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue.filter(upper, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;<span class="comment">//把过滤器加到哪里，value就是哪里的数据</span></span><br><span class="line">    <span class="comment">//过滤器业务逻辑  首字母大写</span></span><br><span class="line">    <span class="keyword">return</span> val.charAt().toUpperCase()+ val.slice(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">vue.filter(lower, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//过滤器业务逻辑  首字母小写</span></span><br><span class="line">    <span class="keyword">return</span> val.charAt().toLowerCase()+ val.slice(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg | upper&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg | upper | lower&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"id | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//效果和全局过滤器一样，但是在组件内部才能使用</span></span><br><span class="line">filters: &#123;</span><br><span class="line">    upper: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toUpperCase()+val.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参数的过滤器"><a href="#带参数的过滤器" class="headerlink" title="带参数的过滤器"></a>带参数的过滤器</h2><p>我们想把当前时间(如2020-8-12T09:20:15)的时间改成2020-8-12可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数是要过滤的参数，第二个是过滤器携带的参数</span></span><br><span class="line">Vue.filter(<span class="string">'format'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value,arg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果是这个格式</span></span><br><span class="line">    <span class="keyword">if</span>(arg ==<span class="string">'yyyy-MM-dd'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> ret =<span class="string">''</span>;</span><br><span class="line">        ret+= value.getFullYear()+<span class="string">'-'</span>+(value.getMonth()+ <span class="number">1</span>)+<span class="string">'-'</span>  +value.getDate();</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;、</span><br><span class="line">    <span class="comment">//如果不是这个格式</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤器的使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;date | format('yyyy-MM-Nd')&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>监听器</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
</search>
