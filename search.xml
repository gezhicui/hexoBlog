<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie和Session的使用</title>
    <url>/MyBlog/2020/07/22/Cookie%E5%92%8CSession%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="cookie和session概念"><a href="#cookie和session概念" class="headerlink" title="cookie和session概念"></a>cookie和session概念</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>&emsp;&emsp;cookie是浏览器在电脑硬盘中开辟的一块空间，主要供服务器端存储数据。</p>
<ul>
<li>cookie中的数据是以域名的形式进行区分的。</li>
<li>cookie中的数据是<strong>有过期时间</strong>的，超过时间数据会被浏览器<strong>自动删除</strong>。</li>
<li>cookie中的数据会随着请求被<strong>自动发送</strong>到服务器端。</li>
<li>单个cookie大小不能超过4k，很多浏览器限制一个站点最多20个cookie</li>
</ul>
<h2 id="如何查看cookie"><a href="#如何查看cookie" class="headerlink" title="如何查看cookie"></a>如何查看cookie</h2><p>&emsp;&emsp;我们访问百度，在浏览器的开发者模式下Application中就可以查看百度给我们的cookie<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%99%BE%E5%BA%A6cookie.png" alt=""></p>
<a id="more"></a>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>&emsp;&emsp;session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。在session对象中也可以存储多条数据，每一条数据都有一个<code>sessionid</code>做为唯一标识。</p>
<h2 id="session工作流程"><a href="#session工作流程" class="headerlink" title="session工作流程"></a>session工作流程</h2><p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一<br>个类似于key,value的键值对，然后将key(cookie)返回到浏览器(客户)端，浏览器下次<br>再访问时，携带key(cookie)，找到对应的session(value)。</p>
<h2 id="cookie和session关系"><a href="#cookie和session关系" class="headerlink" title="cookie和session关系"></a>cookie和session关系</h2><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/cookie%E5%92%8Csession%E5%85%B3%E7%B3%BB.png" alt=""></p>
<h1 id="Cookie在Nodejs中使用"><a href="#Cookie在Nodejs中使用" class="headerlink" title="Cookie在Nodejs中使用"></a>Cookie在Nodejs中使用</h1><p>首先我们要安装一个模块</p>
<blockquote>
<p>npm install cookie-parser –save</p>
</blockquote>
<p>然后引入并使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入依赖项</span></span><br><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser=<span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"><span class="comment">//配置中间件</span></span><br><span class="line"><span class="keyword">var</span> app=express()</span><br><span class="line">app.use(cookieParser())</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听路由 </span></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//设置cookie(名称，值，配置),保存到客户端浏览器</span></span><br><span class="line">    res.cookie(<span class="string">'username'</span>,<span class="string">'zhangsan'</span>,&#123;</span><br><span class="line">        <span class="comment">//设置cookie过期时间 单位：毫秒</span></span><br><span class="line">        maxAge:<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.send(<span class="string">'你好'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//从客户端获取cookie  </span></span><br><span class="line">    <span class="keyword">let</span> name = req.cookies.username</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们发现cookie是可以配置参数的，在设置cookie的源码中定义了这几个配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">maxAge?: number;<span class="comment">//过期时间（毫秒数）</span></span><br><span class="line">signed?: boolean;<span class="comment">//是否加密  true为加密</span></span><br><span class="line">    &#123;   <span class="comment">//用法 1、在配置的时候传入一个随意的加密字符串</span></span><br><span class="line">        app.use(cookieParser(<span class="string">'yang'</span>))</span><br><span class="line">        <span class="comment">//2、在设置cookie时，传入一个signed:true配置项</span></span><br><span class="line">        res.cookie(<span class="string">'username'</span>,<span class="string">'zhangsan'</span>&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">        <span class="comment">//3、在获取加密cookie时，用以下方法获取  **只有用以下方法才能获取到cookie**</span></span><br><span class="line">        <span class="keyword">let</span> name = req.signedCookie.username</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">expires?: <span class="built_in">Date</span>;<span class="comment">//过期时间（设置具体日期）</span></span><br><span class="line">httpOnly?: boolean;<span class="comment">//是否只能在后台访问</span></span><br><span class="line">path?: string;<span class="comment">//允许访问cookie的后端路由</span></span><br><span class="line">domain?: string;<span class="comment">//多个域共享cookie</span></span><br><span class="line">    <span class="comment">//用法</span></span><br><span class="line">    &#123;<span class="attr">domain</span>:<span class="string">".yang.com"</span>&#125;<span class="comment">//这样配置后，aaa.yang.com和bbb.yang.com都可以访问到设置的cookie</span></span><br><span class="line">secure?: boolean;<span class="comment">//设置为true，说明cookie在http中无效，在https中才有效</span></span><br><span class="line">encode?: <span class="function">(<span class="params">val: string</span>) =&gt;</span> string;</span><br><span class="line">samesite? : boolean | <span class="string">'lax'</span>| <span class="string">'strict'</span>| <span class="string">"none"</span>;</span><br></pre></td></tr></table></figure>




<h1 id="Session在Nodejs中使用"><a href="#Session在Nodejs中使用" class="headerlink" title="Session在Nodejs中使用"></a>Session在Nodejs中使用</h1><p>&emsp;&emsp;在node.js中需要借助express-session实现session功能。</p>
<blockquote>
<p>npm install express-session</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//配置session的中间件函数</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret :<span class="string">'secret key'</span><span class="comment">//服务器生成session的签名（随意写）</span></span><br><span class="line">    <span class="comment">//以下可忽略,按照默认配置</span></span><br><span class="line">    resave:<span class="literal">false</span><span class="comment">////强制保存session即使它并没有变化</span></span><br><span class="line">    saveUninitialized:<span class="literal">true</span>，<span class="comment">//强制将未初始化的session存储</span></span><br><span class="line">    name:<span class="string">'node'</span><span class="comment">//修改session对应cookie的名称</span></span><br><span class="line">    rolling:<span class="literal">true</span><span class="comment">//在每次请求时强行设置cookie，这将重置cookie过期时间（默认: false)</span></span><br><span class="line">    cookie&#123;</span><br><span class="line">        maxAge:<span class="number">1000</span>*<span class="number">60</span></span><br><span class="line">        secure:<span class="literal">false</span></span><br><span class="line">        <span class="comment">//详见cookie配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>在用户访问后端路由后，设置一个session</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/login'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//设置session</span></span><br><span class="line">    req.session.username = <span class="string">'zhangsan'</span></span><br><span class="line">    res.send(<span class="string">'登录'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取session</span></span><br></pre></td></tr></table></figure>

<p>在用户再进行登录时，判断用户登录状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截请求判断用户登录状态</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>, (req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.url != <span class="string">'/login'</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        <span class="comment">//判断用户访问的是否是登录页面</span></span><br><span class="line">        <span class="comment">//判断用户的登录状态</span></span><br><span class="line">        <span class="comment">//如果用户是登录的将请求放行</span></span><br><span class="line">        <span class="comment">//如果用户不是登录的将请求重定向到登录页面</span></span><br><span class="line">        res.redirect( <span class="string">' /admin/ login'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(req.session.username)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用户是登录状态将请求放行</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在用户退出登录时，我们需要销毁session</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/loginout"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//1、设置session的过期时间为6(它会把所有的session都销毁)</span></span><br><span class="line">    <span class="comment">//req .session.cookie.maxAge=0</span></span><br><span class="line">    <span class="comment">//2、销毁session</span></span><br><span class="line">    <span class="comment">//req.session.destroy()</span></span><br><span class="line">    <span class="comment">//3、销毁指定session  *推荐</span></span><br><span class="line">    req.session.username=<span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    res.send(<span class="string">"退出登录"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（三） 请求处理</title>
    <url>/MyBlog/2020/07/21/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="创建路由的基础方法"><a href="#创建路由的基础方法" class="headerlink" title="创建路由的基础方法"></a>创建路由的基础方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router();</span><br><span class="line"><span class="comment">//将路由和请求路径进行匹配，当客户端请求路径是home时，使用home这个路由对象进行处理，具体请求处理需要在二级路由中去进行</span></span><br><span class="line">app.use(<span class="string">'/home'</span>,home) ;</span><br><span class="line"><span class="comment">//在home路由下继续创建二级路由</span></span><br><span class="line">home.get(<span class="string">'/index'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">// /home/index</span></span><br><span class="line">    res.send (<span class="string">'欢迎来到博客展示页面'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)<span class="comment">//端口监听</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h1><p>模块化路由基本实现：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1.png" alt=""></p>
<h1 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h1><p>&emsp;&emsp;Express框架中使用<code>req.query</code>即可获取GET参数，框架内部会将GET参数转换为对象并返回。我们就不需要使用原生语法中的url模块了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收地址栏中问号后面的参数</span></span><br><span class="line"><span class="comment">//例如: http://localhost:3000/?name=zhangsan&amp;aqe=30</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log (req.query); <span class="comment">//&#123; "name" : "zhangsan" ，, "age" : "30"&#125;</span></span><br><span class="line">    res.send(req.query)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h1><p>&emsp;&emsp;Express中接收post请求参数需要借助第三方包<code>body-parser</code>。npm下载即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>( <span class="string">'body-parser'</span>);</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截所有请求</span></span><br><span class="line"><span class="comment">// extended: false方法内部使用querystring模块处理请求参数的格式</span></span><br><span class="line"><span class="comment">// extended: true方法内部使用第三方模块qs处理请求参数的格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/add'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//body属性是bodyParser在req中添加的属性，值为post请求参数</span></span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//端口监听</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// localhost: 3000/find/123</span></span><br><span class="line">app.get(<span class="string">'/index/:id'</span>,(req, res) =&gt;&#123;</span><br><span class="line">    <span class="comment">//req.parmas接收post请求参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params); <span class="comment">// &#123;id: 123&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h1><p>&emsp;&emsp;通过Express内置的<code>express.static</code>中间件可以方便地托管静态文件，例如img、CSS、JavaScript文件等。</p>
<blockquote>
<p>app.use(express.statuc(‘public’))</p>
</blockquote>
<p>现在，public目录下面的文件就可以访问了。</p>
<ul>
<li><a href="http://localhost:3000/css/style.css" target="_blank" rel="noopener">http://localhost:3000/css/style.css</a></li>
<li><a href="http://localhost:3000/js/app.js" target="_blank" rel="noopener">http://localhost:3000/js/app.js</a></li>
<li><a href="http://localhost:3000/images/bg.png" target="_blank" rel="noopener">http://localhost:3000/images/bg.png</a></li>
<li><a href="http://localhost:3000/hello.html" target="_blank" rel="noopener">http://localhost:3000/hello.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（一） 基本使用</title>
    <url>/MyBlog/2020/07/20/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Express框架是什么"><a href="#Express框架是什么" class="headerlink" title="Express框架是什么"></a>Express框架是什么</h1><p>&emsp;&emsp;Express是一个基于<strong>Node平台</strong>的<strong>web应用开发框架</strong>，它提供了一系列的强大特性，帮助你<strong>创建各种Web应用</strong>。<br>我们可以使用<code>npm install express</code>命令进行下载。</p>
<h2 id="Express框架特性"><a href="#Express框架特性" class="headerlink" title="Express框架特性"></a>Express框架特性</h2><ul>
<li>提供了方便简洁的路由定义方式</li>
<li>对获取HTTP请求参数进行了简化处理</li>
<li>对模板引擎支持程度高，方便渲染动态HTML页面</li>
<li>提供了中间件机制有效控制HTTP请求</li>
<li>拥有大量第三方中间件对功能进行扩展</li>
</ul>
<h1 id="Express框架基本使用"><a href="#Express框架基本使用" class="headerlink" title="Express框架基本使用"></a>Express框架基本使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#123;<span class="attr">name</span>:<span class="string">'张三'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>
<p>在express框架中，我们用res.send()方法来取代res.end()</p>
<ul>
<li>send方法内部会检测响应内容的类型</li>
<li>send方法会自动设置http状态码</li>
<li>send方法会帮我们自动设置响应的内容类型及编码</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><ul>
<li>JSON.parse()方法可以将字符串类型转换成对象类型</li>
<li>JSON.stringify()方法可以将对象类型转换成字符串类型</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架（二） 中间件</title>
    <url>/MyBlog/2020/07/21/Express%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h1><p>&emsp;&emsp;中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p>
<a id="more"></a>

<p>&emsp;&emsp;中间件主要由两部分构成，中间件方法以及请求处理函数。中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'请求路径'</span>,<span class="string">'处理函数'</span>)<span class="comment">//接收并处理get请求</span></span><br><span class="line">app.post(<span class="string">'请求路径'</span>,<span class="string">'处理函数'</span>)<span class="comment">//接收并处理post请求</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以针对同一个请求设置多个中间件，对<strong>同一个请求进行多次处理</strong>。   默认情况下，请求从上到下依次匹配中间件，<strong>一旦匹配成功，终止匹配</strong>。   可以调用<code>next</code>方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get (<span class="string">'/request'</span>, (req, res, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">//为req添加一个name属性</span></span><br><span class="line">    req.name =<span class="string">"张三"</span>;</span><br><span class="line">    <span class="comment">//权限控制函数，继续向下执行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/request'</span>,(reg, res)=&gt;&#123;</span><br><span class="line">    res.send (req.name);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="app-use中间件用法"><a href="#app-use中间件用法" class="headerlink" title="app.use中间件用法"></a>app.use中间件用法</h1><p>&emsp;&emsp;app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应所有路径的请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();<span class="comment">//next一定要写</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>app.use第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应admin路径的请求</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req, res, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h1><h2 id="路由保护"><a href="#路由保护" class="headerlink" title="路由保护"></a>路由保护</h2><p>&emsp;&emsp;客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p>
<p>来举个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">//模拟用户登录状态</span></span><br><span class="line">    <span class="keyword">let</span> islogin == <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(islogin)&#123;</span><br><span class="line">        <span class="comment">//如果用户登录，请求继续向下执行</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用户没有登录，对客户端做出响应</span></span><br><span class="line">        res.send(<span class="string">'您还没有登录，无法访问'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/admin'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'已经登录，可以访问当前页面'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="网站维护公告"><a href="#网站维护公告" class="headerlink" title="网站维护公告"></a>网站维护公告</h2><p>&emsp;&emsp;在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">'网站正在维护...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自定义404界面"><a href="#自定义404界面" class="headerlink" title="自定义404界面"></a>自定义404界面</h2><p>&emsp;&emsp;在所有路由的最后面定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line">app.use(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/admin'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">404</span>)</span><br><span class="line">    res.send(<span class="string">'当前访问页面不存在'</span>)</span><br><span class="line">    <span class="comment">//还可以用链式调用的写法</span></span><br><span class="line">    <span class="comment">//res.status(404).send('当前访问页面不存在')</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h1><p>&emsp;&emsp;在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'index'</span>(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//手动构造错误并抛出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'程序崩溃'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;错误处理中间件只能捕获同步任务，异步任务需要手动触发错误处理中间件</p>
<p>&emsp;&emsp;当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'index'</span>(req,res,next)=&gt;&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./demo.txt'</span>,<span class="string">'utf8'</span>,(err,result)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)&#123;</span><br><span class="line">           next(err)<span class="comment">//next()没有传递参数时，是把控制权交给下一个中间件，但是传递了参数，表示要触发错误处理中间件</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.send(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功！'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="异步函数捕获错误"><a href="#异步函数捕获错误" class="headerlink" title="异步函数捕获错误"></a>异步函数捕获错误</h1><p>&emsp;&emsp;在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢?</p>
<p>&emsp;&emsp;try catch可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误(如回调函数)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">'util'</span>).promisify</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)<span class="comment">//把readFile变成异步方法</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>,<span class="keyword">async</span>(reg, res, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> readFile(<span class="string">'./aaa.js'</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        next(ex);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa框架（一） 安装和基本使用</title>
    <url>/MyBlog/2020/08/22/Koa%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、Koa框架介绍"><a href="#一、Koa框架介绍" class="headerlink" title="一、Koa框架介绍"></a>一、Koa框架介绍</h1><p>&emsp;&emsp;Node.js是一个异步的世界，官方API支持的都是callback形式的异步编程模型，这会带来许多问题，例如:1、callback嵌套问题2、异步函数中可能同步调用callback返回数据，带来不一致性。为了解决以上问题Koa出现了。</p>
<p>&emsp;&emsp;<strong>Koa–基于Node.js平台的下一代web开发框架</strong></p>
<p>&emsp;&emsp;koa是由Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的Web框架。使用koa编写web应用，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写Web应用变得得心应手。<strong>开发思路和express差不多，最大的特点就是避免异步嵌套</strong></p>
<h1 id="Koa2-x的安装使用"><a href="#Koa2-x的安装使用" class="headerlink" title="Koa2.x的安装使用"></a>Koa2.x的安装使用</h1><h2 id="安装Node-js-8-x以上的版本"><a href="#安装Node-js-8-x以上的版本" class="headerlink" title="安装Node.js 8.x以上的版本"></a>安装Node.js 8.x以上的版本</h2><p>&emsp;&emsp;开发Koa2之前，Node.js是有要求的，它要求Node.js版本高于V7.6。因为 node.js 7.6版本开始完全支持async/await，所以才能完全你支持我们的Koa2</p>
<h2 id="安装Koa"><a href="#安装Koa" class="headerlink" title="安装Koa:"></a>安装Koa:</h2><p>&emsp;&emsp;安装Koa框架和我们以前安装其他模块是一样的。</p>
<blockquote>
<p>npm install –save koa  /  cnpm install –save koa</p>
</blockquote>
<p>–save参数，表示自动修改package.json文件，自动添加依赖项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们先npm init --yes初始化项目，自动创建package.json</span></span><br><span class="line"><span class="comment">//然后创建app.js  如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">const</span> Koa=<span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">'你好koa2.x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于 express中</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req.res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'你好koa2.x'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa框架（二） 路由</title>
    <url>/MyBlog/2020/08/22/Koa%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Koa路由介绍和使用"><a href="#Koa路由介绍和使用" class="headerlink" title="Koa路由介绍和使用"></a>Koa路由介绍和使用</h1><p>&emsp;&emsp;路由（Routing）是由一个URL(或者叫路径）和一个特定的HTTP方法（GET、POST等)组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>&emsp;&emsp;通俗的讲:路由就是根据不同的URL地址，加载不同的页面实现不同的功能。</p>
<p>&emsp;&emsp;Koa中的路由和Express有所不同，在Express中直接引入Express就可以配置路由，但是在Koa中我们需要安装对应的<code>koa-router</code>路由模块来实现。</p>
<blockquote>
<p>npm install –save koa-router</p>
</blockquote>
<p>然后就可以使用了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span> (<span class="string">'koa'</span>) :</span><br><span class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span> (<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> app =  <span class="keyword">new</span> Koa ();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置路由，在express中，调用参数有req，res，但是在Koa中request和response的所有信息都放在context（上下文）中 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span>(ctx)=&gt; &#123;</span><br><span class="line">    <span class="comment">//ctx.body相当于res.send()</span></span><br><span class="line">    ctx.body=<span class="string">'首页'</span><span class="comment">//返回数据</span></span><br><span class="line">&#125;).get(<span class="string">'/news'</span>,<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">'新闻页'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span>(ctx)=&gt; &#123;</span><br><span class="line">    <span class="comment">//ctx.body相当于res.send()</span></span><br><span class="line">    ctx.body=<span class="string">'首页'</span><span class="comment">//返回数据</span></span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/news'</span>,<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">'新闻页'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//启动路由  </span></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Koa的路由还有另一种实例化方法和监听方法，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span> (<span class="string">'koa'</span>) :</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span> (<span class="string">'koa-router'</span>)();<span class="comment">//导的过程实例化</span></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> app =  <span class="keyword">new</span> Koa () ;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span>(ctx)=&gt; &#123;</span><br><span class="line">    <span class="comment">//ctx.body相当于res.send()</span></span><br><span class="line">    ctx.body=<span class="string">'首页'</span><span class="comment">//返回数据</span></span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/news'</span>,<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">'新闻页'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//启动路由  </span></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Koa路由-Get传值"><a href="#Koa路由-Get传值" class="headerlink" title="Koa路由 Get传值"></a>Koa路由 Get传值</h1><p>当浏览器url发来的路径后面带上<code>？xxx=xxx</code>，在Koa里面如何获取请求参数呢</p>
<p>在koa2中GET传值通过request接收，但是接收的方法有两种:<code>query</code>和<code>querystring</code>.</p>
<ul>
<li>query:返回的是格式化好的参数对象。</li>
<li>querystring:返回的是请求字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在express中，我们可以用req.query,在Koa中，所有信息都放在ctx中，可以从ctx中拿</span></span><br><span class="line">router.get(<span class="string">'/newscontent'</span>,(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url =ctx.url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从request中获取GET 请求</span></span><br><span class="line">    <span class="keyword">let</span> request =ctx.request;</span><br><span class="line">    <span class="keyword">let</span> req_query = request.query;<span class="comment">//包含域名信息和请求头信息</span></span><br><span class="line">    <span class="keyword">let</span> req_querystring = request.querystring;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从上下文中直接获取</span></span><br><span class="line">    <span class="keyword">let</span> ctx_query = ctx.query; <span class="comment">//***&#123;aid: '123'&#125;获取的是对象,用的最多的方式</span></span><br><span class="line">    <span class="keyword">let</span> ctx_querystring = ctx.querystring;<span class="comment">//'aid=123&amp;name=zhangsan获取的是一个字符串</span></span><br><span class="line"></span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        url,</span><br><span class="line">        req_query,</span><br><span class="line">        req_querystring,</span><br><span class="line">        ctx_query,</span><br><span class="line">        ctx_querystring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Koa路由-动态路由传值"><a href="#Koa路由-动态路由传值" class="headerlink" title="Koa路由 动态路由传值"></a>Koa路由 动态路由传值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态路由需在路由后面跟上/:xx</span></span><br><span class="line">router.get(<span class="string">'/newscontent/:aid'</span>,(ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">//获取动态路由的传值</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.params)<span class="comment">//&#123;aid:'456'&#125;</span></span><br><span class="line">    ctx.body=<span class="string">"新闻aid页面详情"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态路由里面可以传递多个值</span></span><br><span class="line">router.get(<span class="string">'/newscontent/:aid/:bid'</span>,(ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">//获取动态路由的传值</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.params)<span class="comment">//&#123;aid:'456'&#125;</span></span><br><span class="line">    ctx.body=<span class="string">"新闻aid页面详情"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Koa路由-Post传值"><a href="#Koa路由-Post传值" class="headerlink" title="Koa路由 Post传值"></a>Koa路由 Post传值</h1><p>在koa中，我们可以用koa-bodyparser来获取post提交的数据</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm install –save koa-bodyparser</p>
<h2 id="引入中间件"><a href="#引入中间件" class="headerlink" title="引入中间件"></a>引入中间件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span> (<span class="string">'koa'</span>) :</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span> (<span class="string">'koa-router'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app =  <span class="keyword">new</span> Koa () ;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/add'</span>,<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">//crx.request.body 获取post数据，数据为对象形式</span></span><br><span class="line">    ctx.body = ctx.request.body</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa框架（三） 中间件</title>
    <url>/MyBlog/2020/08/23/Koa%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h1><p>&emsp;&emsp;通俗的讲:中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。<br>&emsp;&emsp;在<code>express</code>中间件(Middleware)是一个函数,它可以访问请求对象<code>(request object(req))</code>,响应对象<code>(response object(res))</code>，和web应用中处理请求-响应循环流程中的中间件，一般被命名为<code>next</code>的变量。在Koa中中间件和express有点类似。</p>
<p>中间件的功能包括:</p>
<ul>
<li>执行任何代码。</li>
<li>修改请求和响应对象。</li>
<li>终结请求-响应循环。</li>
<li>调用堆栈中的下一个中间件。</li>
</ul>
<p>如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写<code>next()</code></p>
<h1 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title="应用级中间件"></a>应用级中间件</h1><p>我们来实现一个不管接到任何请求都打印日期的中间件，也叫<strong>应用级中间件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>( <span class="string">'koa '</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="comment">//设置中间件，可以设置匹配路由 app.use('/',functio()) 不设置默认匹配所有路由</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    <span class="comment">//当前路由匹配完成以后继续向下匹配,如果不写next，路由匹配到了就不会继续向下</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    ctx.body=<span class="string">"Hello koa"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/news '</span>,(ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">"新闻页面"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes());<span class="comment">//作用:启动路由</span></span><br><span class="line">app.use(router.allowedMethods());<span class="comment">//作用:当请求出错时的处理逻辑</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title="路由级中间件"></a>路由级中间件</h1><p>我们可以在路由当中加一个next(),路由匹配完也会继续向下执行   </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/news'</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是一个新闻'</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/news'</span>,<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">'这是一个新闻'</span>;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在Koa中，总是先把app.use的中间件先执行完再去执行router的匹配，并不是顺序执行，所以可以把app.use放在路由匹配的下面</strong></p>
<p>那么，koa的错误处理中间件该怎么做呢？，毕竟Koa中间件不是顺序执行的</p>
<h1 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是一个中间件01'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先放下去匹配</span></span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果匹配不到，进行错误处理</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.status==<span class="number">404</span>)&#123;<span class="comment">//如果页面找不到</span></span><br><span class="line">        <span class="comment">//不重新赋值会变回200</span></span><br><span class="line">        ctx.status = <span class="number">404</span>;</span><br><span class="line">        ctx.body=<span class="string">"这是一个404页面"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/news'</span>,(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'news page'</span>)</span><br><span class="line">    ctx.body=<span class="string">"新闻页面"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们输入域名/news,会经过以下步骤</p>
<ul>
<li>匹配中间件，控制台输出 这是一个中间件01</li>
<li>查找/news路由，匹配成功，输出news page，向浏览器返回新闻页面</li>
</ul>
<p>当我们输入域名/xxx会经过以下步骤</p>
<ul>
<li>匹配中间件，控制台输出 这是一个中间件01</li>
<li>查找/xxx路由，查找不到，if(ctx.status==404)判断成功</li>
<li>返回浏览器 这是一个404页面</li>
</ul>
<h1 id="中间件的洋葱模型"><a href="#中间件的洋葱模型" class="headerlink" title="中间件的洋葱模型"></a>中间件的洋葱模型</h1><p>我们来看看中间件的使用，一层一层向下再一层一层向上，称为洋葱模型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字为执行顺序</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1、这是第一个中间件01'</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5、匹配完成以后又会返回来执行中间件'</span>);</span><br><span class="line">)&#125;</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2、这是第一个中间件02'</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4、匹配完成以后又会返回来执行中间件'</span>);</span><br><span class="line">)&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/news'</span>,asyns(ctx)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3、匹配到了这个路由'</span>);</span><br><span class="line">    ctx.body=<span class="string">"news page "</span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Koa跨域处理中间件"><a href="#Koa跨域处理中间件" class="headerlink" title="Koa跨域处理中间件"></a>Koa跨域处理中间件</h1><p>在koa2里解决跨域的中间件叫<code>koa2-cors</code>,安装如下</p>
<blockquote>
<p>npm install –save koa2-cors</p>
</blockquote>
<p>安装完成后，记得要在文件中引入和注册（使用）一下中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa2-cors'</span>)</span><br><span class="line">app.use(cors())</span><br></pre></td></tr></table></figure>
<p>这样就实现了跨域访问</p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa框架（四） Koa中的Cookie和Session</title>
    <url>/MyBlog/2020/08/23/Koa%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Koa中Cookie的使用"><a href="#Koa中Cookie的使用" class="headerlink" title="Koa中Cookie的使用"></a>Koa中Cookie的使用</h1><p>cookie可以实现的功能：</p>
<ul>
<li>保存用户信息</li>
<li>浏览器历史记录</li>
<li>猜你喜欢的功能</li>
<li>10天免登陆</li>
<li>多个页面之间的数据传递</li>
<li>cookie实现购物车功能<h2 id="设置Cookie的值"><a href="#设置Cookie的值" class="headerlink" title="设置Cookie的值"></a>设置Cookie的值</h2><blockquote>
<p>ctx.cookies.set(name,value,{options})</p>
</blockquote>
</li>
</ul>
<p>其中，options参数可选以下值：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/options%E5%80%BC.png" alt=""></p>
<h2 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h2><blockquote>
<p>ctx.cookies.get(‘name’)</p>
</blockquote>
<a id="more"></a>
<h2 id="Koa中设置中文cookie"><a href="#Koa中设置中文cookie" class="headerlink" title="Koa中设置中文cookie"></a>Koa中设置中文cookie</h2><p>我们用cookies.set的方法没办法设置中文cookie，会报错。那我们就可以用到以下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">'hello，world!'</span>).toString (<span class="string">'base64'</span>))<span class="comment">//转换成base64字符串: aGvsbG8sIHdvcmxkIQ==</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">'aGVsbG8sIHdvcmxkIQ=='</span>,<span class="string">'base64'</span>).toString());<span class="comment">//还原base64字符串:hello, world!</span></span><br></pre></td></tr></table></figure>
<p>在项目中，我们就可以这么使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>,<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="keyword">new</span> Buffer(<span class="string">'张三'</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"></span><br><span class="line">    ctx.cookies.set(<span class="string">'userinfo'</span>,name,&#123;</span><br><span class="line">        maxAge:<span class="number">60</span>*<span class="number">1000</span>*<span class="number">60</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/news'</span>,<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> userinfo=ctx.cookies.get(<span class="string">'userinfo'</span>)</span><br><span class="line">    <span class="keyword">var</span> name = <span class="keyword">new</span> Buffer(userinfo,<span class="string">'base64'</span>).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Koa中Session的使用"><a href="#Koa中Session的使用" class="headerlink" title="Koa中Session的使用"></a>Koa中Session的使用</h1><h2 id="Session工作流程"><a href="#Session工作流程" class="headerlink" title="Session工作流程"></a>Session工作流程</h2><p>&emsp;&emsp;当浏览器访问服务器并发送第一次请求时，服务器端会创建一个<code>session</code>对象，生成一个类似于<code>key,value</code>的键值对，然后将<code>key(cookie)</code>返回到浏览器(客户)端，浏览器下次再访问时，携带 <code>key(cookie)</code>，找到对应的<code>session(value)</code>。客户的信息都保存在<code>session</code>中</p>
<h2 id="Koa-session的使用"><a href="#Koa-session的使用" class="headerlink" title="Koa-session的使用"></a>Koa-session的使用</h2><h3 id="安装koa-session"><a href="#安装koa-session" class="headerlink" title="安装koa-session"></a>安装koa-session</h3><blockquote>
<p>install koa-session –save</p>
</blockquote>
<h3 id="引入koa-session"><a href="#引入koa-session" class="headerlink" title="引入koa-session"></a>引入koa-session</h3><blockquote>
<p>const session = require(‘koa-session’);</p>
</blockquote>
<h3 id="设置官方文档提供的中间件"><a href="#设置官方文档提供的中间件" class="headerlink" title="设置官方文档提供的中间件"></a>设置官方文档提供的中间件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//照着复制就行</span></span><br><span class="line">app.keys = [<span class="string">'some secret hurr'</span>];<span class="comment">//cookie的签名</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> CONFIG = &#123;</span><br><span class="line">  key: <span class="string">'koa.sess'</span>, <span class="comment">//默认</span></span><br><span class="line">  maxAge: <span class="number">86400000</span>,<span class="comment">//cookie过期时间 需要设置</span></span><br><span class="line">  autoCommit: <span class="literal">true</span>, </span><br><span class="line">  overwrite: <span class="literal">true</span>, <span class="comment">//没有效果，默认</span></span><br><span class="line">  httpOnly: <span class="literal">true</span>, <span class="comment">//true表示只有服务器端可以获取cookie</span></span><br><span class="line">  signed: <span class="literal">true</span>, <span class="comment">//签名  默认 </span></span><br><span class="line">  rolling: <span class="literal">false</span>, <span class="comment">//每次访问重新设置session</span></span><br><span class="line">  renew: <span class="literal">true</span>, <span class="comment">//快过期时设置session 当用户在指定时间内有操作，重新设置session，无操作就过期</span></span><br><span class="line">  secure: <span class="literal">true</span>, <span class="comment">//加密cookie</span></span><br><span class="line">  sameSite: <span class="literal">null</span>, </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">app.use(session(CONFIG, app));</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在路由中</span></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">ctx.session.username =<span class="string">'张三'</span></span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line">ctx.session.username</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（一） 安装及环境配置和基本操作</title>
    <url>/MyBlog/2020/07/18/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="MongoDB数据库和可视化软件的下载"><a href="#MongoDB数据库和可视化软件的下载" class="headerlink" title="MongoDB数据库和可视化软件的下载"></a>MongoDB数据库和可视化软件的下载</h2><ul>
<li>下载地址: <a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%98%E7%BD%91.png" alt=""></p>
<a id="more"></a>
<p>按照这个下载，然后再来下载mongodb可视化软件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BD%AF%E4%BB%B6.png" alt=""></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、mongodb的安装</p>
<p>在这我们选择自定义安装，一路next<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/momgodb%E5%AE%89%E8%A3%85.png" alt=""></p>
<p>在这里选择默认值，让他作为服务去运行就行了</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%89%E8%A3%852.png" alt=""></p>
<p>由于我们已经下载过可视化软件，这里就不下载了</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mongodb%E5%AE%89%E8%A3%853.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt=""></p>
<p>2、可视化软件的安装</p>
<p>下载之后直接打开就已经安装完成了，点击Star Using Compass开始使用<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%89%E8%A3%85.png" alt=""></p>
<h1 id="MongoDB的使用"><a href="#MongoDB的使用" class="headerlink" title="MongoDB的使用"></a>MongoDB的使用</h1><h2 id="下载MongoDB第三方包"><a href="#下载MongoDB第三方包" class="headerlink" title="下载MongoDB第三方包"></a>下载MongoDB第三方包</h2><ul>
<li>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose</li>
<li>使用<code>npm install mongoose</code>命令下载<h2 id="在node环境中使用"><a href="#在node环境中使用" class="headerlink" title="在node环境中使用"></a>在node环境中使用</h2>1、启动MongoDB</li>
</ul>
<p>在命令行工具中运行<code>net start mongoDB</code>即可启动MongoDB，否则MongoDB将无法连接。同时，也可以用<code>net stop mongoDB</code>停止服务</p>
<p>2、连接MongoDB</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%BF%9E%E6%8E%A5MongoDB.png" alt=""></p>
<h1 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h1><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>cmd窗口cd到数据库的bin目录下，我是C:\ProgramFiles\MongoDB\Server\4.2\bin&gt;</p>
<p>输入<code>mongo</code>进行数据库操作，输入</p>
<blockquote>
<p>show databases</p>
</blockquote>
<p>就会出现当前以及创建过的数据库</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/showdatabases.png" alt=""></p>
<p>现在想要进入admin目录，输入</p>
<blockquote>
<p>use admin</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%BF%9B%E5%85%A5admin.png" alt=""></p>
<p>当我们use进入不存在的数据库时，不会报错，而会帮我们隐式创建一个该名字的数据库，后期当该数据库有数据时，系统自动创建</p>
<h2 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h2><p>进入已经创建的数据库中，输入</p>
<blockquote>
<p>show collections</p>
</blockquote>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><blockquote>
<p>db.createCollection(‘集合名’)</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88(2).png" alt=""></p>
<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><blockquote>
<p>db.集合名.drop()</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88.png" alt=""></p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><ul>
<li>1通过use语法选中数据库</li>
<li>2通过db.dropDatabase()删除数据库</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（二） CRUD</title>
    <url>/MyBlog/2020/07/19/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="MongoDB-CRUD操作"><a href="#MongoDB-CRUD操作" class="headerlink" title="MongoDB CRUD操作"></a>MongoDB CRUD操作</h1><p>我们先来看看MongoDB中的相关概念</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.png" alt=""></p>
<a id="more"></a>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>&emsp;&emsp;创建集合分为两步，一是对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合。</p>
<p><strong>schema为约束</strong><br>作用:用来约束MongoDB文档数据（哪些字段必须，哪些字段可选的)</p>
<p><strong>model为模型</strong><br>一个模型对应一个集合，后面我们通过模型来管理集合中的数据</p>
<p>集合规则的值可以设置默，如图中的name:String 可以设置为name:{type；String,dafault:’username’}</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88.png" alt=""></p>
<h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><p>创建文档实际上就是<strong>向集合中插入数据。</strong><br>分为两步</p>
<ul>
<li>创建集合实例。</li>
<li>调用实例对象下的save方法将数据保存到数据库中。<h3 id="创建文档方法一"><a href="#创建文档方法一" class="headerlink" title="创建文档方法一"></a>创建文档方法一</h3></li>
</ul>
<p>注意：这里的const的Course可以自己定义，new的对象要和自己定义的一致<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3.png" alt=""></p>
<p>此时，数据库就已经创建成功</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8F%92%E5%85%A5%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h3 id="创建文档方法二"><a href="#创建文档方法二" class="headerlink" title="创建文档方法二"></a>创建文档方法二</h3><p>在集合的构造函数下有一个create方法，可以通过<code>Course.create</code>的方法创建文档</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/createCourse.png" alt=""></p>
<p>注意：<strong>对数据库的所有操作都是异步操作</strong></p>
<p>所以，还可以这么写：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><h3 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h3><p>先来用find的基本方法查询一下所有的文档</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/find%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3.png" alt=""></p>
<p>同时，find()中还可以传递一个对象作为参数，这个对象实际上就是查找条件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p><code>.findOne()</code>方法返回一条文档，默认返回第一条</p>
<h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><p>1、我们用<code>$gt</code>表示大于，<code>$lt</code>表示小于<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p>2、我们用<code>$in</code>表示包含<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8C%85%E5%90%AB%E6%9F%A5%E8%AF%A2.png" alt=""></p>
<p>3、选择要查询的字段<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2.png" alt=""><br>如果不想查询某个字段，只需要在该字段前面加个<code>-</code> ，如<code>select(&#39;email name -_id&#39;)</code></p>
<p>4、排序<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97.png" alt=""></p>
<p>5、skip和limit</p>
<ul>
<li>skip()跳过多少条数据</li>
<li>limit()限制查询数量</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/skip%E5%92%8Climit.png" alt=""></p>
<p>6、查询用户数据的总数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用在分页</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="keyword">await</span> User.countDocuments(&#123;&#125;)</span><br><span class="line"><span class="comment">//和 skip()、limit()一起使用</span></span><br><span class="line"><span class="comment">//总页数</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="built_in">Math</span>.ceil(count / pagesize);</span><br><span class="line"><span class="comment">//页码对应的数据查询开始位置</span></span><br><span class="line"><span class="keyword">let</span> start = (page - <span class="number">1</span>)* pagesize;</span><br><span class="line"><span class="comment">//将用户信息从数据库中查询出来</span></span><br><span class="line"><span class="comment">//渲染用户列表模块</span></span><br><span class="line"><span class="keyword">let</span> users = <span class="keyword">await</span> User.find(&#123;&#125;).limit(pagesize).skip(start)</span><br></pre></td></tr></table></figure>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除id为12345的数据，若匹配到多个，则删除第一个</span></span><br><span class="line">User.findOneAndDelete(&#123;<span class="attr">_id</span>:<span class="string">'12345'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有文档 </span></span><br><span class="line">User.deleteMany(&#123;&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除多个id为12345的文档</span></span><br><span class="line">User.deleteMany(&#123;<span class="attr">_id</span>:<span class="string">'12345'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新单个 </span></span><br><span class="line"><span class="comment">//更新条件： (&#123;查询条件&#125;,&#123;更新后的值&#125;)</span></span><br><span class="line">User.updateOne(&#123;<span class="attr">name</span>:<span class="string">'李四'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'李狗蛋'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新多个 把所有的age改成65</span></span><br><span class="line">User.updateMany(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="string">'65'</span>&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>
<h1 id="mongodb获取前端数据并处理"><a href="#mongodb获取前端数据并处理" class="headerlink" title="mongodb获取前端数据并处理"></a>mongodb获取前端数据并处理</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res, next) =&gt;&#123;</span><br><span class="line">    <span class="comment">//接收客户端传递过来的请求参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username,email, role, state &#125; = req.body;</span><br><span class="line">    <span class="comment">//即将要修改的用户id</span></span><br><span class="line">    <span class="keyword">const</span> id = req.query.id;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    Let user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>: id&#125;);</span><br><span class="line">    <span class="comment">//密码比对</span></span><br><span class="line">    <span class="keyword">const</span> isValid = <span class="keyword">await</span> bcrypt.compare(req.body.password,user.  password);</span><br><span class="line">    <span class="comment">//密码比对成功</span></span><br><span class="line">    <span class="keyword">if</span> (isValid)&#123;</span><br><span class="line">        res.send(<span class="string">'密码比对成功'</span>);</span><br><span class="line">        <span class="comment">//将用户信息更新到数据库中</span></span><br><span class="line">        <span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>: id&#125;,&#123;</span><br><span class="line">            username:username,</span><br><span class="line">            email:email,</span><br><span class="line">            role: role,</span><br><span class="line">            state: state</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">'密码比对失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h1><ul>
<li>required: true必传字段</li>
<li>minlength: 3 字符串最小长度</li>
<li>maxlength: 20 字符串最大长度</li>
<li>min:2 数值最小为2</li>
<li>max: 100 数值最大为100</li>
<li>enum:[‘html’, ‘css’. - ‘javascript’, ‘node.js’]</li>
<li>trim: true 去除字符串两边的空格</li>
<li>validate: 自定义验证器</li>
<li>default: 默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建集合规则时，加入验证,非必填</span></span><br><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> userschema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,<span class="comment">//类型为string</span></span><br><span class="line">        <span class="built_in">require</span>:<span class="literal">true</span>,<span class="comment">//必填字段</span></span><br><span class="line">        minlrngth:<span class="number">2</span>,<span class="comment">//最小长度为2</span></span><br><span class="line">        maxkength:<span class="number">5</span>,<span class="comment">//最大长度为5</span></span><br><span class="line">        trim:<span class="literal">true</span><span class="comment">//去除两边字符串</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,<span class="comment">//最小数字</span></span><br><span class="line">        max:<span class="number">100</span><span class="comment">//最大数字</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publishData:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now<span class="comment">//默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    category:&#123;<span class="comment">//分类</span></span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//枚举  列举出当前字段可以拥有的值</span></span><br><span class="line">        enum:[<span class="string">'html'</span>,<span class="string">'css'</span>,<span class="string">'js'</span>]<span class="comment">//只允许传递这里面的值</span></span><br><span class="line">        <span class="comment">//如果自定义错误信息，还可以这么写：</span></span><br><span class="line">        enum:&#123;</span><br><span class="line">            values:[<span class="string">'html'</span>,<span class="string">'css'</span>,<span class="string">'js'</span>],</span><br><span class="line">            message:<span class="string">'分类信息需在范围之内'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//自定义验证规则</span></span><br><span class="line">        validate:&#123;</span><br><span class="line">            validator:<span class="function"><span class="params">v</span>=&gt;</span>&#123;<span class="comment">//v为传入的值</span></span><br><span class="line">                <span class="keyword">return</span> v &amp;&amp; v.length &gt; <span class="number">4</span><span class="comment">//传入了一个值且这个值的长度大于4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            messgae:<span class="string">'传入的值不符合验证规则'</span><span class="comment">//自定义报错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此时，若插入空数据，如<code>Course.create({})</code>,则插入失败</p>
<p>同时，还能在第二个参数自定义错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userschema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">require</span>:[<span class="literal">true</span>,<span class="string">'请输入文章标题'</span>],</span><br><span class="line">        maxlength:[<span class="number">2</span>,<span class="string">'文章长度最大不能超过2'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="获取错误信息对象"><a href="#获取错误信息对象" class="headerlink" title="获取错误信息对象"></a>获取错误信息对象</h1><p>在插入数据错误时，在错误信息中我们通常可以看到一大串信息，如现在<code>category</code>和<code>author</code>报错，报错信息如下：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt=""></p>
<p>我们现在只想获取报错对象中的<code>errors</code>中的<code>message</code>属性，来更直观的看到哪里有错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = mongoose.model(<span class="string">'Post'</span>, postschema);</span><br><span class="line">Post.create(&#123;<span class="attr">title</span>: <span class="string">'aa'</span>, <span class="attr">age</span>: <span class="number">60</span>,<span class="attr">category</span>: <span class="string">'java'</span>, <span class="attr">author</span>: <span class="string">'bd'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//获取错误信息对象</span></span><br><span class="line">        <span class="keyword">const</span> err = error.errors;</span><br><span class="line">        <span class="comment">//循环错误信息对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> err)&#123;</span><br><span class="line">            <span class="comment">//打印</span></span><br><span class="line">            consoLe.log(err[attr][ <span class="string">'message'</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>现在就能方便的看到具体的报错信息<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%85%B7%E4%BD%93%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的学习使用（三）集合关联、聚合管道</title>
    <url>/MyBlog/2020/07/20/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h1><p>通常<strong>不同集合的数据之间是有关系的</strong>，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的<br>，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p>
<ul>
<li>使用id对集合进行关联</li>
<li>使用populate方法进行关联集合查询</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94.png" alt=""></p>
<a id="more"></a>

<h2 id="集合关联实现"><a href="#集合关联实现" class="headerlink" title="集合关联实现"></a>集合关联实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们先定义两个集合</span></span><br><span class="line"><span class="comment">//用户集合  </span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>,<span class="keyword">new</span> mongoose.schema(&#123;<span class="attr">name</span>:&#123;<span class="attr">type</span>:string )&#125;));<span class="comment">//我们之前是单独给集合规则赋给一个对象，但其实可以直接写在里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文章集合</span></span><br><span class="line"><span class="keyword">const</span> Post = mongoose.model(<span class="string">'Post'</span>, <span class="keyword">new</span> mongoose.schema(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//使用ID将文章集合和作者集合进行关联</span></span><br><span class="line">    author: &#123;</span><br><span class="line">        type: mongoose.schema.Types.ObjectId, </span><br><span class="line">        ref:<span class="string">'User'</span><span class="comment">//当前字段要关联的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建用户</span></span><br><span class="line">User.create(&#123;<span class="attr">name</span>:<span class="string">'yang'</span>&#125; ).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));<span class="comment">//自动生成id为12321412312</span></span><br><span class="line"><span class="comment">//创建文章</span></span><br><span class="line">Post.create(&#123;<span class="attr">titile</span>:<span class="string">'123'</span>，author:<span class="string">'12321412312'</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//联合查询</span></span><br><span class="line">Post.find()<span class="comment">//查询post信息</span></span><br><span class="line">    .then(<span class="function">(<span class="params">err, result</span>)=&gt;</span><span class="built_in">console</span>.log(result));<span class="comment">//查出来的author是id</span></span><br><span class="line"></span><br><span class="line">Post.find()<span class="comment">//查询post信息</span></span><br><span class="line">    .populate(<span class="string">'author'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">err, result</span>)=&gt;</span><span class="built_in">console</span>.log(result));<span class="comment">//查出来的author是一个对象，对象中是author的具体内容</span></span><br></pre></td></tr></table></figure>
<h1 id="聚合管道-Aggregation-Pipeline"><a href="#聚合管道-Aggregation-Pipeline" class="headerlink" title="聚合管道 Aggregation Pipeline"></a>聚合管道 Aggregation Pipeline</h1><p>使用聚合管道可以对集合中的文档进行变换和组合。</p>
<h2 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h2><table>
<thead>
<tr>
<th>管道操作符</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>增加、删除、重命名字段</td>
<td>$project</td>
</tr>
<tr>
<td>条件匹配。只满足条件的文档才能进入下阶段</td>
<td>$match</td>
</tr>
<tr>
<td>限制结果的数量</td>
<td>$limit</td>
</tr>
<tr>
<td>跳过文档的数量</td>
<td>$skip</td>
</tr>
<tr>
<td>条件排序</td>
<td>$sort</td>
</tr>
<tr>
<td>条件组合结果统计</td>
<td>$group</td>
</tr>
<tr>
<td>$lookup操作符用以引入其它集合的数</td>
<td>$lookup</td>
</tr>
</tbody></table>
<h2 id="SQL和NOSQL对比："><a href="#SQL和NOSQL对比：" class="headerlink" title="SQL和NOSQL对比："></a>SQL和NOSQL对比：</h2><table>
<thead>
<tr>
<th>WHERE</th>
<th>$match</th>
</tr>
</thead>
<tbody><tr>
<td>GROUP BY</td>
<td>$group</td>
</tr>
<tr>
<td>HAVING</td>
<td>$match</td>
</tr>
<tr>
<td>SELECT</td>
<td>$project</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>$sort</td>
</tr>
<tr>
<td>LIMIT</td>
<td>$limit</td>
</tr>
<tr>
<td>SUM()</td>
<td>$sum</td>
</tr>
<tr>
<td>COUNT()</td>
<td>$sum</td>
</tr>
<tr>
<td>join</td>
<td>$lookup</td>
</tr>
</tbody></table>
<p>来学着用一下，先搞点数据</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">db</span>.<span class="keyword">order</span>.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"1"</span>,<span class="string">"uid"</span>:10,<span class="string">"trade_no"</span>:<span class="string">"111"</span>,<span class="string">"all_price"</span>:100,<span class="string">"all_num"</span>:2&#125;)</span><br><span class="line"><span class="keyword">db</span>.<span class="keyword">order</span>.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"2"</span>,<span class="string">"uid"</span>:7,<span class="string">"trade_no"</span>:<span class="string">"222"</span>,<span class="string">"all_price"</span>:90,<span class="string">"all_num"</span>:2)</span><br><span class="line"><span class="keyword">db</span>.<span class="keyword">order</span>.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"3"</span>,<span class="string">"uid"</span>:9,<span class="string">"trade_no"</span>:<span class="string">"333"</span> ,<span class="string">"all_price"</span>:20 , <span class="string">"all_num"</span>:6&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span>.order_item.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"1"</span>,<span class="string">"title"</span>:<span class="string">"商品鼠标1"</span>,<span class="string">"price"</span>:50,num:1&#125;)</span><br><span class="line"><span class="keyword">db</span>.order_item.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"1"</span>,<span class="string">"title"</span>:<span class="string">"商品键盘2"</span>,<span class="string">"price"</span>:50,num:1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span>.order_item.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"2"</span>,<span class="string">"title"</span>:<span class="string">"牛奶"</span>,<span class="string">"price"</span> :50,num:1&#125;)</span><br><span class="line"><span class="keyword">db</span>.order_item.insert(&#123;<span class="string">"order_id"</span>:<span class="string">"2"</span>,<span class="string">"title"</span>:<span class="string">"酸奶"</span>,<span class="string">"price"</span> :40,num:1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span> order_item.inset(&#123;<span class="string">"order_id"</span>:<span class="string">"3"</span>,<span class="string">"title"</span>:<span class="string">"矿泉水"</span>,<span class="string">"price"</span>:2,num:5)</span><br><span class="line"><span class="keyword">db</span> order_item.inset(&#123;<span class="string">"order_id"</span>:<span class="string">"3"</span>,<span class="string">"title"</span>:<span class="string">"毛巾"</span>,<span class="string">"price"</span>:2,num:5)</span><br></pre></td></tr></table></figure>
<p>现在我们有一个<code>order</code>表和一个<code>order_item</code>表</p>
<h2 id="project-查询指定的字段"><a href="#project-查询指定的字段" class="headerlink" title="$project 查询指定的字段"></a>$project 查询指定的字段</h2><p>要求查找order只返回文档中trade_no和all_price字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.order.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123; <span class="attr">trade_no</span>:<span class="number">1</span>,<span class="attr">all_price</span>:<span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="match-过滤"><a href="#match-过滤" class="headerlink" title="$match 过滤"></a>$match 过滤</h2><p>作用:用于过滤文档。用法类似于find()方法中的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询all_Price大于90的数据的三个列</span></span><br><span class="line">db.order.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        order_id:<span class="number">1</span>, <span class="attr">trade_no</span>:<span class="number">1</span>, <span class="attr">a11_price</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $match: &#123;<span class="string">"a11_price"</span>: &#123;<span class="attr">$gte</span>:<span class="number">90</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="group-分组"><a href="#group-分组" class="headerlink" title="$group 分组"></a>$group 分组</h2><p>将集合中的文档进行分组，可用于统计结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个订单的订单数量，按照订单号分组</span></span><br><span class="line">db.order_item.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $group:&#123;<span class="attr">_id</span>: <span class="string">"$order_id"</span> , <span class="attr">total</span>: &#123;<span class="attr">$sum</span>:<span class="string">"$num"</span>&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">//统计订单的总价格</span></span><br><span class="line">db.order_item.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $group:&#123;<span class="attr">_id</span>: <span class="string">"$order_id"</span> , <span class="attr">price</span>: &#123;<span class="attr">$sum</span>:<span class="string">"$price"</span>&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="sort-对文档内容进行排序"><a href="#sort-对文档内容进行排序" class="headerlink" title="$sort 对文档内容进行排序"></a>$sort 对文档内容进行排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.order.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123; <span class="attr">trade_no</span>:<span class="number">1</span>,<span class="attr">all_price</span>:<span class="number">1</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $match:&#123;<span class="string">"all_price"</span>:&#123;<span class="attr">$gte</span>:<span class="number">90</span>&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">        $sort:&#123;<span class="string">"all_price"</span>:<span class="number">-1</span>&#125;<span class="comment">//-1表示降序排列，1表示升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="limit-限制数据条数"><a href="#limit-限制数据条数" class="headerlink" title="$limit 限制数据条数"></a>$limit 限制数据条数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.order.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123; <span class="attr">trade_no</span>:<span class="number">1</span>,<span class="attr">all_price</span>:<span class="number">1</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $match:&#123;<span class="string">"all_price"</span>:&#123;<span class="attr">$gte</span>:<span class="number">90</span>&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">        $sort:&#123;<span class="string">"all_price"</span>:<span class="number">-1</span>&#125;<span class="comment">//-1表示降序排列，1表示升序排列</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">        $limit:<span class="number">1</span><span class="comment">//限制一条数据 skip用法同理</span></span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="lookup-表关联"><a href="#lookup-表关联" class="headerlink" title="$lookup 表关联"></a>$lookup 表关联</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.order.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup: &#123;</span><br><span class="line">            <span class="keyword">from</span>: <span class="string">"order_item"</span>,<span class="comment">//order表要和哪个表进行关联</span></span><br><span class="line">            localField: <span class="string">"order_id"</span>,<span class="comment">//要关联的字段</span></span><br><span class="line">            foreignField: <span class="string">"order_id"</span>,<span class="comment">//另一个表的该字段</span></span><br><span class="line">            <span class="keyword">as</span>: <span class="string">"item"</span><span class="comment">//关联的数据放在item里面</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs中http请求与响应处理</title>
    <url>/MyBlog/2020/06/30/Nodejs%E4%B8%ADhttp%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>首先，我们先来创建一个网站服务器</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/node%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt=""></p>
<p>其中，当有请求来的时候，会触发request这个事件，然后执行后面的事件处理函数。我们可以通过res.end对客户端进行响应</p>
<a id="more"></a>
<h1 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h1><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><ul>
<li>Get请求数据</li>
<li>Post请求数据<h2 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h2><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80.png" alt=""><br>我们可以通过<code>req.url</code>来获取客户端请求地址，通过<code>req.headers</code>获取请求报文，<code>req.methods</code>获取请求方法(get/post)</li>
</ul>
<h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><ul>
<li>200请求成功</li>
<li>404请求的资源没有被找到</li>
<li>500 服务器端错误</li>
<li>400客户端请求有语法错误<h2 id="响应内容类型"><a href="#响应内容类型" class="headerlink" title="响应内容类型"></a>响应内容类型</h2></li>
<li>text/html</li>
<li>text/css</li>
<li>application/javascript</li>
<li>image/jpeg</li>
<li>application/json</li>
</ul>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>客户端向服务器端发送请求时，有时需要携带一些客户信息, 客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p>
<h2 id="get请求参数"><a href="#get请求参数" class="headerlink" title="get请求参数"></a>get请求参数</h2><ul>
<li>参数被放置在浏览器地址栏中，例如: <a href="http://localhost:3000/?name=" target="_blank" rel="noopener">http://localhost:3000/?name=</a> zhangsan&amp;age= 20</li>
</ul>
<p>那么怎么拿到get的参数呢？<br>node为我们提供了一个内置模块</p>
<blockquote>
<p>const url = require(‘url)</p>
</blockquote>
<p>在url模块中，有一个parse()方法可以处理url，我们只需要将想解析的url传给url.parse()方法进行解析，最终，这个方法会返回一个对象。我们来console.log一下<code>url.parse(req.url)</code></p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/urlparse%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>现在，我们把查询参数转换成对象。</p>
<blockquote>
<p>url.parse(req.url,true)</p>
</blockquote>
<ul>
<li>第一个参数是要解析的url地址</li>
<li>第二个参数表示把查询参数解析成对象形式。</li>
</ul>
<p>此时，url.paesr中的query参数会变成一个对象 <code>query:&#39;name=zhangsan ,age=&#39;20&#39;</code><br>这个时候，我们就可以通过<code>url.parse(res.url,true).query</code>拿到这个对象</p>
<blockquote>
<p>let params = url.parse(res.url,true).query</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cocnsole.log(params.name)<span class="comment">//zhangsan</span></span><br><span class="line">cocnsole.log(params.age)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在parse()方法中，还有一个pathname属性可以帮我们获取到不包含请求参数的请求地址。这样，我们就可以通过对象结解构的方式拿到query和pathname</p>
<blockquote>
<p>let {query, pathname} = url.parse(res.url,true)</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/parse%E6%96%B9%E6%B3%95.png" alt=""></p>
<h2 id="post请求参数"><a href="#post请求参数" class="headerlink" title="post请求参数"></a>post请求参数</h2><p>我们可以通过表单方式提交一个post请求，post方式是通过事件的方式接收的。<strong>当请求传递参数时触发data事件</strong>，<strong>当传递完成时触发end事件</strong></p>
<p>我们通过querystring这个内置模块来处理post的请求参数</p>
<blockquote>
<p>const querystring = require(‘querystring’);</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/querystring%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86post.png" alt=""></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p><a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a></p>
<p><a href="http://localhost:3000/login" target="_blank" rel="noopener">http://localhost:3000/login</a></p>
<p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p>
<p>实现路由的核心代码</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81.png" alt=""></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs中的密码加密bcrypt</title>
    <url>/MyBlog/2020/07/22/Nodejs%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86bcrypt/</url>
    <content><![CDATA[<h1 id="密码加密bcrypt"><a href="#密码加密bcrypt" class="headerlink" title="密码加密bcrypt"></a>密码加密bcrypt</h1><p>&emsp;&emsp;哈希加密是单程加密方式:1234 =&gt; abcd，无法解密。但是，在加密的密码中加入随机字符串可以增加密码被破解的难度。</p>
<p>先看一个小demo介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入bcrypt模块</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span> (<span class="string">'bcrypt'</span>) ;</span><br><span class="line">    <span class="comment">//生成随机字符串</span></span><br><span class="line">    <span class="comment">// genSalt方法接收一个数值作为参数</span></span><br><span class="line">    <span class="comment">//数值越大生成的随机字符串复杂度越高</span></span><br><span class="line">    <span class="comment">//数值越小生成的随机字符串复杂度越低</span></span><br><span class="line">    <span class="comment">//默认值是10</span></span><br><span class="line">    <span class="comment">//返回生成的随机字符串</span></span><br><span class="line"><span class="keyword">let</span> salt = <span class="keyword">await</span> bcrypt.gensalt(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//对密码进行加密</span></span><br><span class="line">    <span class="comment">//第一个参数．要进行加密的明文</span></span><br><span class="line">    <span class="comment">//第二个参数．随机字符串</span></span><br><span class="line">    <span class="comment">//返回值是加密后的密码</span></span><br><span class="line"><span class="keyword">let</span> pass = <span class="keyword">await</span> bcrypt.hash (<span class="string">'明文密码,'</span>salt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码比对</span></span><br><span class="line"><span class="keyword">let</span> isEqual = <span class="keyword">await</span> bcrypt.compare(<span class="string">'明文密码'</span>,<span class="string">'加密密码'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="bcrypt安装"><a href="#bcrypt安装" class="headerlink" title="bcrypt安装"></a>bcrypt安装</h1><blockquote>
<p>npm install bcrypt</p>
</blockquote>
<h2 id="bcrypt依赖的其他环境-需要提前安装"><a href="#bcrypt依赖的其他环境-需要提前安装" class="headerlink" title="bcrypt依赖的其他环境(需要提前安装)"></a>bcrypt依赖的其他环境(需要提前安装)</h2><ul>
<li>python 2.x<blockquote>
<p>去官网安装</p>
</blockquote>
</li>
<li>node-gyp<blockquote>
<p>npm install -g node-gyp</p>
</blockquote>
</li>
<li>windows-build-tools<blockquote>
<p>npm install –global –production windows-build-tools</p>
</blockquote>
</li>
</ul>
<h1 id="bcrypt的使用"><a href="#bcrypt的使用" class="headerlink" title="bcrypt的使用"></a>bcrypt的使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在model下的user.js中</span></span><br><span class="line"><span class="comment">//创建用户集合</span></span><br><span class="line"><span class="comment">//引入mongoose第三方模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">//导入bcrypt</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>( <span class="string">'bcrypt'</span>);</span><br><span class="line"><span class="comment">//创建用户集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    username:<span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    password:<span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//创建集合</span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>,userSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> pass = <span class="keyword">await</span> bcrypt.hash(<span class="string">'123456'</span>,salt);</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">        username:<span class="string">'yang'</span>,</span><br><span class="line">        email: <span class="string">'yang@qq.cn'</span>,</span><br><span class="line">        password: pass,</span><br><span class="line">        role: <span class="string">'admin'</span>,</span><br><span class="line">        state:<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">creatUser()</span><br></pre></td></tr></table></figure>
<h2 id="在验证登录逻辑中加上密码的比对"><a href="#在验证登录逻辑中加上密码的比对" class="headerlink" title="在验证登录逻辑中加上密码的比对"></a>在验证登录逻辑中加上密码的比对</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现登录功能</span></span><br><span class="line">admin.post(<span class="string">'/login'</span>, <span class="keyword">async</span>(req,res）=&gt;&#123;</span><br><span class="line">    <span class="comment">//接收请求参数 解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123;email,password&#125; = req.body;</span><br><span class="line">    <span class="comment">//如果用户没有输入邮件地址</span></span><br><span class="line">    <span class="keyword">if</span> (email.trim().length == <span class="number">0</span> || password.trim().length = <span class="number">0</span>) <span class="keyword">return</span> res.status(<span class="number">400</span>).send(<span class="string">'请输入邮件地址或密码'</span>)</span><br><span class="line">    <span class="comment">//根据邮箱地址查询用户信息</span></span><br><span class="line">    <span class="comment">//如果查询到了用户user变量的值是对象类型对象中存储的是用户信息</span></span><br><span class="line">    <span class="comment">//如果没有查询到用户user变量为空</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123;email&#125;);</span><br><span class="line">    <span class="comment">//查询到了用户</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;  </span><br><span class="line">        <span class="comment">//将客户端传递过来的密码和用户信息中的密码进行比对</span></span><br><span class="line">        <span class="comment">// true比对成功</span></span><br><span class="line">        <span class="comment">// false对比失败</span></span><br><span class="line">        <span class="keyword">let</span> isValid = <span class="keyword">await</span> bcrypt.compare(password,user.password)</span><br><span class="line">        <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">            <span class="comment">//比对成功</span></span><br><span class="line">            res.send(<span class="string">'登录成功'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//密码不一样</span></span><br><span class="line">            res.status(<span class="number">400</span>).render(<span class="string">'admin/error'</span>, &#123;<span class="attr">msg</span>:<span class="string">'邮箱地址或者密码错误'</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//没查到</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.status(<span class="number">400</span>).render(<span class="string">'admin/error'</span>, &#123;<span class="attr">msg</span>:<span class="string">'邮箱地址或者密码错误'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="密码加密传入数据库"><a href="#密码加密传入数据库" class="headerlink" title="密码加密传入数据库"></a>密码加密传入数据库</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对密码进行加密处理</span></span><br><span class="line"><span class="comment">//生成随机字符串</span></span><br><span class="line"><span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="comment">//替换密码</span></span><br><span class="line">req.body.password = password;</span><br><span class="line"><span class="comment">//将用户信息添加到数据库中,用户信息就是post请求传过来的req.body中的数据</span></span><br><span class="line"><span class="keyword">await</span> User.create(req.body);</span><br><span class="line"><span class="comment">//将页面重定向到用户列表页面</span></span><br><span class="line">res.redirect(<span class="string">'/admin/user'</span>);</span><br><span class="line"><span class="keyword">const</span> password = <span class="keyword">await</span> bcrypt.hash(req.body.password,salt);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>密码加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs异步编程</title>
    <url>/MyBlog/2020/07/01/Nodejs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="同步api-异步api"><a href="#同步api-异步api" class="headerlink" title="同步api,异步api"></a>同步api,异步api</h1><p>同步API:只有当前API执行完成后,才能继续执行下一个API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line"><span class="comment">//输出before after</span></span><br></pre></td></tr></table></figure>
<p>异步API:当前API的执行不会阻塞后续代码的执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>) ;</span><br><span class="line">setTimeout (</span><br><span class="line">    () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'last'</span>) ;</span><br><span class="line">&#125;，<span class="number">2000</span>) ;</span><br><span class="line"><span class="built_in">console</span>. log(<span class="string">'after'</span>) ;</span><br><span class="line"><span class="comment">//输出after before</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="同步api，异步api的区别（获取返回值）"><a href="#同步api，异步api的区别（获取返回值）" class="headerlink" title="同步api，异步api的区别（获取返回值）"></a>同步api，异步api的区别（获取返回值）</h1><p>同步API可以从返回值中拿到API执行的结果，但是异步API是不可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">n1, n2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = sum (<span class="number">10</span>， <span class="number">20</span>) ;</span><br><span class="line"><span class="comment">//输出30</span></span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">msg</span>: <span class="string">'Hello Node. js'</span> &#125;</span><br><span class="line">    &#125;，<span class="number">2000</span>) ;</span><br><span class="line"><span class="keyword">const</span> msg = getMsg() ;</span><br><span class="line"><span class="comment">//msg=undefined</span></span><br></pre></td></tr></table></figure>
<p>那么，异步api的返回值要怎么拿到呢？可以通过回调函数</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>自己定义，让别人去调用<br>来看一个简单的栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'callback函数被调用了'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>把函数当做参数传递，我们还可以给传递的函数再加一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback(<span class="string">'123'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'callback函数被调用了'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>如果getData这个函数内部有异步操作，那么在异步操作执行完成的时候，就会调用回调函数，并且把异步api执行的结果通过参数的形式传递给callback，那么在getData里面的回调函数里面就能拿到这个异步api执行的结果</strong><br>来看一个定时器的异步例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(&#123;</span><br><span class="line">            msg: <span class="string">'hello node.js'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">getMsg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="异步编程代码执行顺序分析"><a href="#异步编程代码执行顺序分析" class="headerlink" title="异步编程代码执行顺序分析"></a>异步编程代码执行顺序分析</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">'代码开始执行'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2s'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">setTimeout (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'0s'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span> . log( <span class="string">'代码结束执行'</span>)</span><br><span class="line"><span class="comment">//输出结果：代码开始执行  代码结束执行 0s 2s</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt=""></p>
<p>当同步代码执行结束后，开始执行异步代码，0秒执行的定时器先执行完，系统调用他的回调函数</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F1.png" alt=""></p>
<p>然后，2秒钟之后执行的定时器也执行完，加入到执行队列中</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F2.png" alt=""></p>
<p>大功告成！</p>
<h1 id="Node-js中的异步api"><a href="#Node-js中的异步api" class="headerlink" title="Node.js中的异步api"></a>Node.js中的异步api</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./demo. txt'</span>,(err, result) =&gt;&#123;&#125;) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http. createServer() ;</span><br><span class="line">server.on(<span class="string">' request'</span>，(req, res) =&gt; &#123;&#125;) ;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢?</p>
<p>现在，我们有个需求：依次读取A文件、B文件、C文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span> );</span><br><span class="line"></span><br><span class="line">fs. readFile(<span class="string">'./1.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result1 )</span><br><span class="line">    fs .readFile(<span class="string">'./2.txt'</span>, <span class="string">'utf8'</span>, (err, result2) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>. log(result2)</span><br><span class="line">        fs.readFile(<span class="string">'./3.txt'</span>, <span class="string">' utf8'</span>, (err, result3) =&gt;</span><br><span class="line">            <span class="built_in">console</span> . log(result3)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们无限嵌套下去，发生了回调地狱。ES6为我们提供了一个promise的方法来解决回调地狱</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise出现的目的是解决Nodejs异步编程中回调地狱的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            resolve (&#123;<span class="attr">name</span>: <span class="string">'张三'</span> &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'失败了'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="number">2000</span>) ;</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure>
<ul>
<li>当异步api有返回结果时，可以调用resolve函数，并把异步api的执行结果通过参数形式传递</li>
<li>当异步api执行失败，我们就可以调用reject这个函数，把这个失败的结果传递到promise外面</li>
</ul>
<p>我们在promise外面怎么拿到异步api的执行结果呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then (<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result) ; <span class="comment">// (name: '张三'&#125;</span></span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error) ;<span class="comment">// 失败了)</span></span><br></pre></td></tr></table></figure>
<p>对promise有个了解后，我们来实现需求,先读取一个文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>( <span class="string">'fs'</span> );</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    fs.readFile(<span class="string">'./1. txt'</span>, <span class="string">'utf8'</span>, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(result); </span><br><span class="line">            <span class="comment">//异步api执行成功后调用resolve，其实就是调用then里面的()=&gt;&#123;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们改造一下，利用promise解决回调地狱</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./1.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result1)</span><br><span class="line">             <span class="comment">//异步api执行成功后调用resolve，其实就是调用then里面的()=&gt;&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./2.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result2)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./3.txt'</span>，<span class="string">' utf8'</span>, (err, result1) =&gt; &#123;</span><br><span class="line">            resolve(result3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="keyword">return</span> p2();<span class="comment">//这里的p2是一个promise对象，相当于return了一个promise对象，然后对这个promise对象调用.then方法</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result2)</span><br><span class="line">    <span class="keyword">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result3</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><p>异步函数是ES7中新增方法，异步函数是异步编程语法的终极解决方案,它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套,使代码变得清晰明了。<br><strong>async关键字</strong></p>
<ul>
<li>在普通函数前面加上async关键字，普通函数就变成了异步函数</li>
<li>异步函数默认返回值是promise对象</li>
<li>在异步函数内部使用return关键字进行结果返回结果会被包裹的promise对象中return关键字代替了resolve方法</li>
<li>在异步函数内部使用throw关键字抛出程序异常</li>
<li>调用异步函数再链式调用then方法获取异步函数执行结果</li>
<li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li>
</ul>
<p><strong>await关键字</strong></p>
<ul>
<li>它只能出现在异步函数中</li>
<li>await  promise它可以暂停异步函数的执行等待promise对象返回结果后再向下执行</li>
<li>await promise await后面只能写promise对象，写其他类型的API是不可以的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p1'</span>;</span><br><span class="line">    <span class="comment">//async修饰的函数返回一个promise对象</span></span><br><span class="line">    <span class="comment">//return promise&#123;'p1'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'p3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> p1()</span><br><span class="line">    <span class="keyword">let</span> r2 = <span class="keyword">await</span> p2()</span><br><span class="line">    <span class="keyword">let</span> r3 = <span class="keyword">await</span> p3()</span><br><span class="line">    <span class="built_in">console</span>.log(r1)</span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(r2)</span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(r3)</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"><span class="comment">//输出 p1 p2 p3 把异步操作写成了同步代码</span></span><br></pre></td></tr></table></figure>
<p>现在，我们用async、await改造读取文件顺序输出需求</p>
<p>&emsp;&emsp;首先，我们知道，<code>fs.readFile()</code>方法是通过返回值的方法来获取文件的读取结果，也就是说，他不返回promise对象，没办法加async/await关键字,后来，nodejs为我们提供了一个<code>promisify</code>方法，可以对现有的异步api进行包装，让方法返回promise对象，以支持异步函数语法</p>
<blockquote>
<p>const promisify = require(‘util’).promisify</p>
</blockquote>
<p>我们开始</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//改造现有异步函数api让其返回promise对象从而支持异步函数语法</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>( <span class="string">'util'</span> ).promisify;</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs. readFile);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">' ./1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(r1)</span><br><span class="line">    <span class="built_in">console</span>.log(r2)</span><br><span class="line">    <span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（三）脚手架、生命周期</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>create-react-app是facebook官方退出的一款react的脚手架，安装前确保电脑有node环境并安装到最新版本</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>npm install -g create-react-app</p>
</blockquote>
<p>等待安装，安装结束执行</p>
<blockquote>
<p>create-react-app –version</p>
</blockquote>
<p>可查看版本<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%89%8B%E6%9E%B6%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>cd到项目文件夹中，执行代码新建一个项目</p>
<blockquote>
<p>create-react-app 项目名</p>
</blockquote>
<p>然后执行npm start启动项目</p>
<blockquote>
<p>npm start</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/start%E6%88%90%E5%8A%9F.png" alt=""></p>
<a id="more"></a>

<h1 id="文件夹目录"><a href="#文件夹目录" class="headerlink" title="文件夹目录"></a>文件夹目录</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%AE%E5%BD%95.png" alt=""></p>
<ul>
<li>public 静态资源文件</li>
<li>src 代码文件</li>
</ul>
<p>我们在src中创建components文件夹来存放自己写的组件</p>
<h1 id="快速使用组件"><a href="#快速使用组件" class="headerlink" title="快速使用组件"></a>快速使用组件</h1><p>现在我们想快速创建一个组件，来到vscode插件市场中，搜索ES7</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/react%E6%8F%92%E4%BB%B6.png" alt=""></p>
<p>下载安装，此时，我们用<code>rcc</code>就可以快速创建一个组件模板<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/rcc.png" alt=""></p>
<p>然后来到<code>App.js</code>文件下，把该删除的都删干净，导入自己写的组件文件</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/app.js.png" alt=""></p>
<p>点击运行，自己写的组件就正常调用了</p>
<h1 id="导入本地图片"><a href="#导入本地图片" class="headerlink" title="导入本地图片"></a>导入本地图片</h1><p>导入本地图片有三种方法</p>
<h2 id="第一种导入图片路径"><a href="#第一种导入图片路径" class="headerlink" title="第一种导入图片路径"></a>第一种导入图片路径</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Img <span class="keyword">from</span> <span class="string">"./images/1.png"</span></span><br><span class="line">&lt;img src=&#123;Img&#125; alt=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="第二种直接获取图片"><a href="#第二种直接获取图片" class="headerlink" title="第二种直接获取图片"></a>第二种直接获取图片</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#123;<span class="built_in">require</span>(<span class="string">"./images/1.png"</span>)&#125; alt=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="如果是背景图的话操作style"><a href="#如果是背景图的话操作style" class="headerlink" title="如果是背景图的话操作style"></a>如果是背景图的话操作style</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">style=&#123;&#123;<span class="attr">background</span>:<span class="string">`url(<span class="subst">$&#123;<span class="built_in">require</span>(<span class="string">"./images/1.png"</span>)&#125;</span>)`</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>${} 为字符串模板,要用反引号``</p>
</blockquote>
<h1 id="脚手架-props与state"><a href="#脚手架-props与state" class="headerlink" title="脚手架 props与state"></a>脚手架 props与state</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>我们先来创建一个 <code>News.js</code>组件当做<code>Home.js</code>组件的子组件</p>
<p>在home组件中引入News.js<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/home%E5%BC%95%E5%85%A5news.png" alt=""></p>
<p>此时，想在home组件给news组件传一个值，那么，<strong>News</strong>组件就要接收这个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//News组件</span></span><br><span class="line">News---&#123;<span class="keyword">this</span>.props.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Home组件</span></span><br><span class="line">&lt;News text = <span class="string">"我是父组件传过来的值"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>和本地模式一样，详见<strong><a href="http://yang_yu_xiang.gitee.io/myblog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/#more" target="_blank" rel="noopener">React学习笔记（二）</a></strong></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>&emsp;&emsp;生命周期即是组件从实例化到渲染到最终从页面中销毁，整个过程就是生命周期，在这生命周期中，我们有许多可以调用的事件，也俗称为<code>钩子函数</code></p>
<p>生命周期的3个状态:</p>
<ul>
<li><code>Mounting</code>:将组件插入到DOM中</li>
<li><code>Updating</code>:将数据更新到DOM中</li>
<li><code>unmounting</code>:将组件移除DOM中</li>
</ul>
<p>生命周期中的钩子函数（方法，事件）</p>
<ul>
<li><code>CompontWillMount</code>:组件将要渲染   ——AJAX，添加动画前的类</li>
<li><code>CompontDidMount</code>:组件渲染完毕    ——添加动画</li>
<li><code>CompontWillReceiveProps</code>:组件将要接受props数据   ——查看接收props的数据什么</li>
<li><code>ShouldComponentupdate</code>:组件接收到新的state或者props   ——判断是否更新。返回布尔值</li>
<li><code>CompontWillupdate</code>:组件将要更新</li>
<li><code>ComponentDidUpdate</code>:组件已经更新</li>
<li><code>Componentwillunmount</code>:组件将要卸载</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（一） React的组件和props</title>
    <url>/MyBlog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>react的组件分为3个部分</p>
<ul>
<li>属性 props</li>
<li>状态state</li>
<li>生命周期</li>
</ul>
<h1 id="组件的创建"><a href="#组件的创建" class="headerlink" title="组件的创建"></a>组件的创建</h1><h2 id="函数组件-无状态组件"><a href="#函数组件-无状态组件" class="headerlink" title="函数组件/无状态组件"></a>函数组件/无状态组件</h2><p>无状态组件的创建方式:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function MyCom()&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="comment">&lt;!-- jsx代码 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个无状态组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-- 组件就是自定义标签 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用组件 --&gt;</span></span><br><span class="line">let com=<span class="tag">&lt;<span class="name">MyCom</span>/&gt;</span></span><br><span class="line">ReactDOM.render(com,document.getElementById("demoReact"));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果想要多次调用的话，就必须加一个父容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">let com=<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父子组件：多个组件在在一个组件里多次调用来进行组合拼装</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function MyCom1( )&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="comment">&lt;!-- jsx代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个无状态组件1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function MyCom2( )&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="comment">&lt;!-- jsx代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个无状态组件2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function MyCom3( )&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="comment">&lt;!-- jsx代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个无状态组件3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">//父组件调用子组件</span><br><span class="line">function Com( )&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom1</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom2</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom3</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(Com,document.getElementById("demoReact"));</span><br></pre></td></tr></table></figure>
<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><p>创建一个类组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class MyCom extends React.Component &#123;</span><br><span class="line">    <span class="comment">&lt;!-- 必须通过一个render方法return一个jsx --&gt;</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>类组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let com=<span class="tag">&lt;<span class="name">MyCom</span>/&gt;</span></span><br><span class="line">ReactDOM.render(com,document.getElementById("demoReact"));</span><br></pre></td></tr></table></figure>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>props是react中一个重要的属性，是组件对外的接口。我们props就可以从组件的外部向组件的内部进行数据的传递。也可以完成父组件给子组件的数据传递</p>
<p><strong>注意:无论是无状态组件还是类组件我们都不能修改自身的props</strong></p>
<h2 id="无状态组件的props使用"><a href="#无状态组件的props使用" class="headerlink" title="无状态组件的props使用"></a>无状态组件的props使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 想使用props，必须在无状态组件的函数的形参中写上props --&gt;</span></span><br><span class="line">function Com(props)&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            我是一 个无状态组件------ 外部传递数据是: &#123;props.text&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM. render(<span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">" 我是传递给Com的props数据"</span>/&gt;</span> ,document.getElementById( "demoReact")); </span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 提升下难度，把text中的数据放在外面 --&gt;</span></span><br><span class="line">function Com(props)&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          我是一 个无状态组件------ 外部传递数据是: &#123;props.text&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let demo="我是数据"</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">&#123;demo&#125;/</span>&gt;</span>,document.getElementById( "demoReact")); </span><br><span class="line"><span class="comment">&lt;!-- 再提升难度，当我们调用多个数据时，把数据放到对象中，再使用扩展运算符来传递属性 --&gt;</span></span><br><span class="line">function Com(props )&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            我是一 个无状态组件------ 外部传递数据是: &#123;props.text&#125;-&#123;props.age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let obj=&#123;</span><br><span class="line">    text:"我是text",</span><br><span class="line">    age:"我是age"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM. render(<span class="tag">&lt;<span class="name">Com</span> <span class="attr">text</span>=<span class="string">&#123;...obj&#125;/</span>&gt;</span> , document.getElementById( "demoReact"));</span><br></pre></td></tr></table></figure>
<h2 id="类组件props使用"><a href="#类组件props使用" class="headerlink" title="类组件props使用"></a>类组件props使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class MyCom extends React.Component &#123;</span><br><span class="line">     <span class="comment">&lt;!-- 必须通过一个render方法return一个jsx --&gt;</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                类组件---&#123;this.props.name&#125;--&#123;this.props.num&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:"i am name",</span><br><span class="line">    num:"i am num"</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">MyCom</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span>,document.getElementById("demoReact"));</span><br></pre></td></tr></table></figure>
<h2 id="无状态组件的props默认值"><a href="#无状态组件的props默认值" class="headerlink" title="无状态组件的props默认值"></a>无状态组件的props默认值</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 1.无状态组件的props验证和 默认值 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 默认值需要defaultProps  --&gt;</span></span><br><span class="line">function Com(props)&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是无状态组件----&#123; props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">Com.defaultProps=&#123;</span><br><span class="line">    name:"我是props中name的默认值"</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Com</span> <span class="attr">name</span>=<span class="string">"我是name的数据"</span>/&gt;</span>，document.getElementById( "demoReact");</span><br><span class="line"> <span class="comment">&lt;!-- 如果没有传值，则显示  我是props中name的默认值</span></span><br><span class="line"><span class="comment"> 否则，像例子中传了值，显示  我是name的数据 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="类组件的props默认值"><a href="#类组件的props默认值" class="headerlink" title="类组件的props默认值"></a>类组件的props默认值</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class MyCom extends React.Component &#123;</span><br><span class="line">     <span class="comment">&lt;!-- 必须通过一个render方法return一个jsx --&gt;</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                类组件---&#123;this.props.name&#125;--&#123;this.props.num&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Com.defaultProps=&#123;</span><br><span class="line">    name:"我是props中name的默认值"</span><br><span class="line">&#125;</span><br><span class="line">let obj=&#123;</span><br><span class="line">    num:"i am num"</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">MyCom</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span>,document.getElementById("demoReact"));</span><br><span class="line"> <span class="comment">&lt;!-- 显示类组件---我是props中name的默认值--i am num --&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><p>之前的数据都是存在组件内部，如果我想要渲染外部传递进来props的数据怎么办？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">let MyCom=(props)=&gt;&#123;</span><br><span class="line">    return(</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            我是子组件 </span><br><span class="line">            &#123;</span><br><span class="line">                props.arr.map((v,i)=&gt;&#123;</span><br><span class="line">                    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let dataArr=["寒冰","盖伦","蛮王"];</span><br><span class="line">let Com=()=&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            我是父组件</span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom</span> <span class="attr">arr</span>=<span class="string">&#123;dataArr&#125;/</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )       </span><br><span class="line">&#125;</span><br><span class="line">ReactDOM. render(<span class="tag">&lt;<span class="name">Com</span> /&gt;</span>,document.getElementById("demoReact"));</span><br></pre></td></tr></table></figure>

<p>还有一种传值方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在子组件MyCom中，用props.children接收--&gt;</span></span><br><span class="line">let dataArr=["寒冰","盖伦","蛮王"];</span><br><span class="line"></span><br><span class="line">let Com=()=&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            我是父组件</span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom</span>&gt;</span>&#123;dataArr&#125;<span class="tag">&lt;/<span class="name">MyCom</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一个修改过的例子：</p>
<p>当我点击页面中的lol英雄展示的时候下面的内容隐藏，点击之后在显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 控制变量用来保存当前的内容显示和隐藏的状态 --&gt;</span></span><br><span class="line">let bool=true; </span><br><span class="line">let MyCom=(props)=&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;display</span> <span class="attr">:</span> <span class="attr">bool</span> ?"<span class="attr">block</span>"<span class="attr">:</span>"<span class="attr">none</span>"&#125;&#125;&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                props.arr.map((v,i)=&gt;&#123;</span><br><span class="line">                return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let dataArr=["寒冰","盖伦" ,"蛮王"];</span><br><span class="line">let Com=()=&gt;&#123;</span><br><span class="line">    return(</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;bool =! bool;console.log(bool);render()&#125;&#125;&gt;</span><br><span class="line">                LOL英雄展示</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MyCom</span> <span class="attr">arr</span>=<span class="string">&#123;dataArr&#125;/</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function render()&#123;</span><br><span class="line">    ReactDOM. render(<span class="tag">&lt;<span class="name">Com</span> /&gt;</span>,document.getElementById(" demoReact" ));</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>

<h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><p>与Vue的$emit不同，在react中，我们通过调用父元素的函数从而操作父元素的数据来实现数据子传父的实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我们用类组件来实现 --&gt;</span></span><br><span class="line">class ParentCom extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            childData:null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子元素传递给父元素的数据：&#123;this.state.childData&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- !!父元素修改state的方法传给子元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ChildCom</span> <span class="attr">setChildData</span>=<span class="string">&#123;this.setChildData&#125;/</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setChildData=(data)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            childData:data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChildCom extends React.Componment&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            msg:"helloworld"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 注意：onClick的C必须大写，切后面必须是事件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.sendData&#125;</span>&gt;</span>传递helloworld给父元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 方法二  通过匿名箭头函数在这里直接调用父元素的方法 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>&#123;this.props.setChildData('直接调用props的函数')&#125;&#125;&gt;传递helloworld给父元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    sendData = ()=&gt;&#123;</span><br><span class="line">        <span class="comment">&lt;!--方法一   在这里调用父元素传进来的方法，传进自己的值，从而修改父元素的值 --&gt;</span></span><br><span class="line">        this.props.setChildData(this.state.msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">ParentCom</span>/&gt;</span>,document.getElementById(" demoReact" ));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（二）组件的状态state、ref转发</title>
    <url>/MyBlog/2020/07/02/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h1><h2 id="state-和props的区别"><a href="#state-和props的区别" class="headerlink" title="state 和props的区别"></a>state 和props的区别</h2><ul>
<li>props是组件对外的接口</li>
<li>state是组件对内的接口</li>
</ul>
<p>&emsp;&emsp;组件内可以引用其他组件，组件之间的引用就形成了一个树状的接口。如果下层组件需要使用上层组件的数据，上层组件就可以通过下层组件中props来进行数据的传递。因此props就是组件对外的接口</p>
<p>&emsp;&emsp;组件除了使用上层组件传递的数据之外，他自身也可能有需要管理的数据。这个对内管理数据的属性就是state</p>
<p>&emsp;&emsp;react中我们只需要关心的是数据。当数据改变的时候页面就会自动的发生改变。状态等同于页面中的数据；状态/数据改变了，页面中对应的数据绑定内容就会被react自动的进行改变</p>
<p>主要区别：</p>
<ul>
<li>state是 可变的</li>
<li>props对于当前页面的组件来说他是只读。如果我们想修改props中的数据那么我们要修改传递给当前组件数据的父组件中的内容</li>
</ul>
<p><strong>如果想使用状态，不能使用无状态组件（函数组件）</strong></p>
<a id="more"></a>
<h2 id="创建state入门代码"><a href="#创建state入门代码" class="headerlink" title="创建state入门代码"></a>创建state入门代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class Com extends React.Component&#123;</span><br><span class="line"><span class="comment">&lt;!-- 在ES6中不管子类写不写constructor 在new实例的时候都会补上constructor --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 我们可以不写但是如果我们写了constructor 之后就必须在其中写上super() 就是指向父类的构造方法 --&gt;</span></span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="comment">&lt;!-- 如果想在consternation使用props那么super中必须写上props --&gt;</span></span><br><span class="line">        super(props )</span><br><span class="line">        <span class="comment">&lt;!-- 定义state --&gt;</span></span><br><span class="line">        this.state=&#123;</span><br><span class="line">            name :"西西"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个组件--- &#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Com</span> /&gt;</span>,documen.getElementById(" demoReact"));</span><br></pre></td></tr></table></figure>
<p>如果我们想要改变state中的数据，就要用到<code>setState</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">       <span class="comment">&lt;!-- this. setState( &#123;key:newValue&#125;)是异步的 当我们触发了setState后，react就会自动的触发render进行数据的渲染 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;this.setState( &#123;name :"哈哈"&#125;&#125;&#125;&gt;点我改变state的数据 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个组件-----&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="state进阶"><a href="#state进阶" class="headerlink" title="state进阶"></a>state进阶</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- this.setState()是异步的 --&gt;</span></span><br><span class="line">class Com extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props) </span><br><span class="line">        this.state=&#123;</span><br><span class="line">            name:"西西",</span><br><span class="line">            newHtml:"<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是state中的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span>"</span><br><span class="line">        &#125;</span><br><span class="line">        fun=()=&gt;&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                name : "haha"</span><br><span class="line">        &#125;,()=&gt;&#123;</span><br><span class="line">        console.log(this.state.name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.fun&#125;</span>&gt;</span>点我修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                &#123;this.state.name&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.newHtml&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!-- //输出&lt;p&gt;我是state中的内容&lt;/p&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &#123;/*字符串标签插入的话 dangerouslySetInnderHTML=&#123;&#123;_HTML:你要插入的字符串&#125;&#125;*/&#125; --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">this.state</span> <span class="attr">.newHtm1</span>&#125;&#125;&gt;</span><span class="tag">&lt;/ <span class="attr">div</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- //输出 我是state中的内容  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>转发refs</p>
<p>&emsp;&emsp;react当中提供了一个ref的数据，表示当前组件的真正实例的引用，他会返回绑定当前属性的元素。他能标识组件内部的元素，方便我们查找</p>
<p>&emsp;&emsp;但是<strong>不能在无状态组件当中进行使用</strong>，因为无状态组件没有实例。</p>
<p>&emsp;&emsp;react给我们3种方式进行ref的使用</p>
<ul>
<li>字符串的方式</li>
<li>回调函数(推荐)</li>
<li>React.createRef() (react16.3新提供的一种方式)</li>
</ul>
<h2 id="字符串方式"><a href="#字符串方式" class="headerlink" title="字符串方式"></a>字符串方式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class Com extends React.Component&#123;</span><br><span class="line">    fun=()=&gt;&#123;</span><br><span class="line">        console.log(this.refs.demoInput.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                我是组件</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">" text"</span> <span class="attr">ref</span>=<span class="string">"demoInput"</span> <span class="attr">placeholder</span>=<span class="string">" 请输入"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.fun&#125;</span>&gt;</span>点我得到输入框的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回调函数方式（推荐）"><a href="#回调函数方式（推荐）" class="headerlink" title="回调函数方式（推荐）"></a>回调函数方式（推荐）</h2><p>就是在dom节点上或者组件上挂载函数，函数的形参是dom结点，他的效果和字符串的方式是一样的，都是获取值的引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class Com extends React.Component&#123;</span><br><span class="line">    fun=()=&gt;&#123;</span><br><span class="line">        console.log(this.textInput.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                我是组件</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">" text"</span> <span class="attr">ref</span>=<span class="string">&#123;(input)</span>=&gt;</span>&#123;this.textInput=input&#125; placeholder=" 请输入"/&gt;</span><br><span class="line">                <span class="comment">&lt;!-- // 这里的input代表当前元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.fun&#125;</span>&gt;</span>点我得到输入框的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef()"></a>React.createRef()</h2><p>把值赋给一个变量，通过ref挂载在节点或者组件上。使用ref的current属性拿到这个节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class Com extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.myRef=React.creatRef()</span><br><span class="line">    &#125;</span><br><span class="line">    fun=()=&gt;&#123;</span><br><span class="line">        console.log(this.myRef.current.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                我是组件</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">" text"</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> <span class="attr">placeholder</span>=<span class="string">" 请输入"</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- // 这里的input代表当前元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.fun&#125;</span>&gt;</span>点我得到输入框的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*<em>官方当中建议我们不要过度的使用refs对逻辑进行处理,需要优先考虑state<br>*</em></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（六）hook、redux</title>
    <url>/MyBlog/2020/07/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h1><p>Hook是react中16.7新增的一个特性，主要是用来让无状态组件可以使用状态。在react开发中状态的管理是必不可少的，以前 为了进行状态管理，需要使用类组件或者redux等来管理</p>
<h2 id="在类组件中使用状态："><a href="#在类组件中使用状态：" class="headerlink" title="在类组件中使用状态："></a>在类组件中使用状态：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class App extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state=&#123;</span><br><span class="line">        text:"我是状态数据"</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                hello----&#123;this.state.text&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="在无状态组件中使用状态-useState-："><a href="#在无状态组件中使用状态-useState-：" class="headerlink" title="在无状态组件中使用状态(useState)："></a>在无状态组件中使用状态(useState)：</h2><p>可以使用react Hook 中的<code>useState</code>来进行实现</p>
<ul>
<li><code>useState</code>是来定义一个状态的，他与类组件的状态不同，函数组件的状态可以是对象也可以是基础类型数据。</li>
<li><code>useState</code>返回的是一个<strong>数组</strong>。第一个参数是<strong>当前的状态值</strong>。第二个参数是对象，表明<strong>用于更改状态的函数</strong>(类似于setstate )</li>
</ul>
<p>1、先来导包</p>
<blockquote>
<p>import {useState} from ‘react’</p>
</blockquote>
<p>2、具体用法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function App(props) &#123;</span><br><span class="line">    <span class="comment">&lt;!-- 解构赋值到val，setVal上 --&gt;</span></span><br><span class="line">    let [val, setVal] = useState(0)</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>= <span class="string">"App"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            使用数据:&#123;val&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、如果有多个状态怎么办？</p>
<ul>
<li>1.声明对象类型的状态</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function App(props) &#123;</span><br><span class="line">    let [val, setVal] = useState(&#123;</span><br><span class="line">        vala:1,</span><br><span class="line">        valb:2,</span><br><span class="line">        valc:3</span><br><span class="line">    &#125;)</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>= <span class="string">"App"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            使用数据:&#123;val.vala&#125;---&#123;val.valb&#125;---&#123;val.valc&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            // 至于修改，要用其他方式</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.多次声明</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function App(props) &#123;</span><br><span class="line">    let [vala, setVala] = useState(0)</span><br><span class="line">    let [valb, setValb] = useState(1)</span><br><span class="line">    let [valc, setValc] = useState(2)</span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>= <span class="string">"App"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            使用数据:&#123;val.vala&#125;---&#123;val.valb&#125;---&#123;val.valc&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setVal(val+1)&#125;&#125;&gt;点我进行数据的修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 至于修改，要用其他方式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>&emsp;&emsp;在用<code>Class</code>制作组件时，经常会用生命周期函数，来处理一些额外的事情。在<code>React Hooks</code>中也需要这样类似的生命周期函数，比如在每次状态<code>（State）</code>更新时执行，它为我们准备了<code>useEffect</code>。</p>
<p>&emsp;&emsp;为了更好的理解<code>useEffect</code>的使用，先用原始的方式把计数器的Demo增加两个生命周期函数<code>componentDidMount</code>和<code>componentDidUpdate</code>。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from 'react';</span><br><span class="line"></span><br><span class="line">class Example3 extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123; count:0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        console.log(`ComponentDidMount=&gt;You clicked $&#123;this.state.count&#125; times`)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        console.log(`componentDidUpdate=&gt;You clicked $&#123;this.state.count&#125; times`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; </span><br><span class="line">        return (</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.addCount.bind(this)&#125;</span>&gt;</span>Chlick me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    addCount()&#123;</span><br><span class="line">        this.setState(&#123;count:this.state.count+1&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example3;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在使用<code>React Hooks</code>的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入<code>useEffect</code>后，才可以正常使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState , useEffect &#125; from 'react';</span><br><span class="line">function Example()&#123;</span><br><span class="line">    const [ count , setCount ] = useState(0);</span><br><span class="line">    <span class="comment">&lt;!-- ---关键代码---------start------- --&gt;</span></span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        console.log(`useEffect=&gt;You clicked $&#123;count&#125; times`)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">&lt;!-- ---关键代码---------end------- --&gt;</span></span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，当组件创建的时候执行一次<code>useEffect</code>，组件更新时也会执行<code>useEffect</code>,相当于生命周期函数<code>componentDidMount</code>和<code>componentDidUpdate</code>。但是我们如果想用<code>componentWillUnmount</code>(组件销毁)的什么周期函数，要怎么做呢？</p>
<h3 id="useEffect中实现componentWillUnmount"><a href="#useEffect中实现componentWillUnmount" class="headerlink" title="useEffect中实现componentWillUnmount"></a>useEffect中实现componentWillUnmount</h3><p>&emsp;&emsp;我们在<code>useEffect</code>中<code>return</code>一个方法，就能实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function Index() &#123;</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        console.log('useEffect=&gt;老弟你来了！Index页面')</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            console.log('老弟，你走了!Index页面')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是Index<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  &emsp;&emsp;这时候你在浏览器中预览，我们仿佛实现了<code>componentWillUnmount</code>方法。但这只是好像实现了，当点击计数器按钮时，你会<code>发现老弟，你走了!Index页面</code>，也出现了。这到底是怎么回事那？其实每次状态发生变化，<code>useEffect</code>都进行了解绑。</p>
<p>  &emsp;&emsp;这就需要请出<code>useEffect</code>的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组<code>[]</code>时，就是当组件将被销毁时才进行解绑，这也就实现了<code>componentWillUnmount</code>的生命周期函数。<br>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  function Index() &#123;</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        console.log('useEffect=&gt;老弟你来了！Index页面')</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            console.log('老弟，你走了!Index页面')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[]) <span class="comment">&lt;!-- 数组里如果是count，每次count发生变化，才会输出 return的函数中的内容  --&gt;</span></span><br><span class="line">    return <span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="useEffect中进行ajax请求"><a href="#useEffect中进行ajax请求" class="headerlink" title="useEffect中进行ajax请求"></a>useEffect中进行ajax请求</h3><p>&emsp;&emsp;我们在<code>useEffect</code>这个effect hook中，通过axios从API中获取数据,并使用state hook的更新函数,将数据存入到本地state中。并且使用async/await来解析promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">'http://hn.algolia.com/api/v1/search?query=redux'</span>,</span><br><span class="line">    ); </span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//   当你运行上面的代码的时候，你会陷入到死循环中。effect hook 在组件 mount 和 update 的时候都会执行。</span></span><br><span class="line"><span class="comment">//   因为我们每次获取数据后，都会更新 state，所以组件会更新，并再次运行 effect，这会一次又一次的请求数据。</span></span><br><span class="line"><span class="comment">//   很明显我们需要避免这样的bug产生，我们只想在组件 mount 的时候请求数据。你可以在 effect hook 提供的第二个参数中， 传入一个空数组</span></span><br><span class="line"><span class="comment">//   这样做可以避免组件更新的时候执行 effect hook ，但是组件在 mount 依然会执行它。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (&#123;</span><br><span class="line">        data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;item.title&#125;))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>&emsp;&emsp;有了<code>useState</code>和<code>useEffect</code>已经可以实现大部分的业务逻辑了，但是<code>React Hooks</code>中还是有很多好用的<code>Hooks</code>函数的，比如<code>useContext</code>和<code>useReducer</code>。</p>
<p>&emsp;&emsp;现在使用方法(Function)来声明组件，已经没有了<code>constructor</code>构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。<code>React Hooks</code> 为我们准备了<code>useContext</code>来进行父子组件的传值</p>
<p>&emsp;&emsp;来看代码：<code>Example.js</code>中引入<code>createContext</code>函数，并使用得到一个组件，然后在<code>return</code>方法中进行使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState , createContext &#125; from 'react';</span><br><span class="line"> <span class="comment">&lt;!-- ========关键代码(创建一个CountCountext对象)========= --&gt;</span></span><br><span class="line">const CountContext = createContext()</span><br><span class="line"></span><br><span class="line">function Example()&#123;</span><br><span class="line">    const [ count , setCount ] = useState(0);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- =============关键代码(把count暴露出去)============== --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用<code>useContext</code>就可以，但是在使用前需要新进行引入<code>useContext</code>（不引入是没办法使用的）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState , createContext , useContext &#125; from 'react';</span><br><span class="line"></span><br><span class="line">function Counter()&#123;</span><br><span class="line">    const count = useContext(CountContext) <span class="comment">&lt;!--一句话就可以得到count --&gt;</span></span><br><span class="line">    return (<span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到后就可以显示出来了，但是要记得在<code>&lt;CountContext.Provider&gt;</code>的闭合标签中,代码如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>&emsp;&emsp;为了更好的理解<code>useReducer</code>，所以先要了解JavaScript里的<code>Redcuer</code>是什么。它的兴起是从<code>Redux</code>广泛使用开始的，但不仅仅存在<code>Redux</code>中。reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;了解<code>reducer</code>的含义后，就可以讲<code>useReducer</code>了，它也是<code>React hooks</code>提供的函数，可以增强我们的<code>Reducer</code>，实现类似<code>Redux</code>的功能。我们新建一个<code>Example.js</code>的文件，然后用<code>useReducer</code>实现计数器的加减双向操作</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from 'react';</span><br><span class="line"></span><br><span class="line">function ReducerDemo()&#123;</span><br><span class="line">    const [ count , dispatch ] =useReducer((state,action)=&gt;&#123;</span><br><span class="line">        switch(action)&#123;</span><br><span class="line">            case 'add':</span><br><span class="line">                return state+1</span><br><span class="line">            case 'sub':</span><br><span class="line">                return state-1</span><br><span class="line">            default:</span><br><span class="line">                return state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,0)<span class="comment">&lt;!--0为count默认值--&gt;</span></span><br><span class="line">    return (</span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span>现在的分数是&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>dispatch('add')&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>dispatch('sub')&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ReducerDemo</span><br></pre></td></tr></table></figure>









<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>&emsp;&emsp;<code>redux</code> 是javascript提供的一个可预测性<code>(我们给个固定的输入 那么必定可以等到一个结果)</code>的状态容器。<code>redux</code>是个专门的状态管理库，并不是react独有的。在vue等当中也可以使用 但是在react中会比较多。</p>
<p>&emsp;&emsp;<code>redux</code>的作用就是集中的管理react中多个组件的状态</p>
<h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><ul>
<li>某个组件的状态需要共享的时候</li>
<li>个组件需要改变另外一个组件状态的时候</li>
<li>组件中的状态需要在任何地方都可以拿到<h2 id="几个核心概念"><a href="#几个核心概念" class="headerlink" title="几个核心概念"></a>几个核心概念</h2></li>
</ul>
<p><strong>1.Store</strong><br>&emsp;&emsp;整个react中的状态都会被统一的管理到<code>store</code></p>
<p><strong>2.State</strong><br>&emsp;&emsp;<code>state</code>是一个对象，数据仓库里的所有数据都放到一个<code>state</code>里。我们不能够直接改变<code>state</code>而是要通过触发<code>redux</code>中的特定方法来进行修改</p>
<p><strong>3.Action</strong><br>&emsp;&emsp;<code>action</code>是一个动作，我们要用<code>action</code>来改变redux中的<code>state</code><br><strong>4.Dispatch</strong><br>&emsp;&emsp;<code>Dispatch</code>将动作触发成方法</p>
<p><strong>5.Reducer</strong><br>&emsp;&emsp;<code>Reducer</code>是一个函数，通过获取动作，改变数据，生成一个新的<code>state</code></p>
<h2 id="redux的使用"><a href="#redux的使用" class="headerlink" title="redux的使用"></a>redux的使用</h2><p>1、下载</p>
<blockquote>
<p>npm install –save redux</p>
</blockquote>
<p>2、首先在src下新建一个<code>redux</code>目录，在该目录下创建一个<code>reducer.js</code>文件</p>
<p>&emsp;&emsp;<code>reduce</code>有两个作用，第一个是<code>初始化数据</code>，第二个是通过<code>获取动作改变数据</code>。它有点像一个指挥中心，根据传进来的类型分配任务。它负责接收组件传递的<code>action</code>，根据<code>action</code>的类型来进行数据的修改，函数接收两个参数，第一个<code>state</code>,为store存储的状态，可以给它赋初始值，第二个为<code>action</code>（动作）,action是一个对象，可以传递type和其他的值进去</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/reducer.png" alt=""></p>
<p>3、在redux文件夹下新建一个<code>store.js</code>文件，导入刚刚的<code>reducer.js</code>文件。</p>
<p>&emsp;&emsp;<code>store.js</code>接收<code>reducer.js</code>的导出为参数并使用redux提供的<code>createStore()</code>方法创建一个数据源<code>store</code>，在<code>store.js</code>中写代码：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/store.png" alt=""></p>
<p>4、在components文件夹下的<code>Home.js</code>组件中使用store中的值<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/store%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt=""></p>
<p><strong>修改操作</strong><br>1、所有的修改操作都要调用一个action，所以，我们在redux文件夹下新建一个文件<code>action.js</code></p>
<p>2、设置操作</p>
<p>在<code>action.js</code>中定义两个如下操作</p>
<p>&emsp;&emsp;<code>action.js</code>中定义一些方法用于Home组件的动作分发(<code>dispatch()</code>)，这里的<code>type</code>其实就是对应<code>reducer.js</code>的<code>action.type</code><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/action.js.png" alt=""></p>
<p>3、回到reducer.js文件添加对action的判断<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%BF%AE%E6%94%B9reducer.js.png" alt=""></p>
<p>4、在组件中调用dispatch()更新方法来进行data数据的修改<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/action%E8%B0%83%E7%94%A8%E6%88%90%E5%8A%9F.png" alt=""><br>dispatch作用：发送用户请求并去更新state</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（五）React router dom路由基础</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>根据url的不同来切换对应的组件实现spa(单页面应用)在页面切换的时候不会刷新，更加接近原生体验</p>
<h2 id="路由的下载"><a href="#路由的下载" class="headerlink" title="路由的下载"></a>路由的下载</h2><p>下载</p>
<blockquote>
<p>npm install –save react-router-dom</p>
</blockquote>
<ul>
<li>router-router    只提供了一些核心的API</li>
<li>router-router-dom    提供更多的一些选项</li>
</ul>
<p>路由模式:</p>
<ul>
<li>hash HashRouter (hash模式带#号，刷新的时候页面不会丢失)</li>
<li>browser BrowserRouter 历史记录模式，没有#号，他是通过历史记录api来进行路由切换的。刷新会丢失，本地模式不会<a id="more"></a>

</li>
</ul>
<h2 id="引用路由"><a href="#引用路由" class="headerlink" title="引用路由"></a>引用路由</h2><p>在index.js中导入包</p>
<blockquote>
<p>import {BrowserRouter} from ‘react-router-dom’</p>
</blockquote>
<p>路由模式包裹根组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//在index.js中</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span>,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在App.js中导入包</p>
<blockquote>
<p>import {Route,Link} from ‘react-router-dom’<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/routerLink.png" alt=""></p>
</blockquote>
<p>除了Link的方法，还有一个<code>NavLink</code>，可以动态设置类名，当路由被激活时，被激活的路由会被添加一个<code>class=&quot;active&quot;</code>的类名</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在导入的包中加上Redirect</p>
<blockquote>
<p>import {Route,Link,Redirect} from ‘react-router-dom’</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">"/"</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">exact</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于Route的exact,加上exact代表当前路由path的路径采用精确匹配，比如说Home的path如果不加上exact,那么path=”/home”将会匹配他自己与path=”/“这两个，所以一般path=”/“这个路由一般会加上exact</p>
<h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p>Link组件用于取代<code>&lt;a&gt;</code>元素，生成一个<code>链接</code>，允许用户<code>点击后跳转到另一个路由</code>。它基本上就是<code>&lt;a&gt;</code>元素的React 版本，可以接收Router的状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/repos"</span>&gt;</span>Repos<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>to后面不止可以放路径，。还可以放一个对象，对象里可以定义各种属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    let meobj = (</span><br><span class="line">        <span class="comment">&lt;!-- 跳转的路径 --&gt;</span></span><br><span class="line">        pathname : "/me",</span><br><span class="line">        <span class="comment">&lt;!-- get请求参数 --&gt;</span></span><br><span class="line">        search: " ?username=admin",</span><br><span class="line">        <span class="comment">&lt;!-- 设置的HASH值 --&gt;</span></span><br><span class="line">        hash: "#abc",</span><br><span class="line">        <span class="comment">&lt;!-- 传入组件的数据 --&gt;</span></span><br><span class="line">        state:&#123;msg:'hell.oworld'&#125;;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    return(</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;meobj&#125;</span>&gt;</span>meObj<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的<code>activeStyle</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>'&#125;&#125;&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/repos"</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>'&#125;&#125;&gt;</span>Repos<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，当前页面的链接会红色显示。</p>
<p>另一种做法是，使用<code>activeClassName</code>指定当前路由的<code>Class</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">activeClassName</span>=<span class="string">"active"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/repos"</span> <span class="attr">activeClassName</span>=<span class="string">"active"</span>&gt;</span>Repos<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，当前页面的链接的<code>class</code>会包含<code>active</code>。</p>
<h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><p>除了用link来进行路由跳转，我们还可以用编程式导航的方式进行路由跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">class ChildCom extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#123;this.clickEvent&#125;</span>&gt;</span>跳转到首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    clickEvent=()=&gt;&#123;</span><br><span class="line">        <span class="comment">&lt;!-- console.log(this.props) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- msg可不写，就写个路径 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正常跳转 --&gt;</span></span><br><span class="line">        this.props.history.push("/",&#123;msg:"这是由childcom组件发给父组件的信息"&#125;)</span><br><span class="line">        <span class="comment">&lt;!-- 重定向 --&gt;</span></span><br><span class="line">        this.props.history.replace("/",&#123;msg:"这是由childcom组件发给父组件的信息"&#125;)</span><br><span class="line">        <span class="comment">&lt;!-- 前进 --&gt;</span></span><br><span class="line">        this.props.history.go(1)</span><br><span class="line">        this.props.history.goForward(1)</span><br><span class="line">        <span class="comment">&lt;!-- 后退 --&gt;</span></span><br><span class="line">        this.props.history.go(-1)</span><br><span class="line">        this.props.history.goBack(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，路由跳转的时候传递了一个msg，我们可以通过<code>props.location.state.msg</code>获取到这个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>msg-&#123;props.location.state.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><p><code>Link</code>组件用于正常的用户点击跳转，但是有时还需要<code>表单跳转</code>、<code>点击按钮跳转</code>等操作。这些情况怎么跟React Router对接呢？</p>
<p>下面是一个表单。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"userName"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"repo"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一种方法是使用<code>browserHistory.push</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> userName = event.target.elements[<span class="number">0</span>].value</span><br><span class="line">    <span class="keyword">const</span> repo = event.target.elements[<span class="number">1</span>].value</span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`/repos/<span class="subst">$&#123;userName&#125;</span>/<span class="subst">$&#123;repo&#125;</span>`</span></span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>第二种方法是使用<code>context</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for `router` from context</span></span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="高阶组件withRouter"><a href="#高阶组件withRouter" class="headerlink" title="高阶组件withRouter"></a>高阶组件withRouter</h1><p>&emsp;&emsp;参数是一个组件，同时返回的也是一个组件。这类组件我们成为高阶组件(HOC)</p>
<p>&emsp;&emsp;withRouter作用：让不是路由切换的组件将react-router 的 history、location、match 三个对象传入props对象上</p>
<p>&emsp;&emsp;默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面</p>
<p>&emsp;&emsp;然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>&emsp;&emsp;比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法调用props中的<code>history</code>、<code>location</code>、<code>match</code>等属性。</p>
<p>设置withRouter很简单只需要两步：</p>
<ul>
<li>1.引入 </li>
<li>2.将App组件 withRouter() 一下</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from 'react'</span><br><span class="line">import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouter</span><br><span class="line">import One from './One'</span><br><span class="line">import NotFound from './NotFound'</span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    //此时才能获取this.props,包含（history, match, location）三个对象</span><br><span class="line">    console.log(this.props);  //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">'/one/users'</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">'/one/companies'</span>&gt;</span>公司列表<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">'/one/:type?'</span> <span class="attr">component</span>=<span class="string">&#123;One&#125;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">'/'</span> <span class="attr">to</span>=<span class="string">'/one'</span> <span class="attr">exact</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(App);  //这里要执行一下WithRouter</span><br></pre></td></tr></table></figure>
<h2 id="介绍一个简单应用"><a href="#介绍一个简单应用" class="headerlink" title="介绍一个简单应用"></a>介绍一个简单应用</h2><p>可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。</p>
<p>仍然是App.js组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Switch,Route,NavLink,Redirect,withRouter&#125; <span class="keyword">from</span>  <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> One <span class="keyword">from</span> <span class="string">'./One'</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">'./NotFound'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">                <span class="keyword">super</span>(props);</span><br><span class="line">                props.history.listen(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123;  <span class="comment">//在这里监听location对象</span></span><br><span class="line">                        <span class="built_in">console</span>.log(location.pathname);  <span class="comment">//切换路由的时候输出"/one/users"和"/one/companies"</span></span><br><span class="line">                        <span class="keyword">switch</span>(location.pathname)&#123;   <span class="comment">//根据路径不同切换不同的浏览器title</span></span><br><span class="line">                                <span class="keyword">case</span> <span class="string">'/one/users'</span> : <span class="built_in">document</span>.title = <span class="string">'用户列表'</span>; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">'/one/companies'</span> : <span class="built_in">document</span>.title = <span class="string">'公司列表'</span>; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="string">`&lt;div className='app'&gt;</span></span><br><span class="line"><span class="string">                        &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">                        &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">                        &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                                &lt;Route path='/one/:type?'  component=&#123;One&#125; /&gt;</span></span><br><span class="line"><span class="string">                                &lt;Redirect from='/' to='/one' exact /&gt;</span></span><br><span class="line"><span class="string">                                &lt;Route component=&#123;NotFound&#125; /&gt;</span></span><br><span class="line"><span class="string">                        &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span></span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(App);</span><br></pre></td></tr></table></figure>
<p>同时，我们可以进行编程式导航：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/home")&#125;&#125;&gt;点我去home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/phone")&#125;&#125;&gt;点我去phone<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user")&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h1><h2 id="params方式进行传参"><a href="#params方式进行传参" class="headerlink" title="params方式进行传参"></a>params方式进行传参</h2><ul>
<li>1.需要在路由规则中设置传递的接受参数   :xxx</li>
<li>2.发送参数,直接在跳转路径后进行编写</li>
<li>3.接受:props.match.params.参数名/this.props.params.参数名</li>
</ul>
<p><strong>优势:刷新地址,参数依然存在</strong></p>
<p><strong>缺点:只能传递字符中,并且参数过多的时候url会变得比较丑陋</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路由表中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">'/user/:id'</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js传递方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user"+"2")&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML传递方式 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>'/<span class="attr">user</span>/'+'<span class="attr">2</span>'&#125; <span class="attr">activeClassName</span>=<span class="string">'active'</span>&gt;</span>点我去user<span class="tag">&lt;/<span class="name">Link</span>&gt;</span>         </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子路由componentDidMount中接受 --&gt;</span></span><br><span class="line">let id = this.props.params.id</span><br></pre></td></tr></table></figure>
<h2 id="query方式进行传参"><a href="#query方式进行传参" class="headerlink" title="query方式进行传参"></a>query方式进行传参</h2><ul>
<li>1.不需要再路由规则中进行传递参数的配置</li>
<li>2.直接发送数据</li>
<li>3.使用 this.props.location.query.xxx</li>
<li>4.必须由其他页面跳过来，参数才会被传递过来 </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JS传递方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/phone",query:&#123;name:"小明"&#125;)&#125;&#125;&gt;点我去phone<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;props.history.push("/user",query:&#123;name:"小刚"&#125;)&#125;&#125;&gt;点我去user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML传递方式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;pathname:</span>'/<span class="attr">user</span>',<span class="attr">query:</span>&#123; <span class="attr">day:</span>'<span class="attr">Friday</span>'&#125;&#125;&#125;&gt;</span> <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子路由componentDidMount中接受 --&gt;</span></span><br><span class="line">let name = this.props.location.query.参数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记（四）json-server与axios、跨域请求</title>
    <url>/MyBlog/2020/07/03/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server可以开启一个端口模拟服务端的数据</p>
<h2 id="安装json-server"><a href="#安装json-server" class="headerlink" title="安装json-server"></a>安装json-server</h2><blockquote>
<p>npm install json-server -g</p>
</blockquote>
<p>安装完成后，我们来创建一个data.json文件放在mock文件夹中<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/datejson.png" alt=""></p>
<a id="more"></a>
<p>cd到mock文件夹下，启动json-server</p>
<blockquote>
<p>json-server json数据名字 –port 5000</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/datajson%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt=""><br>启动成功，我们进到浏览器或者用postman测试接口<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%B5%8B%E8%AF%95jsonserver.png" alt=""></p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>安装</p>
<blockquote>
<p>npm install –save axios</p>
</blockquote>
<p>引入axios</p>
<blockquote>
<p>import axios from ‘axios’</p>
</blockquote>
<p>在钩子函数componentDidMount()中使用axios</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/axios%E5%AF%BC%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8.png" alt=""><br>请求成功！<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/axios%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F.png" alt=""></p>
<h1 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h1><ul>
<li>1、正向代理–开发环境</li>
</ul>
<p>&emsp;&emsp;一个位于客户端和目标服务器之间的代理服务器。为了获取到目标服务器的内容，客户端向代理服务器发送一个请求，代理服务器帮助我们去目标服务器里面获取数据且并返回给我们</p>
<ul>
<li>2、反向代理–上线环境</li>
</ul>
<p>&emsp;&emsp;可以通过代理服务器来接受网络上的请求连接，然后将这个请求转发给内部的网络服务器上并且把这个服务器上得到的数据返回给网络请求的客户端。这个时候代理服务器对外的表现就是一个反向代理</p>
<p>模拟请求真实的网络接口:中国天气网中的数据<br>找到文件项目\node modules\react-scripts\config\webpackDevServer.config.js</p>
<p>找到proxy进行修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy:&#123;</span><br><span class="line">    <span class="string">"/api"</span>:&#123;</span><br><span class="line">    target:<span class="string">"http://www.weather.com.cn/data/cityinfo"</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span> ,</span><br><span class="line">    <span class="string">"pathRewrite"</span>:&#123;</span><br><span class="line">    <span class="string">"^/api"</span>:<span class="string">"/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在需要的axios请求中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">"/api/161320101.html"</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/MyBlog/2020/08/15/Vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>官方解释:<code>Vuex是一个专为Vuejs应用程序开发的状态管理模式。</code></p>
<p>它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p><strong>状态管理到底是什么?</strong></p>
<ul>
<li>状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。</li>
<li>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</li>
<li>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</li>
<li>那么，多个组件就可以共享这个对象中的所有变量属性了</li>
</ul>
<p><strong>等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢?难道我们不能自己封装一个对象来管理吗?</strong><br>比如说我们定义一个shareObj对象，挂载到Vue的原型上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shareObj = &#123;</span><br><span class="line">    name:<span class="string">'yang'</span></span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.shareObj = shareObj</span><br></pre></td></tr></table></figure>
<p>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢?没错，就是响应式。如果这么做了，我们更新<code>shareObj</code>中的值，<strong>没办法触发</strong>页面中的值刷新。因为他没被加到Vue的响应式系统里，而data中的数据被加载到了响应式系统里，所以能触发刷新。</p>
<h2 id="管理什么状态"><a href="#管理什么状态" class="headerlink" title="管理什么状态"></a>管理什么状态</h2><p>有什么状态时需要我们在多个组件间共享的呢?<br>&emsp;&emsp;如果你做过大型开发，你一定遇到过多个状态，在多个界面间的共享问题。比如<strong>用户的登录状态、用户名称、头像、地理位置信息</strong>等等。比如<strong>商品的收藏、购物车中的物品</strong>等等。<br>&emsp;&emsp;这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>npm vuex –save</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装完成后，我们在<code>src</code>目录下新建<code>store</code>文件夹，下面放个<code>index.js</code>存放Vuex</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">vue.use(vuex)</span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">//存放状态</span></span><br><span class="line">    state:&#123;</span><br><span class="line">        counter: <span class="number">0</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//修改状态的方法</span></span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    <span class="comment">//异步方法</span></span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    getters:&#123;&#125;,</span><br><span class="line">    <span class="comment">//模块</span></span><br><span class="line">    modules:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.导出store独享</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js引入</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="comment">//在vue实例中加入store  这样就可以在全局使用$store使用vuex</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>创建完后，我们就可以在所有组件中使用共享的状态了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候，我们想修改<code>counter</code>中的值，有啥办法，可能会想到这种办法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.counter++"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方法也可以改变<code>counter</code>的值，但是<strong>不推荐！</strong>  来看一张官方的图</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/vuex.png" alt=""></p>
<p><strong>我们应该通过Mutation来修改state</strong></p>
<p>&emsp;&emsp;Vue官方为我们提供了一个<code>Devtools</code>插件，在多个页面对Vuex进行修改时，我们能知道到底是哪个界面修改了vuex的东西，这样维护起来的时候比较方便<br>&emsp;&emsp;如果我们像上面的例子一样绕过了<code>Mutations</code>，直接对<code>state</code>进行修改，我们就是不知道到底哪个界面修改了<code>state</code></p>
<p>当然，我们在修改的时候也可以跳过<code>Action</code><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/vuex%E8%B7%B3%E8%BF%87action.png" alt=""></p>
<p>&emsp;&emsp;<code>Action</code>的作用是当你在修改<code>Mutation</code>时，如果有异步操作(发送网络请求)，放在<code>Action</code>中进行。<code>Devtools</code>无法跟踪异步操作，所以把异步放在<code>Action</code>中执行完了发给<code>Mutation</code>，让<code>Devtools</code>可以跟踪，让调试更加方便</p>
<h1 id="Mutatuons使用"><a href="#Mutatuons使用" class="headerlink" title="Mutatuons使用"></a>Mutatuons使用</h1><p>Vuex的store状态的<strong>更新唯一方式:提交Mutation</strong></p>
<p>下面我们来通过mutation修改state,首先在Mutation中添加方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在store/index.js中</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        counter: <span class="number">0</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        <span class="comment">//state为默认参数</span></span><br><span class="line">        increament(state)&#123;</span><br><span class="line">            state.counter++</span><br><span class="line">        &#125;,</span><br><span class="line">        decreament(state)&#123;</span><br><span class="line">            state.counter--</span><br><span class="line">        &#125;,</span><br><span class="line">        increamentCount(state,count)&#123;</span><br><span class="line">            state.counter +=count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters:&#123;&#125;,</span><br><span class="line">    modules:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在使用到vuex的组件中，先定义事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addition"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"subtraction"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 带参传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCount(5)"</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCount(10)"</span>&gt;</span>+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义事件处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    addition()&#123;</span><br><span class="line">        <span class="comment">//commit提交对应mutations</span></span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decreament()&#123;</span><br><span class="line">        <span class="comment">//提交对应mutations</span></span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'decreament'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//带参传递，参数可以是对象 这里的参数有个专业名称：mutation的payload(负荷，负载)</span></span><br><span class="line">    addCount(count)&#123;</span><br><span class="line">        <span class="comment">//提交对应mutations</span></span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'increamentCount'</span>,count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Action的使用"><a href="#Action的使用" class="headerlink" title="Action的使用"></a>Action的使用</h1><p>&emsp;&emsp;通常情况下,Vuex要求我们<code>Mutation</code>中的方法必须是同步方法。</p>
<p>&emsp;&emsp;主要的原因是当我们使用<code>devtools</code>时,<code>devtools</code>可以帮助我们捕捉<code>mutation</code>的快照。但是如果是异步操作,那么<code>devtools</code>将不能很好的追踪这个操作什么时候会被完成。<br>&emsp;&emsp;但是某些情况,我们确实希望在Vuex中进行一些异步操作,比如网络请求,必然是异步的.这个时候怎么处理呢?这时候，我们就要用到<code>Action</code><br>&emsp;&emsp;<code>Action</code>类似于<code>Mutation</code>,但是是用来代替<code>Mutation</code>进行异步操作的。</p>
<p>Action的基本使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在store/index.js中</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        info:&#123;</span><br><span class="line">            name:<span class="string">'yang'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        UpdateInfo(state)&#123;</span><br><span class="line">            state.info.name = <span class="string">'xiang'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    actions:&#123;</span><br><span class="line">        <span class="comment">//mutations和getter默认参数为state,而actions为context</span></span><br><span class="line">        <span class="comment">//context为上下文</span></span><br><span class="line">        actionUpdateName(context,payload)&#123;<span class="comment">//payload只有带参传递过来的函数才需要写</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                context.commit(UpdateInfo)</span><br><span class="line">                <span class="built_in">console</span>.log(payload)</span><br><span class="line">            &#125;,<span class="number">1000</span>)          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;&#125;,</span><br><span class="line">    modules:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在使用到vuex的组件中，先定义事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"UpdateName"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 带参传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCount()"</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义事件处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">//  1  不带参数传递</span></span><br><span class="line">    UpdateName()&#123;</span><br><span class="line">        <span class="comment">//dispatch提交对应actions</span></span><br><span class="line">        <span class="keyword">this</span>.$store.dispatch(<span class="string">'actionUpdateName'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//  2  带参传递，参数可以是对象payload(负荷，负载)</span></span><br><span class="line">    UpdateName()&#123;</span><br><span class="line">        <span class="comment">//提交对应mutations</span></span><br><span class="line">        <span class="keyword">this</span>.$store.dispatch(<span class="string">'increamentCount'</span>,<span class="string">'hahah'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Getters使用"><a href="#Getters使用" class="headerlink" title="Getters使用"></a>Getters使用</h1><p>&emsp;&emsp;在使用<code>state</code>数据的时候，如果很经常要用到<code>state</code>数据的变形，如我现在经常要用到<code>counter</code>的平方，正常情况下我可以这么写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter * $store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是这样太麻烦，我们可以定义<code>getters</code>。另一种方法是定义一个computed计算属性，这里不讲</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store/index.js中</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        counter: <span class="number">110</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        <span class="comment">//state为默认参数</span></span><br><span class="line">        powerCounter(state)&#123;</span><br><span class="line">            <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以这样用getters:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.powerCounte&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>getters是默认不能传递参数的，如果想传递参数，可以return一个function</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&lt;h2&gt;&#123;&#123;$store.getters.Count(2)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">getters:&#123;</span><br><span class="line">    Count(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state.counter*num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Modules的使用"><a href="#Modules的使用" class="headerlink" title="Modules的使用"></a>Modules的使用</h1><p>&emsp;&emsp;Module是模块的意思，为什么在Vuex中我们要使用模块呢?</p>
<p>&emsp;&emsp;Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理。当应用变得非常复杂时,store对象就有可能变得相当臃肿<br>&emsp;&emsp;为了解决这个问题,Vuex允许我们将store分割成模块(Module)，而每个模块拥有自己的state、mutation、action、getters等</p>
<p>我们按以下形式组织代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ...&#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ...&#125;,</span><br><span class="line">    actions: &#123; ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a <span class="comment">// -&gt;moduleA的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h1 id="Vuex-store文件夹的目录结构组织"><a href="#Vuex-store文件夹的目录结构组织" class="headerlink" title="Vuex-store文件夹的目录结构组织"></a>Vuex-store文件夹的目录结构组织</h1><p>全部内容都写在index.js里面太乱了，我们可以分开几个文件，比如我们把mutations抽离出去，在store文件夹下新建一个mutations.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutations.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//mutations中的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在index.js中引入</span></span><br><span class="line"><span class="comment">///index.js</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="数据的响应式原理"><a href="#数据的响应式原理" class="headerlink" title="数据的响应式原理"></a>数据的响应式原理</h1><p>&emsp;&emsp;Vuex的store中的state是响应式的，当state中的数据发生改变时, Vue组件会自动更新</p>
<p>这就要求我们必须遵守一些Vuex对应的规则:</p>
<ul>
<li>提前在store中初始化好所需的属性.</li>
<li>当给state中的对象添加新属性时，使用下面的方式:<br>》方式一:使用Vue.set(obj, ‘newProp’,123)<br>》方式二:用心对象给旧对象重新赋值</li>
</ul>
<p>&emsp;&emsp;我们在数据中预先定义好的的每一个属性都会被加入到响应式系统中，并对应着一个Dep这样的对象，这是一个观察者模式，可以监听数据有没有变化，一旦数据变化，他会去寻找哪些地方需要用到这个属性去刷新界面，然后通知这些地方做出改变</p>
<p>&emsp;&emsp;我们可以通过<strong>Vue.set</strong>方法让对象里加入数据且成为响应式的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue.set(修改的对象/数组  ，  对象的属性/数组的索引  ，  值)</span></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">Vue.set(state.info,<span class="string">'address'</span>,<span class="string">'Fuzhou'</span>)</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line">Vue.set(sate.Arry,<span class="number">0</span>,<span class="string">'Fuzhou'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件中也可使用</span></span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(this.info,'address','fuzhou')</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;this.$set和Vue.set的区别：<br>Vue.set 可以设置实例创建之后添加的新的属性，（在data里未声明的属性），而。this.$set只能设置实例创建后存在的属性。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中父子组件传值和访问</title>
    <url>/MyBlog/2020/07/26/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>在开发中，往往一些数据确实需要从上层传递到下层∶</p>
<p>&emsp;&emsp;比如在一个页面中，我们从服务器请求到了很多的数据。</p>
<p>&emsp;&emsp;其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</p>
<p>&emsp;&emsp;这个时候，并不会让子组件再次发送一个网络请求，而是直接让<strong>大组件(父组件)</strong>将数据传递给<strong>小组件(子组件)</strong>。</p>
<p>如何进行父子组件间的通信呢?Vue官方提到</p>
<ul>
<li>通过<code>props</code>向子组件传递数据</li>
<li>通过事件向父组件发送消息</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt=""></p>
<a id="more"></a>
<h1 id="父传子-props"><a href="#父传子-props" class="headerlink" title="父传子 props"></a>父传子 props</h1><p>&emsp;&emsp;在组件中，使用选项props来声明需要从父级接收到的数据。props的值有两种方式:</p>
<ul>
<li>方式一:字符串数组，数组中的字符串就是传递时的名称。</li>
<li>方式二∶对象，对象可以设置传递时的类型，也可以设置默认值等。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传递动态props --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cmovies</span>=<span class="string">"movies"</span> <span class="attr">:message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传递静态props --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">cmovies</span>=<span class="string">"鳄鱼洗澡"</span> <span class="attr">message</span>=<span class="string">"hshshsh"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入数字、布尔值、数组、对象时，都需要用v-bind --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span> = <span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;cmovies&#125;&#125;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in cmovies"</span>&gt;</span>&#123;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">    template:<span class="string">'#cpn'</span>,</span><br><span class="line">    <span class="comment">//数组写法</span></span><br><span class="line">    props: [ <span class="string">'cmovies'</span>,<span class="string">'message'</span>],</span><br><span class="line">    <span class="comment">//对象写法（推荐）</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        cmovies:<span class="built_in">Array</span>,</span><br><span class="line">        <span class="comment">//还可以设置默认值，如果没传参，则显示默认值</span></span><br><span class="line">        messgae:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="string">'哈哈哈'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="comment">//return</span></span><br><span class="line">    &#125;，</span><br><span class="line">    methods:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化vue实例 父组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message:<span class="string">'你好啊'</span>，</span><br><span class="line">        movies:[<span class="string">'海王'</span>，<span class="string">'海贼王'</span>，<span class="string">'海尔兄弟'</span>]</span><br><span class="line">    &#125;，</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn<span class="comment">//cpn:cpn的简写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时，父组件中的movies和message已经传递到子组件中并可以展示了</p>
<h1 id="子传父-emit"><a href="#子传父-emit" class="headerlink" title="子传父 $emit"></a>子传父 $emit</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 监听子组件发射事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">itemClick</span>=<span class="string">"cpnClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span> = <span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击触发切换子组件事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">"item in categories"</span> @<span class="attr">click</span>=<span class="string">"btnClick(item)"</span>&gt;</span>&#123;&#123;item.name&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">    template:<span class="string">'#cpn'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            categories:[</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'aaa'</span>,name=<span class="string">'热门推荐'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'bbb'</span>,name=<span class="string">'手机数码'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'ccc'</span>,name=<span class="string">'家用家电'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>:<span class="string">'ddd'</span>,name=<span class="string">'电脑办公'</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btnClick(item)&#123;</span><br><span class="line">            <span class="comment">//给父组件传值，告诉父组件这个按钮被点击了</span></span><br><span class="line">            <span class="comment">//发射事件</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'itemClick'</span>)</span><br><span class="line">            <span class="comment">//同时，也可以携带参数</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'itemClick'</span>,item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化vue实例 父组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    &#125;，</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn<span class="comment">//cpn:cpn的简写</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="comment">//若无参数,item不写</span></span><br><span class="line">        cpnClick(item)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"接收到子组件的点击事件"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>原文链接：<a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">vue官方文档：单向数据流</a></p>
<p>&emsp;&emsp;所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>&emsp;&emsp;额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>&emsp;&emsp;这里有两种常见的试图变更一个 prop 的情形：</p>
<ul>
<li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用</strong>。在这种情况下，最好<strong>定义一个本地的 data property</strong>并将这个 prop 用作其初始值：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>这个 prop 以一种原始的值传入且需要进行转换</strong>。在这种情况下，最好<strong>使用这个 prop 的值来定义一个计算属性</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="vue中父子组件访问"><a href="#vue中父子组件访问" class="headerlink" title="vue中父子组件访问"></a>vue中父子组件访问</h1><h2 id="父子组件访问子组件方式：-children"><a href="#父子组件访问子组件方式：-children" class="headerlink" title="父子组件访问子组件方式：$children"></a>父子组件访问子组件方式：$children</h2>&emsp;&emsp;有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件。</li>
<li>父组件访问子组件:使用$children或$refs  (reference 引用)</li>
<li>子组件访问父组件∶使用$parent</li>
</ul>
<p>&emsp;&emsp;我们先来看下$children的访问</p>
<ul>
<li>this.$children是一个数组类型，它包含所有子组件对象。</li>
<li>我们这里通过一个遍历，取出所有子组件的message状态。</li>
</ul>
<p>现在，我们想在父组件中调用子组件的方法，就可以用$children</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们先定义一个子组件</span></span><br><span class="line">components:&#123;</span><br><span class="line">    cpn:&#123;</span><br><span class="line">        template:<span class="string">'#cpn'</span>,</span><br><span class="line">        data()&#123;    </span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                name:<span class="string">'我是子组件的name'</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showMessage()&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'showMessage'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件如下：</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message:<span class="string">'你好啊'</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btnclick()&#123;</span><br><span class="line">            <span class="comment">//重要的在这里！！！ 我们访问$children,就是访问组件对象</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children);</span><br><span class="line">            <span class="comment">//访问第一个组件对象的showmessage方法，输出'showmessage'</span></span><br><span class="line">            <span class="keyword">this</span>.$children[<span class="number">0</span>].showMessage()</span><br><span class="line">            <span class="comment">//访问第一个子组件的name属性</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[<span class="number">0</span>].name)</span><br><span class="line">            <span class="comment">//循环访问子组件的name</span></span><br><span class="line">            (<span class="keyword">let</span> c <span class="keyword">of</span> <span class="keyword">this</span>.$children)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(c.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">在html中定义模板</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnclick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="父子组件访问子组件方式-ref"><a href="#父子组件访问子组件方式-ref" class="headerlink" title="父子组件访问子组件方式 $ref"></a>父子组件访问子组件方式 $ref</h2><p>&emsp;<strong>但是，在普通的开发中，我们一般使用$ref而不是用$children,</strong>因为会有可能我们在开发中插入了一个子组件，这样this.$chilren[n]就有可能会出错,我们就可以用到$ref指定访问的组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对上一小节中的html模板改造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnclick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在btnclick这个方法中访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methids:&#123;</span><br><span class="line">    btnClick()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs);</span><br><span class="line">            <span class="comment">//访问第一个组件对象的showmessage方法，输出'showmessage'</span></span><br><span class="line">            <span class="keyword">this</span>.$refs.aaa.showMessage()</span><br><span class="line">            <span class="comment">//访问第一个子组件的name属性</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$ref.aaa.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子组件访问父组件方式-parent"><a href="#子组件访问父组件方式-parent" class="headerlink" title="子组件访问父组件方式$parent"></a>子组件访问父组件方式$parent</h2><p>我们写一个父子组件的嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">    cpn:&#123;</span><br><span class="line">        template: <span class="string">'#cpn'</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                name:<span class="string">'我是cpn组件的name'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        components: &#123;</span><br><span class="line">            ccpn:&#123;</span><br><span class="line">                template: <span class="string">'#ccpn'</span>,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    btnclick()&#123;</span><br><span class="line">                    <span class="comment">// 1.访问父组件$parent</span></span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent);</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.name);<span class="comment">//输出'我是cpm组件的name'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在开发中并<strong>不建议使用</strong>，因为组件本来就是为了复用，如果这样写就必须要求父组件中有对应的方法，<strong>降低了复用性</strong>。</p>
<h2 id="访问根组件-root"><a href="#访问根组件-root" class="headerlink" title="访问根组件 $root"></a>访问根组件 $root</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的路由</title>
    <url>/MyBlog/2020/07/28/Vue%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h2><ul>
<li>概念:根据不同的用户URL请求，返回不同的内容</li>
<li>本质:URL请求地址与服务器资源之间的对应关系<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2></li>
<li>概念:根据不同的用户事件，显示不同的页面内容</li>
<li>本质:用户事件与事件处理函数之间的对应关系</li>
</ul>
<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>&emsp;&emsp;vue Router(官网: <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a> )是Vue.js官方的路由管理器。</p>
<a id="more"></a>
<h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><ul>
<li>1.引入相关的库文件</li>
<li>2.添加路由链接</li>
<li>3.添加路由填充位</li>
<li>4.定义路由组件</li>
<li>5.配置路由规则并创建路由实例</li>
<li>6.把路由挂载到Vue根实例中</li>
</ul>
<p>我们来看最简单的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 被vm实例所控制的区域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">" /user"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--路由占位符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义路由组件</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;User 组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Register = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;Register 组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    <span class="comment">// routes是路由规则数组</span></span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//每个路由规则都是一个配置对象，其中至少包含path和component两个属性:</span></span><br><span class="line">    <span class="comment">//path表示当前路由规则匹配的hash地址</span></span><br><span class="line">    <span class="comment">// component表示当前路由规则对应要展示的组件</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/user'</span>, <span class="attr">component</span>: User&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>: Register&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//把路由挂载到Vue根实例中</span></span><br><span class="line"><span class="comment">//创建vm实例对象</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//指定控制的区域</span></span><br><span class="line">    el: <span class="string">'#app'</span>，</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">    <span class="comment">//挂载路由实例对象</span></span><br><span class="line">    <span class="comment">// router: router  可简写</span></span><br><span class="line">    router</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>路由重定向指的是∶用户在访问地址A的时候，强制用户跳转到地址c，从而展示特定的组件页面;<br>通过路由规则的<code>redirect</code>属性，指定一个新的路由地址，可以很方便地设置路由的重定向:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//其中，path表示需要被重定向的原地址，redirect表示将要被重定向到的新地址</span></span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/user'</span>&#125;，</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/user'</span>, <span class="attr">component</span>: user&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/ register'</span>, <span class="attr">component</span>: Register&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由功能分析</p>
<ul>
<li>点击父级路由链接显示模板内容</li>
<li>模板内容中又有子级路由链接</li>
<li>点击子级路由链接显示子级模板内容</li>
</ul>
<p>如图<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt=""></p>
<h3 id="父路由组件模板"><a href="#父路由组件模板" class="headerlink" title="父路由组件模板"></a>父路由组件模板</h3><ul>
<li>父级路由链接</li>
<li>父组件路由填充位<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">routir-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控制组件的显示位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="子级路由模板"><a href="#子级路由模板" class="headerlink" title="子级路由模板"></a>子级路由模板</h3></li>
<li>子级路由链接</li>
<li>子级路由填充位<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Register =&#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Register组件&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;hr/&gt;</span></span><br><span class="line"><span class="string">    &lt;router-link to=" /register/tab1" &gt;Tab1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;router-link to=" /register/tab2" &gt;Tab2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;!--子路由填充位置 --&gt;</span></span><br><span class="line"><span class="string">    &lt;router-view /&gt;</span></span><br><span class="line"><span class="string">    &lt;/ div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">corst Tab1 = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;tab1子组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Tab2 = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;tab2子组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套路由配置"><a href="#嵌套路由配置" class="headerlink" title="嵌套路由配置"></a>嵌套路由配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父级路由通过children属性配置子级路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter ([</span><br><span class="line">    routes:[</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">component</span>: User &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/register'</span>,<span class="attr">component</span>: Register,<span class="attr">children</span>:[</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/register/tab1'</span>, <span class="attr">component</span>: Tab1 &#125;，</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/register/tab2'</span>, <span class="attr">component</span>: Tab2 &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">&#125;) <span class="comment">//通过children属性，为/register添加子路由规则</span></span><br></pre></td></tr></table></figure>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2>应用场景:通过动态路由参数的模式进行路由匹配<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//动态路径参数以冒号开头</span></span><br><span class="line">    path:&#123;<span class="string">'/user/:id'</span>, <span class="attr">component</span>: user &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    <span class="comment">//路由组件中通过$route.params获取路由参数</span></span><br><span class="line">    template: <span class="string">'&lt;div&gt;user的id为：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="最简单的路由传参方法"><a href="#最简单的路由传参方法" class="headerlink" title="最简单的路由传参方法"></a>最简单的路由传参方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>&#125; <span class="comment">//定义一个路由参数</span></span><br><span class="line">&lt;router-link to=<span class="string">"/user/123"</span>&gt;&lt;<span class="regexp">/router-link&gt;/</span><span class="regexp">/传值，</span></span><br><span class="line"><span class="regexp">this.$route.params.id/</span><span class="regexp">/取值</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/query传值,指通过?后面的拼接参数传值</span></span><br><span class="line"><span class="regexp">&lt;router-link to="/u</span>ser?id=<span class="number">123</span><span class="string">"&gt;&lt;/router-link&gt;//传值</span></span><br><span class="line"><span class="string">this.$route.query.id//取值</span></span><br></pre></td></tr></table></figure>
<h3 id="利用props"><a href="#利用props" class="headerlink" title="利用props"></a>利用props</h3><p>&emsp;&emsp;刚刚说了利用动态路由匹配可以进行路由的传参，但是$route与对应路由形成高度耦合，不够灵活，所以可以使用<code>props</code>将组件和路由解耦</p>
<h3 id="props的值为布尔类型"><a href="#props的值为布尔类型" class="headerlink" title="props的值为布尔类型"></a>props的值为布尔类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props被设置为true，route.params将会被设置为组件属性</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>,<span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props: [<span class="string">'id'</span>],<span class="comment">//使用props接收路由参数,就不需要通过$route.params</span></span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户ID:&#123;&#123; id &#125;&#125;&lt;/div&gt;'</span><span class="comment">//使用路由参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-props的值为对象类型"><a href="#2-props的值为对象类型" class="headerlink" title="2.props的值为对象类型"></a>2.props的值为对象类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter ( &#123;</span><br><span class="line">    routes: [</span><br><span class="line">    <span class="comment">//如果props是一个对象，它会被按原样设置为组件属性</span></span><br><span class="line">    ( path: <span class="string">'/user/:id'</span>,<span class="attr">component</span>: User,<span class="attr">props</span>: &#123; <span class="attr">uname</span>: <span class="string">'lisi'</span>，age: <span class="number">12</span> &#125;&#125;<span class="comment">//此时，无法访问id的值</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[<span class="string">'uname '</span>, <span class="string">'age'</span> ],</span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户信息:&#123; uname + '</span>---<span class="string">' + age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="props的值为函数类型"><a href="#props的值为函数类型" class="headerlink" title="props的值为函数类型"></a>props的值为函数类型</h3><p>我们现在又想获取id的值，又想获取name和age，怎么办呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">constrouter =<span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props 是一个函数，则这个函数接收route对象为自己的形参</span></span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/user/ :id'</span>,</span><br><span class="line">        component: User,</span><br><span class="line">        <span class="comment">//route为动态参数对象。在路由url后面有几个参数项，route里就有几个参数值</span></span><br><span class="line">        props: <span class="function"><span class="params">route</span> =&gt;</span>([ uname: <span class="string">'zs'</span>，age: <span class="number">20</span>,<span class="attr">id</span>: route.params.id &#125;)&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[ <span class="string">'uname '</span>, <span class="string">'age'</span>, <span class="string">'id'</span>]，</span><br><span class="line">    template: <span class="string">'div&gt;用户信息:[&#123; uname + '</span>---<span class="string">' + age + '</span>---<span class="string">' + id]]&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link to="/user"&gt;User&lt;/router-link&gt; 传统路由 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">routir-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'user',params:&#123;id:3&#125;&#125;"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name:路由名称  params:路由需要携带的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控制组件的显示位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">constrouter =<span class="keyword">new</span> vueRouter (&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        <span class="comment">//如果props 是一个函数，则这个函数接收route对象为自己的形参</span></span><br><span class="line">        &#123;   </span><br><span class="line">            name:<span class="string">'user'</span><span class="comment">//**给路由起一个名字**</span></span><br><span class="line">            path:<span class="string">'/user/ :id'</span>,</span><br><span class="line">            component: User,</span><br><span class="line">            <span class="comment">//route为动态参数对象。在路由url后面有几个参数项，route里就有几个参数值</span></span><br><span class="line">            props: <span class="function"><span class="params">route</span> =&gt;</span>([ uname: <span class="string">'zs'</span>，age: <span class="number">20</span>,<span class="attr">id</span>: route.params.id &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    props:[ <span class="string">'uname '</span>, <span class="string">'age'</span>, <span class="string">'id'</span>]，</span><br><span class="line">    template: <span class="string">'&lt;div&gt;用户信息:&#123;&#123; uname + '</span>---<span class="string">' + age + '</span>---<span class="string">' + id&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由的编程式导航"><a href="#路由的编程式导航" class="headerlink" title="路由的编程式导航"></a>路由的编程式导航</h1><h2 id="页面导航的两种方式："><a href="#页面导航的两种方式：" class="headerlink" title="页面导航的两种方式："></a>页面导航的两种方式：</h2><ul>
<li><p>声明式导航:通过点击链接实现导航的方式，叫做声明式导航<br>例如:普通网页中的<a></a>链接或vue中的<router-link></router-link></p>
</li>
<li><p>编程式导航:通过调用JavaScript形式的API实现导航的方式，叫做编程式导航<br>例如:普通网页中的location.href<br>心</p>
</li>
</ul>
<h2 id="编程式导航基本用法"><a href="#编程式导航基本用法" class="headerlink" title="编程式导航基本用法"></a>编程式导航基本用法</h2><p>常用的编程式导航API如下:</p>
<ul>
<li>this.$router.push(‘hash地址’)</li>
<li>this.$router.go(n)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//push的用法</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click="goRegister"&gt;跳转到注册页面&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    goRegister: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用编程的方式控制路由跳转</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/register'</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go的用法</span></span><br><span class="line"><span class="keyword">const</span> Register = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Register组件&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click="goBack"&gt;后退&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        goBack()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编程式导航的参数规则"><a href="#编程式导航的参数规则" class="headerlink" title="编程式导航的参数规则"></a>编程式导航的参数规则</h2><code>router.push()</code>方法的参数规则<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串(路径名称)</span></span><br><span class="line">router.push( <span class="string">'/home'</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">router.push( &#123; <span class="attr">path</span>: <span class="string">'/home'</span> &#125;)</span><br><span class="line"><span class="comment">//命名的路由(传递参数)</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"><span class="comment">//带查询参数，变成/register?uname=lisi</span></span><br><span class="line">router.push( &#123; <span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">query</span>: &#123; <span class="attr">uname</span>: <span class="string">'lisi'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a>hash和history</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul>
<li><p>hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影- 响，因此改变 hash 不会重新加载页面。</p>
</li>
<li><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.-" target="_blank" rel="noopener">http://www.-</a> npc.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 - 404 错误。</p>
</li>
<li><p>hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中。</p>
</li>
<li><p>hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL。</p>
</li>
<li><p>hash 只可添加短字符串。</p>
<h2 id="history（服务器环境下才有效果）"><a href="#history（服务器环境下才有效果）" class="headerlink" title="history（服务器环境下才有效果）"></a>history（服务器环境下才有效果）</h2></li>
<li><p>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；；</p>
</li>
<li><p>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记添加到栈中；</p>
</li>
<li><p>pushState() 通过 stateObject 参数可以添加任意类型的数据到记中；；</p>
</li>
<li><p>pushState() 可额外设置 title 属性供后续使用。</p>
</li>
</ul>
<h1 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h1><p>路由导航守卫可以用于在前端路由跳转之前判断用户的登录状态。写一个vue_shop中的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在router.js实例中 挂载路由导航守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to，<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// to 将要访问的路径</span></span><br><span class="line">    <span class="comment">// from 代表从哪个路径跳转而来</span></span><br><span class="line">    <span class="comment">// next是一个函数，表示放行</span></span><br><span class="line">    <span class="comment">//next(）放行next( '/login'）强制跳转</span></span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/1ogin'</span>) <span class="keyword">return</span> next()</span><br><span class="line">    <span class="comment">//获取token</span></span><br><span class="line">    <span class="keyword">const</span> tokenStr = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">"token"</span>)</span><br><span class="line">    <span class="comment">//不存在token，返回登录页</span></span><br><span class="line">    <span class="keyword">if</span> (!tokenstr) <span class="keyword">return</span> next(<span class="string">'/login'</span>)</span><br><span class="line">    <span class="comment">//验证通过，放行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue脚手架</title>
    <url>/MyBlog/2020/07/30/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="VueCLI"><a href="#VueCLI" class="headerlink" title="VueCLI"></a>VueCLI</h1><p>CLI是什么意思?</p>
<p>&emsp;&emsp;CLI是Command-Line Interface,翻译为命令行界面,但是俗称脚手架.Vue CLI是一个官方发布vue.js项目脚手架<br>&emsp;&emsp;使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置.</p>
<p><strong>！VueCLI使用前必须安装node环境和webpack</strong></p>
<h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>可以直接在官方网站中下载安装。网址: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><blockquote>
<p>npm install webpack -g</p>
</blockquote>
<h2 id="VueCLI的安装"><a href="#VueCLI的安装" class="headerlink" title="VueCLI的安装"></a>VueCLI的安装</h2><p>安装vue脚手架：(全局安装)</p>
<blockquote>
<p>npm install -g @vue/cli</p>
</blockquote>
<a id="more"></a>
<h1 id="VueCLI的使用"><a href="#VueCLI的使用" class="headerlink" title="VueCLI的使用"></a>VueCLI的使用</h1><p>初始化项目可以用两个命令：</p>
<blockquote>
<p>vue create 项目名称<br>vue ui 进入图形化界面</p>
</blockquote>
<h2 id="create创建过程"><a href="#create创建过程" class="headerlink" title="create创建过程"></a>create创建过程</h2><p> <img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%84%9A%E6%89%8B%E6%9E%B6create.png" alt=""></p>
<h2 id="创建项目的文件目录"><a href="#创建项目的文件目录" class="headerlink" title="创建项目的文件目录"></a>创建项目的文件目录</h2><p> <img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt=""></p>
<h1 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h1><p>&emsp;&emsp;由于vue-cli3将webpack的基础配置全部内嵌了，这就导致我们初始化项目完成之后发现原先的webpack的config配置全部都消失不见了，那该怎么办呢？别慌，vue-cli早就考虑到了这一点，它预留了一个vue.config.js的js文件供我们对webpack进行自定义配置。</p>
<h2 id="在项目根目录下新建vue-config-js文件与package-json同级"><a href="#在项目根目录下新建vue-config-js文件与package-json同级" class="headerlink" title="在项目根目录下新建vue.config.js文件与package.json同级"></a>在项目根目录下新建vue.config.js文件与package.json同级</h2><p>&emsp;&emsp;这里的vue.config.js会和脚手架创建的webpack合并，成为最终配置</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的监听器和过滤器</title>
    <url>/MyBlog/2020/08/12/Vue%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器可以监听数据的变化，当某个数据改变时，可以触发某个函数</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%9B%91%E5%90%AC%E5%99%A8.png" alt=""></p>
<p>来看看监听器的简单用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数据  在html中用v-model绑定   </span></span><br><span class="line">data&#123;</span><br><span class="line">    firstName:<span class="string">'xxx'</span></span><br><span class="line">    lastName:<span class="string">'yyy'</span></span><br><span class="line">    fullName:<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">    <span class="comment">//监听firstname变化</span></span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// val表示变化之后的值</span></span><br><span class="line">        <span class="keyword">this</span>.fullName = val + <span class="keyword">this</span>.lastName ;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//监听lastname变化</span></span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>其实，对于这个例子，我们用计算属性也可以实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName +<span class="string">''</span>+ <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反而计算属性更简单。对于这些<strong>字符串操作，更适合计算属性做</strong>，<strong>监听器的使用场景主要在异步操作和弹窗提示</strong>等功能中</p>
<p>&emsp;&emsp;现在我们来做一个小案例，需求:输入框中输入姓名，<strong>失去焦点</strong>时验证是否存在，如果已经存在，提示从新输入，如果不存在，提示可以使用。<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%9B%91%E5%90%AC%E5%99%A8%E6%A1%88%E4%BE%8B.png" alt=""><br>我们需要做到以下东西：</p>
<ul>
<li>通过v-model实现数据绑定</li>
<li>需要提供提示信息</li>
<li>需要侦听器监听输入信息的变化</li>
<li>需要修改触发的事件</li>
</ul>
<p>我们先写个表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"uname"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;tip&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后来写监听器，注意以下几点</p>
<ul>
<li>采用侦听器监听用户名的变化</li>
<li>调用后台接口进行验证</li>
<li>根据验证的结果调整提示信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        uname:<span class="string">''</span>,</span><br><span class="line">        tip:<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    checkName: <span class="function"><span class="keyword">function</span>(<span class="params">uname</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//调用接口，但是可以使用定时任务的方式模拟接口调用</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;<span class="comment">//可以用箭头函数</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//模拟接调用</span></span><br><span class="line">            <span class="keyword">if</span>(uname == <span class="string">'admin'</span>)&#123;</span><br><span class="line">                that.tip =<span class="string">'用户名己经存在，请更换一个'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                that.tip =<span class="string">'用户名可以使用'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">        uname: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//调用后台接口验证用户名的合法性</span></span><br><span class="line">            <span class="keyword">this</span>.checkName(val)</span><br><span class="line">            <span class="keyword">this</span>.tip = <span class="string">'正在验证...'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="过滤器的作用是什么"><a href="#过滤器的作用是什么" class="headerlink" title="过滤器的作用是什么?"></a>过滤器的作用是什么?</h2><p>格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue.filter(upper, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;<span class="comment">//把过滤器加到哪里，value就是哪里的数据</span></span><br><span class="line">    <span class="comment">//过滤器业务逻辑  首字母大写</span></span><br><span class="line">    <span class="keyword">return</span> val.charAt().toUpperCase()+ val.slice(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">vue.filter(lower, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//过滤器业务逻辑  首字母小写</span></span><br><span class="line">    <span class="keyword">return</span> val.charAt().toLowerCase()+ val.slice(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg | upper&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg | upper | lower&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"id | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//效果和全局过滤器一样，但是在组件内部才能使用</span></span><br><span class="line">filters: &#123;</span><br><span class="line">    upper: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toUpperCase()+val.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参数的过滤器"><a href="#带参数的过滤器" class="headerlink" title="带参数的过滤器"></a>带参数的过滤器</h2><p>我们想把当前时间(如2020-8-12T09:20:15)的时间改成2020-8-12可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数是要过滤的参数，第二个是过滤器携带的参数</span></span><br><span class="line">Vue.filter(<span class="string">'format'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value,arg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果是这个格式</span></span><br><span class="line">    <span class="keyword">if</span>(arg ==<span class="string">'yyyy-MM-dd'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> ret =<span class="string">''</span>;</span><br><span class="line">        ret+= value.getFullYear()+<span class="string">'-'</span>+(value.getMonth()+ <span class="number">1</span>)+<span class="string">'-'</span>  +value.getDate();</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;、</span><br><span class="line">    <span class="comment">//如果不是这个格式</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤器的使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;date | format('yyyy-MM-Nd')&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>监听器</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由传参param与query两种方式的区别</title>
    <url>/MyBlog/2020/07/28/Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82param%E4%B8%8Equery%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h1><p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>,<span class="attr">component</span>:Login&#125;,</span><br></pre></td></tr></table></figure>
<p>1.页面携带query参数跳转(path,name指定跳转到Login时都可以携带query参数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: <span class="keyword">this</span>.id &#125; )</span><br></pre></td></tr></table></figure>
<p>query相当与发送了一次get请求，请求参数会显示在浏览器地址栏中</p>
<p>2.页面携带params参数跳转(携带params参数跳转时只能使用name指定)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>:<span class="string">'Login'</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="keyword">this</span>.id &#125; )</span><br></pre></td></tr></table></figure>
<p>params相当与发送了一次post请求，请求参数则不会显示，并且刷新页面之后参数会消失</p>
<a id="more"></a>
<p>当路由配置更改为</p>
<p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login/:id'</span>,<span class="attr">name</span>:<span class="string">'Login'</span>,<span class="attr">component</span>:Login&#125;</span><br></pre></td></tr></table></figure>

<p>并且再次发送请求，请求数据不会随着页面的刷新而消失</p>
<p>获取请求参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.params.id</span><br><span class="line"><span class="keyword">this</span>.$route.query.id</span><br></pre></td></tr></table></figure>
<p>注: </p>
<p>&emsp;&emsp;<code>router</code>是<code>VueRoute</code>r的一个对象，通过<code>Vue.use(VueRouter)</code>和<code>VueRouter</code>构造函数得到一个<code>router</code>的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。</p>
<p>&emsp;&emsp;<code>$router.push({path:&#39;login&#39;})</code>;本质是向<code>history</code>栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个<code>history</code>记录;</p>
<p>&emsp;&emsp;而<code>route</code>是一个跳转的路由对象，每一个路由都会有一个<code>route</code>对象，是一个局部的对象，可以获取对应的<code>name,path,params,query</code>等</p>
<h1 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h1><h2 id="用法上的"><a href="#用法上的" class="headerlink" title="用法上的"></a>用法上的</h2><p>&emsp;&emsp;<code>query</code>要用<code>path</code>来引入，<code>params</code>要用<code>name</code>来引入，接收参数都是类似的，分别是<code>this.$route.query.name</code>和<code>this.$route.params.name</code>。</p>
<p>注意接收参数的时候，已经是<code>$route</code>而不是<code>$router</code>了哦！！</p>
<h2 id="展示上的"><a href="#展示上的" class="headerlink" title="展示上的"></a>展示上的</h2><p>&emsp;&emsp;query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p>query:<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/query%E8%B7%AF%E7%94%B1.png" alt=""><br>params:<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/params%E8%B7%AF%E7%94%B1.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack（二）plugin mode</title>
    <url>/MyBlog/2020/07/30/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><h2 id="plugin是什么"><a href="#plugin是什么" class="headerlink" title="plugin是什么?"></a>plugin是什么?</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</p>
<h2 id="loader和plugin区别"><a href="#loader和plugin区别" class="headerlink" title="loader和plugin区别"></a>loader和plugin区别</h2><ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li>
</ul>
<h2 id="plugin的使用过程∶"><a href="#plugin的使用过程∶" class="headerlink" title="plugin的使用过程∶"></a>plugin的使用过程∶</h2><ul>
<li>步骤一∶通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li>
<li>步骤二︰在webpack.config.js中的plugins中配置插件。webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。   </li>
</ul>
<p>&emsp;&emsp;我们下面就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让webpack变得更加好用。</p>
<a id="more"></a>
<h1 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h1><p>&emsp;&emsp;我们先来使用一个最简单的插件，为打包的文件添加版权声明。该插件名字叫<code>BannerPlugin</code>，属于webpack自带的插件。<br>&emsp;&emsp;按照下面的方式来修改webpack.config.js的文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack =<span class="built_in">require</span>( <span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'最终版权归yang所有'</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打包程序:查看bundle.js文件的头部，看到如下信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!最终版权归yang所有*/</span></span><br><span class="line"><span class="comment">//bundle.js主体内容</span></span><br></pre></td></tr></table></figure>
<h1 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h1><p>&emsp;&emsp;目前，我们的index.html文件是存放在项目的根目录下的。<br>&emsp;&emsp;我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件<br>&emsp;&emsp;<code>HtmlWebpackPlugin</code>插件可以为我们做这些事情:</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件</p>
<blockquote>
<p>npm install html-webpack-plugin –save-dev</p>
</blockquote>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlwebpackPlugin = <span class="built_in">require</span>( <span class="string">' html-webpack-plugin '</span> );</span><br><span class="line"><span class="comment">//加上module.export</span></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'最终版权归yang所有'</span>)，</span><br><span class="line">    <span class="keyword">new</span> htmlwebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)，</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里的template表示根据什么模板来生成index.html</p>
<h1 id="mode的生产模式中css的优化"><a href="#mode的生产模式中css的优化" class="headerlink" title="mode的生产模式中css的优化"></a>mode的生产模式中css的优化</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/webpackmode.png" alt=""></p>
<p>&emsp;&emsp;在开发模式中，我们只要能让代码跑起来就行，那么生产环境中我们需要做什么呢？</p>
<ul>
<li>在开发模式中，我们把css也打包进了bundle.js文件中,这样做会让js体积变得特别大，同时，因为它先加载js才能创建style标签插入到页面中，这里会出现<strong>闪屏</strong>现象，所以，我们需要把css从js中提取出来。</li>
<li>由于css代码也很多，所以我们需要进行<strong>压缩处理</strong><br>&emsp;&emsp;这时候，我们就需要两种mode，一种是<strong>开发模式(developmen)</strong>，一种是<strong>生产模式(production)</strong></li>
</ul>
<p>首先，我们进行提取css成单独文件的插件的下载</p>
<blockquote>
<p>npm i mini-css-extract-plugin -D</p>
</blockquote>
<p>然后导入并使用。使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>( <span class="string">'mini-css-extract-plugin'</span> );</span><br><span class="line"><span class="comment">//加上module.export</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$ /</span>,</span><br><span class="line">            use:[</span><br><span class="line">                <span class="comment">//创建style标签，将样式放入</span></span><br><span class="line">                <span class="comment">//'style-loader' ,</span></span><br><span class="line">                <span class="comment">//这个loader取代style-loader。作用:提取js中的css成单独文件  </span></span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="comment">//将css文件整合到js文件中</span></span><br><span class="line">                <span class="string">'css-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        <span class="comment">//对文件重命名</span></span><br><span class="line">        filename:<span class="string">'css/build.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line">mode:<span class="string">'development'</span></span><br></pre></td></tr></table></figure>

<h2 id="打包后css的兼容性处理"><a href="#打包后css的兼容性处理" class="headerlink" title="打包后css的兼容性处理"></a>打包后css的兼容性处理</h2><p>&emsp;&emsp;css的样式具有兼容性问题，在不同内核的浏览器中需要不同的兼容性解决方案，我们现在可以在webpack中通过<code>postcss</code>这个库来处理我们的css兼容性问题</p>
<p>&emsp;&emsp;下载<code>postcss-loader</code>。同时我们还要下载一个<code>postcss-preset-env</code>插件，这个插件能帮助我们的postcss识别某些环境，从而加载指定的配置</p>
<blockquote>
<p>npm i postcss-loader postcss-preset-env -D</p>
</blockquote>
<p>现在，我们把刚刚的例子拿过来，加入兼容性处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>( <span class="string">'mini-css-extract-plugin'</span> );</span><br><span class="line"><span class="comment">//加上module.export</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$ /</span>,</span><br><span class="line">            use:[</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="comment">//使用loader的默认配置</span></span><br><span class="line">                <span class="comment">//'postcss-loader',</span></span><br><span class="line">                <span class="comment">//修改loader的配置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        <span class="comment">//固定写法</span></span><br><span class="line">                        ident: <span class="string">'postcss '</span>,</span><br><span class="line">                        plugins: <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">                            <span class="comment">// postcss的插件,帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</span></span><br><span class="line">                            <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        <span class="comment">//对文件重命名</span></span><br><span class="line">        filename:<span class="string">'css/build.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line">mode:<span class="string">'development'</span></span><br></pre></td></tr></table></figure>

<p>由于<code>postcss-preset-env</code>这个插件帮postcss找到package.json中<code>browserslist</code>里面的配置，通过配置加载指定的css兼容性样式,所以，我们在package.json中也要进行相应配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"browserslist":&#123;</span><br><span class="line">    <span class="comment">//开发模式，只要兼容最新的浏览器</span></span><br><span class="line">    "development":[</span><br><span class="line">        "last 1 chrome version",</span><br><span class="line">        "last 1 firefox version",</span><br><span class="line">        <span class="string">"last 1 safari version"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//生产模式，默认</span></span><br><span class="line">    "production":[</span><br><span class="line">        <span class="comment">//兼容99.99%的浏览器</span></span><br><span class="line">        "&gt;0.01%",</span><br><span class="line">        "not dead" ,</span><br><span class="line">        <span class="string">"not op_mini all"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在node中，默认打包为生产环境，这个和mode设置成development没有关系,所以，我们要手动设置成开发环境</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上个示例中的module.export外部设置</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">'development'</span> ;</span><br><span class="line"><span class="comment">//如果打包成生产环境，把这段话注释掉就行</span></span><br></pre></td></tr></table></figure>
<p>这样就可以处理开发模式css的兼容问题</p>
<h2 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h2><p>压缩css，我们需要使用一个插件</p>
<blockquote>
<p>npm i optimize-css-assets-webpack-plugin -D</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">const</span> optimizeCssAssetsWebpackPlugin=<span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> optimizeCssAssetsWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/MyBlog/2020/08/11/axios/</url>
    <content><![CDATA[<p>axios(官网: <a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a> )是一个基于Promise用于浏览器和node.js的HTTP客户端。<br>它具有以下特征:</p>
<ul>
<li>支持浏览器和node.js心</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>npm install axios -S</p>
</blockquote>
<h1 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/data'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// data属性名称是固定的，用于获取后台响应的数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="axios常用API"><a href="#axios常用API" class="headerlink" title="axios常用API"></a>axios常用API</h1><ul>
<li>get :查询数据</li>
<li>post:添加数据</li>
<li>put :修改数据</li>
<li>delete:删除数据</li>
</ul>
<h1 id="axios的参数传递"><a href="#axios的参数传递" class="headerlink" title="axios的参数传递"></a>axios的参数传递</h1><h2 id="get参数传递"><a href="#get参数传递" class="headerlink" title="get参数传递"></a>get参数传递</h2><ul>
<li>通过URL传递参数</li>
<li>通过params选项传递参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过url传参(第一种)</span></span><br><span class="line">axios.get( <span class="string">'/adata?id=123'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log (res.data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.get(<span class="string">'/adata'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">"axios get 传递参数"</span>+ req.query.id)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过url传参(第二种)</span></span><br><span class="line">axios.get( <span class="string">'/adata/123'</span>)</span><br><span class="line">    .then (<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log (res.data) </span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.get(<span class="string">'/adata/:id'</span>, (req，res) =&gt;&#123;</span><br><span class="line">res.send(<span class="string">'axios get (Restful）传递参数'</span>+req.params.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过params属性传参（params用于传递get参数）</span></span><br><span class="line">axios.get(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    params : &#123;</span><br><span class="line">        id: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="delete参数传递"><a href="#delete参数传递" class="headerlink" title="delete参数传递"></a>delete参数传递</h2>传递方式与get类似 也是通过url和param，我这里实现一下params<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过params属性传参</span></span><br><span class="line">axios.delete(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    params : &#123;</span><br><span class="line">        id: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.delete(<span class="string">'/axios'</span>,(req，res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios get传递参数'</span>+req.query.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="post参数传递"><a href="#post参数传递" class="headerlink" title="post参数传递"></a>post参数传递</h2></li>
<li>通过选项传递参数（默认传递的是json格式的数据）</li>
<li>通过URLSearchParams传递参数(application/x-www-form-urlencoded)(了解就好)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">    uname: <span class="string">'tom'</span>,</span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.post(<span class="string">"/axios"</span>, (req,res) =&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios post传递参数'</span>+req.body.uname + <span class="string">'---'</span>+req.body.pwd)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="put参数传递"><a href="#put参数传递" class="headerlink" title="put参数传递"></a>put参数传递</h2>与post类似 但是一般会在url后面跟上具体要修改的内容的id<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/adata/123'</span>,&#123;<span class="comment">//123为要修改的信息的id</span></span><br><span class="line">    uname: <span class="string">'tom'</span>,<span class="comment">//要修改的对应id的信息</span></span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">app.post(<span class="string">"/axios/:id"</span>, (req,res) =&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'axios put传递参数'</span>+req.params.id + <span class="string">'---'</span>+req.body.uname + <span class="string">'---'</span>+req.body.pwd)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="axios的全局配置"><a href="#axios的全局配置" class="headerlink" title="axios的全局配置"></a>axios的全局配置</h1></li>
<li>axios.defaults.timeout = 3000//超时时间</li>
<li>axios.defaults.baseURL = ‘<a href="http://localhost:3000/app&#39;;//默认地址" target="_blank" rel="noopener">http://localhost:3000/app&#39;;//默认地址</a></li>
<li>axios.defaults.headers[‘mytoken’]= ‘aqwerwqwerqwer2ewrwe23eresdf23’//设置请求头</li>
</ul>
<h1 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h1><h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>在请求发出之前设置一些信息<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在请求发出之前进行一些信息设置</span></span><br><span class="line">    <span class="built_in">console</span>.log(config.url)<span class="comment">//判断url需不需要加请求头</span></span><br><span class="line">    config.headers.mytoken = <span class="string">'nihao'</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h2><p>在获取数据之前对数据做一些加工处理<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里对返回的数据进行处理 这里把data拆解出来</span></span><br><span class="line">    <span class="keyword">var</span> data = res.data</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="异步终极解决方案-async-await"><a href="#异步终极解决方案-async-await" class="headerlink" title="异步终极解决方案 async/await"></a>异步终极解决方案 async/await</h1><ul>
<li>async/await是ES7引入的新语法，可以更加方便的进行异步操作</li>
<li>async关键字用于函数上(async函数的返回值是Promise实例对象)</li>
<li>await关键字用于async函数当中(await可以得到异步的结果)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then和回调函数，await可以直接返回结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">&#125;</span><br><span class="line">queryData();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你想把结果中的res.data return出去，那么这个return出去的东西是一个peomise对象，可供后面链式调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then，await直接返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">&#125;</span><br><span class="line">queryData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    consolr.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
await后面需要跟上一个异步对象，如果是我们自己写的promise对象想用async和await，如下<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> axios.get(<span class="string">'adata'</span>)<span class="comment">//不需要调用then，await直接返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">&#125;</span><br><span class="line">queryData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    consolr.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack（一） 基本使用和loader</title>
    <url>/MyBlog/2020/07/30/Webpack%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h1><p>来看看官方的解释：</p>
<p>&emsp;&emsp;At its core, webpack is a static module bundler for modern JavaScript applications.</p>
<p>&emsp;&emsp;从本质上来讲，webpack是一个现代的JavgScript应用的静态<strong>模块打包</strong>工具。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/webpack.png" alt=""></p>
<p>&emsp;&emsp;他把所有资源打包压缩成浏览器认识的语法，从而更好的放在服务器上部署，按我的理解就是：大概webpack类似于一个翻译软件，但是它内部是用google翻译（即node）进行翻译的。<br>翻译是为了让我们写的代码能被计算机所识别。</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>！Webpack为了可以正常运行，必须依赖node环境</strong></p>
<h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><blockquote>
<p>npm install webpack webpack-cli -g</p>
</blockquote>
<p>指定版本：</p>
<blockquote>
<p>npm install <a href="mailto:webpack@4.42.0">webpack@4.42.0</a> -g</p>
</blockquote>
<h2 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h2><p>–save-dev是开发时依赖，项目打包后不需要继续使用的。</p>
<blockquote>
<p>npm install webpack –save-dev</p>
</blockquote>
<h1 id="Webpack的基本使用规则"><a href="#Webpack的基本使用规则" class="headerlink" title="Webpack的基本使用规则"></a>Webpack的基本使用规则</h1><p>&emsp;&emsp;在浏览器中，浏览器并不认识commonjs的模块化规范，只认识ES6模块化规范，这个时候，我们就可以用webpack打包模块，让浏览器可以识别。另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mathutil.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 *num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,</span><br><span class="line">    mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;add,mul&#125; =reguire(<span class="string">'./mathutils.js'</span>)l</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>，<span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>，<span class="number">30</span>));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在HTML文件中引入main.js部署到服务器上时，浏览器无法解析commonjs的module.exports，这个时候我们需要通过webpack打包<br><strong>开发环境：</strong></p>
<blockquote>
<p>webpack ./src/main.js -o ./build/bundle.js –mode=development<br><strong>生产环境：</strong>(会压缩代码)<br>webpack ./src/main.js -o ./build/bundle.js –mode=production</p>
</blockquote>
<p>&emsp;&emsp;这时，我们在index.html中引入<code>./build/bundle.js</code>  就可以访问到这两个方法并使用了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Webpack的配置"><a href="#Webpack的配置" class="headerlink" title="Webpack的配置"></a>Webpack的配置</h1><p>&emsp;&emsp;为了更方便的使用webpack，我们可以定义一个<code>webpack.config.js</code>文件来管理我们需要的命令</p>
<p>&emsp;&emsp;在任何项目中，当需要运用到node环境时，我们都需要执行下面的命令来初始化node的配置</p>
<blockquote>
<p>npm init  || npm init -y<br>就会生成 <code>package.json</code>这个文件，这个文件主要描述了当前项目里的一些信息</p>
</blockquote>
<p>然后，我们就可以在<code>webpack.config.js</code>中配置打包文件的入口和出口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入path模块，使用__dirname来拼接绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = reguire(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="comment">//入口文件  即需要打包的文件</span></span><br><span class="line">    entry:<span class="string">'./src/main.js'</span>,</span><br><span class="line">    <span class="comment">//出口文件 即打包好的文件路径和文件名</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="package-json中自定义启动"><a href="#package-json中自定义启动" class="headerlink" title="package.json中自定义启动"></a>package.json中自定义启动</h1><p>来看一个package.json 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"meetwebpack"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:<span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"main"</span>:<span class="string">"index.js"</span>,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>:<span class="string">"webpack"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">"author"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"license"</span>:<span class="string">"ISC"</span>,</span><br><span class="line">    <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>:<span class="string">"^3.6.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每次执行都敲这么一长串webpack命令很不方便。OK，我们可以在package.json的scripts中定义自己的执行脚本。</p>
<p>&emsp;&emsp;package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<ul>
<li><p>首先，会寻找本地的node_modules/.bin路径中对应的命令。</p>
</li>
<li><p>如果没有找到，会去全局的环境变量中寻找。</p>
</li>
<li><p>如何执行我们的build指令呢?</p>
<blockquote>
<p>npm run build</p>
</blockquote>
</li>
</ul>
<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>&emsp;&emsp;<code>loader</code>是webpack中一个非常核心的概念。</p>
<p>&emsp;&emsp;在我们上面的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</p>
<p>&emsp;&emsp;但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</p>
<p>&emsp;&emsp;对于webpack本身的能力来说，对于这些转化是不支持的。那怎么办呢?给webpack扩展对应的loader就可以啦。</p>
<p>loader使用过程∶</p>
<ul>
<li>步骤一︰通过npm安装需要使用的loader</li>
<li>步骤二︰在webpack.config.js中的modules关键字下进行配置</li>
</ul>
<p>大部分loader我们都可以在<strong>webpack的官网</strong>中找到，并且学习对应的用法。</p>
<h2 id="webpack中使用css文件的配置"><a href="#webpack中使用css文件的配置" class="headerlink" title="webpack中使用css文件的配置"></a>webpack中使用css文件的配置</h2><p>&emsp;&emsp;我们想把所有的js/css文件都打包在bundle.js中，我们就需要在入口文件中添加相关的依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中添加</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./css/index.css'</span>)</span><br></pre></td></tr></table></figure>
<p>安装css-loader: 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</p>
<blockquote>
<p>npm install –save-dev css-loader</p>
</blockquote>
<p>安装style-loader: 将模块的导出作为样式添加到 DOM 中</p>
<blockquote>
<p>npm install –save-dev style-loader</p>
</blockquote>
<p>在<code>webpack.config.json</code> 的<code>module.exports</code>中添加如下配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入path模块，使用__dirname来拼接绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = reguire(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    entry:<span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">//css-loader只负责将css文件进行加裁</span></span><br><span class="line">            &#123;   <span class="comment">//匹配所有的css文件</span></span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">//css-loader只负责将css文件进行加载  style-loader将样式添加到 DOM 中</span></span><br><span class="line">                <span class="comment">//使用多个loader时，是从右向左，所以先加载css文件，css-loader写在右边</span></span><br><span class="line">                use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果在<code>package.json</code>中定义了<code>build</code>，那么现在就可以运行 <code>npm run build</code>进行打包了</p>
<h2 id="webpack中使用less文件的配置"><a href="#webpack中使用less文件的配置" class="headerlink" title="webpack中使用less文件的配置"></a>webpack中使用less文件的配置</h2><p>&emsp;&emsp;如果我们希望在项目中使Less、scss来写样式，webpack是否可以帮助我们处理呢?</p>
<p>&emsp;&emsp;我们这里以less为例，其他也是一样的。</p>
<p>我们还是先创建一个less文件index.less，依然放在css文件夹中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* index.less */</span></span><br><span class="line">@fontsize:50px;</span><br><span class="line">@fontColor:orange;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:@fontsize;</span><br><span class="line">    <span class="attribute">color</span>: @fontcolor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在入口文件main.js中添加依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中添加</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./css/index.less'</span>)</span><br></pre></td></tr></table></figure>
<p>安装less-roader</p>
<blockquote>
<p>npm install less-loader –save-dev</p>
</blockquote>
<p>在<code>webpack.config.js</code>的<code>module</code>的<code>rules</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">         use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h2><p>我们在index.css中引入一张图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"../img/test.jpg"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们采用url引入的图片，所以我们用url-roader</p>
<p>安装</p>
<blockquote>
<p>npm install url-loader –save-dev</p>
</blockquote>
<p>在<code>webpack.config.js</code>的<code>module</code>的<code>rules</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">//可以一个loader写成一个对象形式，这样方便我们添加参数如options</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">///当加载的图片，小于limit时，会将图片编译成base64字符串形式.limit可自行修改</span></span><br><span class="line">        <span class="comment">//当加载的图片，大于limit时，需要使用file-loader模块进行加载.npm安装就行，不需要配置</span></span><br><span class="line">        limit: <span class="number">8</span>*<span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题:因为url-loader默认使用es6模块化解析，而ihtml-loader引入图片是commonjs//解析时会出问题:[object Module]</span></span><br><span class="line">        <span class="comment">//解决:关闭ur1-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">        esModule: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是在html文件中使用img引入的图片，我们需要添加一个loader：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.html$ /</span>,</span><br><span class="line">    <span class="comment">//处理html文件的img图片（负责引入img，从而能被url-loader进行处理)</span></span><br><span class="line">    loader: <span class="string">'html-loader '</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们发现webpack在dist文件夹下自动帮助我们生成一个非常长的名字,这是一个32位hash值，目的是防止名字重复<br>&emsp;&emsp;但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>&emsp;&emsp;比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</p>
<p>所以，我们可以在options中添加上如下选项:</p>
<ul>
<li>img :文件要打包到的文件夹</li>
<li>name:获取图片原来的名字，放在该位置</li>
<li>hash:8:为了防止图片名称冲突，依然使用hash，但是我们只保留8位(8可选择其他)</li>
<li>ext:使用图片原来的扩展名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  limit: <span class="number">8192</span>,</span><br><span class="line">  name:<span class="string">'images/[name].[hash:8].[ext]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行<code>npm run build</code>。现在，我们就在dist下有一个images文件夹存放着我们刚刚打包的图片了</li>
</ul>
<h2 id="ES6语法处理-最新版浏览器可以忽略"><a href="#ES6语法处理-最新版浏览器可以忽略" class="headerlink" title="ES6语法处理(最新版浏览器可以忽略)"></a>ES6语法处理(最新版浏览器可以忽略)</h2><p>&emsp;&emsp;如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。<br>&emsp;&emsp;在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel.<br>&emsp;&emsp;而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<blockquote>
<p>npm install -D babel-loader @babel/core @babel/preset-es2015 webpack</p>
</blockquote>
<p>配置webpack.config.js文件下的rules</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">    <span class="comment">//exclude:排除</span></span><br><span class="line">    exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">       loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理其他资源"><a href="#处理其他资源" class="headerlink" title="处理其他资源"></a>处理其他资源</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理其他资源</span></span><br><span class="line">&#123;</span><br><span class="line">    exclude: <span class="regexp">/\.( html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">    loader: <span class="string">'file-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        limit: <span class="number">8192</span>,</span><br><span class="line">        name:<span class="string">'images/[name].[hash:8].[ext]'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="outputPath"><a href="#outputPath" class="headerlink" title="outputPath"></a>outputPath</h2><p>outputPath可以指定改文件打包完输出的路径，如：</p>
<p>```js<br>{<br>    exclude: /.( html|js|css|less|jpg|png|gif)/,<br>    loader: ‘file-loader’,<br>    options: {<br>        limit: 8192,<br>        name:’images/[name].[hash:8].[ext]’<br>    },<br>    //所有的loader都可以使用outputPath<br>    outputPath:’media’<br>}</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>grid布局</title>
    <url>/MyBlog/2020/09/08/grid%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="什么是grid布局？"><a href="#什么是grid布局？" class="headerlink" title="什么是grid布局？"></a>什么是grid布局？</h1><p>&emsp;&emsp;Flex布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<code>一维布局</code>，Grid布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<code>二维布局</code>，Grid布局远比 Flex布局强大.但是兼容性没有flex布局好</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>grid布局中有两个基本概念：</p>
<ul>
<li>容器</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E5%AE%B9%E5%99%A8.png" alt=""></p>
<ul>
<li>项目</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E9%A1%B9%E7%9B%AE.png" alt=""></p>
<ul>
<li>行、列</li>
</ul>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt=""></p>
<a id="more"></a>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><h2 id="grid-template-columns-rows"><a href="#grid-template-columns-rows" class="headerlink" title="grid-template-columns/rows"></a>grid-template-columns/rows</h2><p>&emsp;&emsp;你想要多少行或者列，就填写相应属性值的个数，不填写，自动分配</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指定列的数量和高度 */</span></span><br><span class="line"><span class="selector-tag">grid-template-columns</span> </span><br><span class="line"><span class="comment">/* 指定行的数量和高度 */</span></span><br><span class="line"><span class="selector-tag">grid-template-rows</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;来写个代码感受下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>= <span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-6"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-7"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-8"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-9"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-10"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再给每个div加上颜色，就有这样的效果：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gridcolunms.png" alt=""></p>
<p>如果我们想要让行元素也100px，那么就只要加上<code>grid-template-rows:100px 100px 100px 100px</code>.<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E5%AE%9E%E4%BE%8B.png" alt=""></p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>我们一直写很多px很麻烦，可以用<code>repeat()</code>来简写</p>
<p>repeat():第一个参数是<code>重复的次数</code>，第二个参数是所要<code>重复的值</code>,所以，上面grid布局的css可以写成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(<span class="number">3</span>,<span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(<span class="number">4</span>,<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="auto-fill"><a href="#auto-fill" class="headerlink" title="auto-fill"></a>auto-fill</h3><p>有时，单元格的大小是固定的，但是容器的大小不确定，这个属性就会自动填充。就是说多出来的空间下一行会自己往后面填</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill,<span class="number">100px</span>）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/autofill.png" alt=""></p>
<h3 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h3><p>为了方便表示<code>比例关系</code>，网格布局提供了fr关键字（fraction的缩写，意为”片段”)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="comment">/* 宽度平均分成3份 */</span></span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>，<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gridfr.png" alt=""></p>
<p>我们也可以不进行等分:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="comment">/* 宽度平均分成3份 */</span></span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr <span class="number">3</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/fr%E4%B8%8D%E7%AD%89%E5%88%86.png" alt=""></p>
<h3 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h3><p>函数产生一个长度范围，表示长度就在这个范围之中，它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="comment">/* 容器伸缩时左边的box为1fr，右边最大为1fr，最小为150px */</span></span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">150px</span>,<span class="number">1</span>fr);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid skyblue;</span><br><span class="line">    <span class="comment">/* 第一列100，第二列自适应，第三列100 */</span></span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gridauto.png" alt=""></p>
<h2 id="grid-row-gap-grid-column-gap"><a href="#grid-row-gap-grid-column-gap" class="headerlink" title="grid-row-gap/grid-column-gap"></a>grid-row-gap/grid-column-gap</h2><p>&emsp;&emsp;一话解释就是，item(项目）相互之间的距离</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gap.png" alt=""></p>
<p>注意:根据最新标准，上面三个属性名的<strong>grid-前缀已经删除</strong>,<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code></p>
<h2 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h2><p>一个区域由单个或多个单元格组成，由你决定(具体使用，需要在项目属性里面设置)</p>
<p>比如说，借用上一小节的图，我们可以写成这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="comment">/* 九个字母代表九个小格 */</span></span><br><span class="line">    <span class="attribute">grid-template-areas</span>:<span class="string">'a b c'</span> <span class="string">'d e f'</span> <span class="string">'g h i'</span>;</span><br><span class="line">    <span class="comment">/* 竖着写，123小格属于同一个区域 */</span></span><br><span class="line">    <span class="attribute">grid-template-areas</span>:<span class="string">'a a a'</span></span><br><span class="line">                        <span class="string">'b b b'</span></span><br><span class="line">                        <span class="string">'c c c'</span>;</span><br><span class="line">    <span class="comment">/* 区域不需要利用，则使用"点”(.)表示 */</span></span><br><span class="line">    <span class="attribute">grid-template-areas</span>:<span class="string">'a . c'</span></span><br><span class="line">                        <span class="string">'b . f'</span></span><br><span class="line">                        <span class="string">'g . i'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名<code>-start</code>，终止网格线自动命名为区域名<code>-end</code></p>
<h2 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h2><p>&emsp;&emsp;划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行(就是子元素的主轴方向)</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E4%B8%BB%E8%BD%B4.png" alt=""></p>
<p>*在grid-auto-flow中，还有一个属性叫<code>dense</code>,能帮我们自动填充剩余的空间</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/dense.png" alt=""></p>
<h2 id="justfy-items-align-items"><a href="#justfy-items-align-items" class="headerlink" title="justfy-items/align-items"></a>justfy-items/align-items</h2><p>&emsp;&emsp;justfy-items(水平方向)/align-items(垂直方向)设置单元格内容的水平和垂直对齐方式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">justfy-items:start(靠左) | end(靠右) | center(居中) | streth(铺满);</span><br><span class="line">align-items:start(靠左) | end(靠右) | center(居中) | streth(铺满);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>place-items</code>是<code>justfy-items</code>和<code>align-items</code>的简写,如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* justfy-items:center</span></span><br><span class="line"><span class="comment">align-items:center */</span></span><br><span class="line"><span class="selector-tag">place-items</span><span class="selector-pseudo">:center</span> <span class="selector-tag">center</span></span><br></pre></td></tr></table></figure>
<h2 id="justfy-content-align-content"><a href="#justfy-content-align-content" class="headerlink" title="justfy-content/align-content"></a>justfy-content/align-content</h2><p>&emsp;&emsp;justify-content(水平方向)/ align-content(垂直方向)设置<code>整个内容区域</code>的对齐方式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around I space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br></pre></td></tr></table></figure>
<h2 id="grid-auto-columns-grid-auto-rows"><a href="#grid-auto-columns-grid-auto-rows" class="headerlink" title="grid-auto-columns/grid-auto-rows"></a>grid-auto-columns/grid-auto-rows</h2><p>&emsp;&emsp;用来设置<code>多出来的</code>items宽和高</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%B9%E5%99%A8%E5%A4%9A%E5%87%BA%E6%9D%A5%E7%9A%84%E5%AE%BD%E5%92%8C%E9%AB%98.png" alt=""></p>
<h1 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h1><h2 id="grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="grid-column-start/grid-column-end/grid-row-start / grid-row-end"></a>grid-column-start/grid-column-end/grid-row-start / grid-row-end</h2><p>一句话解释，根据在哪根网格线用来指定item的具体位置.</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E7%BD%91%E6%A0%BC%E7%BA%BF.png" alt=""></p>
<p>上图中有两行属性，分别是<code>grid-column-start</code>和<code>grid-column-end</code>,但是这两个属性可以简写:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1/3表示从第一根网格线开始，第三根网格线结束，并不是三分之一 */</span></span><br><span class="line">grid-column:1 / 3;</span><br></pre></td></tr></table></figure>
<p>rows也同理：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/grid%E7%BD%91%E6%A0%BC%E6%94%B9.png" alt=""></p>
<h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>我们还可以用span属性，span属性代表<code>跨越几个网格</code><br>以上例子中的代码等价于</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-colunm-strat</span><span class="selector-pseudo">:span</span> 2 </span><br><span class="line"><span class="comment">/* 等价于</span></span><br><span class="line"><span class="comment">grid-column-start:1;</span></span><br><span class="line"><span class="comment">grid-column-end:3; */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">grid-colunm-end</span><span class="selector-pseudo">:span</span> 2 </span><br><span class="line"><span class="comment">/* 和grid-colunm-strat:span 2 等价 */</span></span><br></pre></td></tr></table></figure>

<h2 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h2><p>刚刚我们在容器属性中定义了<code>grid-template-areas</code>，现在我们可以定义<code>grid-area</code>来表示item在<code>grid-template-areas</code>中占了哪个区域,像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:<span class="string">'a a a'</span></span><br><span class="line">                        <span class="string">'b b b'</span></span><br><span class="line">                        <span class="string">'c c c'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>:b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/griditem.png" alt=""></p>
<h2 id="justify-self-align-self-place-self"><a href="#justify-self-align-self-place-self" class="headerlink" title="justify-self / align-self / place-self"></a>justify-self / align-self / place-self</h2><p>&ensp;&emsp;<code>justify-self</code>属性设置单元格内容的水平位置（左中右)，跟<code>justify-items</code>属性的用法完全一致，但只作用于<strong>单个项目(水平方向)</strong>,也就是说如果全局设置了<code>justify-items</code>，但是其中有某个项目想用一个其他的样式，就可以使用<code>justify-self</code></p>
<p>&ensp;&emsp;<code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于<strong>单个项目(垂直方向)</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-self: start | end | center | stretch;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js中字符串常用方法</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1、toLowerCase-把字符串转为小写，返回新的字符串。"><a href="#1、toLowerCase-把字符串转为小写，返回新的字符串。" class="headerlink" title="1、toLowerCase(): 把字符串转为小写，返回新的字符串。"></a>1、toLowerCase(): 把字符串转为小写，返回新的字符串。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toLowerCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h1 id="2、toUpperCase-把字符串转为大写，返回新的字符串。"><a href="#2、toUpperCase-把字符串转为大写，返回新的字符串。" class="headerlink" title="2、toUpperCase(): 把字符串转为大写，返回新的字符串。"></a>2、toUpperCase(): 把字符串转为大写，返回新的字符串。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//HELLO WORLD</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3、charAt-返回指定下标位置的字符。如果index不在0-str-length-不包含str-length-之间，返回空字符串。"><a href="#3、charAt-返回指定下标位置的字符。如果index不在0-str-length-不包含str-length-之间，返回空字符串。" class="headerlink" title="3、charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。"></a>3、charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charAt(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="4、charCodeAt-返回指定下标位置的字符的unicode编码-这个返回值是-0-65535-之间的整数。"><a href="#4、charCodeAt-返回指定下标位置的字符的unicode编码-这个返回值是-0-65535-之间的整数。" class="headerlink" title="4、charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。"></a>4、charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charCodeAt(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.charCodeAt(<span class="number">-2</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//101</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="5、indexOf-返回某个指定的子字符串在字符串中第一次出现的位置"><a href="#5、indexOf-返回某个指定的子字符串在字符串中第一次出现的位置" class="headerlink" title="5、indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置"></a>5、indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.indexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.indexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.indexOf(<span class="string">"o"</span>,str1+<span class="number">1</span>);<span class="comment">//注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//4 默认只找第一个关键字位置，从下标0开始查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1 没有找到</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="6、lastIndexOf-返回某个指定的子字符串在字符串中最后出现的位置。"><a href="#6、lastIndexOf-返回某个指定的子字符串在字符串中最后出现的位置。" class="headerlink" title="6、lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。"></a>6、lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.lastIndexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.lastIndexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.lastIndexOf(<span class="string">"o"</span>,str1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//注意：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="7、slice-返回字符串中提取的子字符串。"><a href="#7、slice-返回字符串中提取的子字符串。" class="headerlink" title="7、slice(): 返回字符串中提取的子字符串。"></a>7、slice(): 返回字符串中提取的子字符串。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.slice(<span class="number">2</span>); <span class="comment">//如果只有一个参数，则提取开始下标到结尾处的所有字符串</span></span><br><span class="line"><span class="keyword">var</span> str2=str.slice(<span class="number">2</span>,<span class="number">7</span>); <span class="comment">//两个参数，提取下标为2，到下标为7但不包含下标为7的字符串</span></span><br><span class="line"><span class="keyword">var</span> str3=str.slice(<span class="number">-7</span>,<span class="number">-2</span>); <span class="comment">//如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//llo W</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//o Wor</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="8、substring-提取字符串中介于两个指定下标之间的字符。"><a href="#8、substring-提取字符串中介于两个指定下标之间的字符。" class="headerlink" title="8、substring(): 提取字符串中介于两个指定下标之间的字符。"></a>8、substring(): 提取字符串中介于两个指定下标之间的字符。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substring(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substring(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substring(<span class="number">2</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//如果两个参数相等，返回长度为0的空串</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//llo W</span></span><br><span class="line"><span class="comment">//注意：substring()用法与slice()一样，但不接受负值的参数。</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="9、substr-返回从指定下标开始指定长度的的子字符串"><a href="#9、substr-返回从指定下标开始指定长度的的子字符串" class="headerlink" title="9、substr(): 返回从指定下标开始指定长度的的子字符串"></a>9、substr(): 返回从指定下标开始指定长度的的子字符串</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substr(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substr(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substr(<span class="number">-3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//ello World </span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//ell</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//rl</span></span><br><span class="line"><span class="comment">//注意：如果没有指定length,返回从下标开始处结尾处的所有字符串。</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="10、split-把字符串分割成字符串数组。"><a href="#10、split-把字符串分割成字符串数组。" class="headerlink" title="10、split(): 把字符串分割成字符串数组。"></a>10、split(): 把字符串分割成字符串数组。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"AA BB CC DD"</span>;</span><br><span class="line"><span class="keyword">var</span> string1=<span class="string">"1:2:3:4:5"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.split(<span class="string">""</span>);<span class="comment">//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割</span></span><br><span class="line"><span class="keyword">var</span> str2=str.split(<span class="string">" "</span>); <span class="comment">//以空格为分隔符</span></span><br><span class="line"><span class="keyword">var</span> str3=str.split(<span class="string">""</span>,<span class="number">4</span>); <span class="comment">//4指定返回数组的最大长度</span></span><br><span class="line"><span class="keyword">var</span> str4=string1.split(<span class="string">":"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//["AA" "BB" "CC" "DD"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//["A", "A", " ", "B"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str4); <span class="comment">// ["1", "2", "3", "4", "5"]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11、replace-在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。"><a href="#11、replace-在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。" class="headerlink" title="11、replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。"></a>11、replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello WORLD"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/o/ig</span>; <span class="comment">//o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。</span></span><br><span class="line"><span class="keyword">var</span> str1=str.replace(reg,<span class="string">"**"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hell** W**RLD</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12、match-返回所有查找的关键字内容的数组。"><a href="#12、match-返回所有查找的关键字内容的数组。" class="headerlink" title="12、match(): 返回所有查找的关键字内容的数组。"></a>12、match(): 返回所有查找的关键字内容的数组。</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"To be or not to be"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/to/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//["To", "to"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="string">"Hello"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>原文地址：<a href="https://www.cnblogs.com/Yimi/p/10362214.html" target="_blank" rel="noopener">JS字符串常用方法总结</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的原型和原型链</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>在ES6之前，面向对象是通过构造函数来实现的。构造函数的方法很好用，但是存在一个<strong>浪费内存</strong>的问题。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gouzaohanshu.png" alt=""></p>
<p>如图，每创建一个对象，都要开辟一个新的内存区域，<strong>我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？</strong></p>
<h1 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h1><a id="more"></a>
<p> &emsp;&emsp;构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。<br> &emsp;&emsp;JavaScript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。注意这个<code>prototype</code>就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。称为<strong><em>原型对象</em></strong></p>
<p> &emsp;&emsp;我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。这就是原型的作用</p>
<p> &emsp;&emsp;举个栗子<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决构造函数的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">star</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把sing方法挂载到原型上</span></span><br><span class="line">star.prototype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> star(<span class="string">'张学友'</span>, <span class="number">18</span>);</span><br><span class="line">ldh.sing()</span><br><span class="line">zxy.sing()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 proto"></a>对象原型 <strong>proto</strong></h1><p> &emsp;&emsp;对象都会有一个属性 <strong>proto</strong> 指向构造数的prototype原型对象，之 以我们对可以使用构造函数prototype原型对象的性和方法，就是因为对象 <strong>proto</strong>原型的存在。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ldh.__proto__===star.prototype);</span><br><span class="line"><span class="comment">//输出结果为true</span></span><br><span class="line"><span class="comment">//方法的查找规则：首先先看1dh对象身上是否有sing方法，如果有就执行这个对象上的sing</span></span><br><span class="line"><span class="comment">//如果么有sing这个方法，因为有_proto的存在，就去构造函数原型对象prototype身上去查找sing这个方法I</span></span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;proto对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/proto.png" alt=""></p>
<hr>
<h1 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h1><p>&emsp;&emsp;对象原型（ <em>proto</em> ）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(star.prototype.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(ldh.__proto__.constructor);</span><br><span class="line"><span class="comment">//输出的都是star这个构造函数</span></span><br></pre></td></tr></table></figure>
<p>当我们想在prototype上添加多个方法的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.prototype=&#123;</span><br><span class="line">    sing:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    movie:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会演电影'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个时候，protptype被完全覆盖掉了</strong><br>我们就要添加一个语句让prototype重新指回构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>: star</span><br><span class="line">//如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用<span class="keyword">constructor</span>指回原来的构造函数</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png" alt=""></p>
<hr>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>&emsp;&emsp;<strong>只要是对象就有_proto原型，指向原型对象</strong></p>
<p>一张图看懂原型链：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li><p>我们star原型对象里面的_proto_原型指向的是Object.prototype</p>
</li>
<li><p>我们object.prototype原型对象里面的_proto_原型指向为null</p>
</li>
</ul>
<hr>
<h1 id="JavaScript的成员查找机制（规则）"><a href="#JavaScript的成员查找机制（规则）" class="headerlink" title="JavaScript的成员查找机制（规则）"></a>JavaScript的成员查找机制（规则）</h1><ul>
<li><p>当访问一个对象的属性（包括方法）时，首先找这个<strong>对象自身</strong>有没有该属性。</p>
</li>
<li><p>如果没有就查找它的原型（也就是_proto_指向的（<strong>prototype原型对象</strong>）。</p>
</li>
<li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p>
</li>
<li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p>
</li>
</ul>
<hr>
<h1 id="原型对象中的this指向问题"><a href="#原型对象中的this指向问题" class="headerlink" title="原型对象中的this指向问题"></a>原型对象中的this指向问题</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.protptype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sing'</span>)</span><br><span class="line">    that = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment">//在构造函数中，里面this指向的是对象实例ldh</span></span><br><span class="line">ldh.sing();</span><br><span class="line"><span class="built_in">console</span>.log(that === <span class="keyword">this</span>) </span><br><span class="line"><span class="comment">//输出结果为true</span></span><br><span class="line"><span class="comment">//原型对象函数里面的this 指向的是实例对象ldh</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的闭包</title>
    <url>/MyBlog/2020/06/19/%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量根据作用域的不同分为两种:全局变量和局部变量。</p>
<ul>
<li>1.函数内部可以使用全局变量。</li>
<li>2.函数外部不可以使用局部变量。</li>
<li>3.当函数执行完毕,本作用域内的局部变量会销毁。</li>
</ul>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p><strong>闭包( closure )</strong>指有权访问另一个函数作用域中变量的<strong>函数</strong>。—– JavaScript 高级程序设计</p>
<p>通俗点说，闭包就是一个函数（一个作用域可以访问另一个函数的局部变量）</p>
<p>简单理解就是,一个作用域可以访问另外一个函数内部的局部变量。<strong><em>被访问的局部变量所在的函数我们成为闭包函数</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);<span class="comment">//fun()访问到了fn()中的局部变量，满足闭包条件，产生闭包</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(); </span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>让fn外面的作用域可以访问fn内部的局部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">    retuen fun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>我们可以简化一下写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line"><span class="comment">//相当于 var f = function()&#123;</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p><strong>闭包的主要作用：延伸了变量的作用域</strong></p>
<h1 id="闭包案例1"><a href="#闭包案例1" class="headerlink" title="闭包案例1"></a>闭包案例1</h1><p>闭包应用-点击li输出当前li的索引号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>大猪蹄子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>臭豆腐<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>鲱鱼罐头<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1.我们可以利用动态添加属性的方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span> ). querySelectorAll( <span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].index = i</span><br><span class="line">    lis[i] .onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(<span class="keyword">this</span>.index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.利用闭包方式得到 li 索引号<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用 for 循环创建了4个立即执行数</span></span><br><span class="line">    <span class="comment">// 立即执行函数 也称为小闭包  因立即执函数里面的任何一个函数都可使用他 的 i量</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;<span class="comment">//把当前循环到的i传入立即执行函数</span></span><br><span class="line">        <span class="comment">// console.log(i);</span></span><br><span class="line">        lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);<span class="comment">//这里必须写传入的参数，函数才能获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个例子中，点击事件触发的函数的i是从立即执行函数中获取来的，所以这个立即执行函数是一个闭包函数</span></span><br></pre></td></tr></table></figure>
需求更改：闭包应用-3秒钟之后，打印所有li 元素的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectornav.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(lis[i].innerHTML);</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="闭包案例2"><a href="#闭包案例2" class="headerlink" title="闭包案例2"></a>闭包案例2</h1></li>
<li>闭包应用-计算打车价格</li>
<li>打车起步价13（3公里内），之后每多一公里增加5块钱.用户输入公里数就可以计算打车价格</li>
<li>如果有拥堵情况，总价格多收取18块钱拥堵费<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">13</span>; <span class="comment">// 起步价 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>; <span class="comment">// 总价 局部变量</span></span><br><span class="line">        <span class="comment">// 正常的价格</span></span><br><span class="line">        price: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                total = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = start + (n <span class="number">3</span>) * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拥堵之后的价格</span></span><br><span class="line">        yd: <span class="function"><span class="keyword">function</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag ? total + <span class="number">1</span>: total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">5</span>)); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">true</span>)); <span class="comment">// 33</span></span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">1</span>)); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">false</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
price和yd函数用了立即执行函数中的局部变量，所以立即执行函数是一个闭包函数</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</span><br></pre></td></tr></table></figure>
<p>有点乱？不要急  我们来拆解一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f =robject.getNameFunc( );</span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">f(),即</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;()<span class="comment">//这是一个立即执行函数，this指向window 那么this中的name就是window全局作用域下的name</span></span><br><span class="line"><span class="comment">//输出the window</span></span><br></pre></td></tr></table></figure>
<p>这段代码中没有访问到局部变量，没有闭包产生</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span> ;<span class="comment">//此时，this指向object，即that=object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;<span class="comment">//that用了getNameFunc的局部变量，产生了闭包，这里getNameFunc是闭包函数</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log (object.getNameFunc()())<span class="comment">//my object</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的常用数组方法</title>
    <url>/MyBlog/2020/06/18/js%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>JavaScript中创建数组有两种方式</strong></p>
<ul>
<li>使用 Array 构造函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// 创建一个包含20项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(“lily”,“lucy”,“Tom”); <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
<li>使用数组字面量表示法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = []; <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">20</span>]; <span class="comment">// 创建一个包含1项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [“lily”,“lucy”,“Tom”]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数组的方法有数组原型方法，也有从object对象继承来的方法，这里我们只介绍数组的原型方法，数组原型方法主要有以下这些:</strong></p>
<a id="more"></a>
<h1 id="1、join"><a href="#1、join" class="headerlink" title="1、join()"></a>1、join()</h1><p>join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"-"</span>)); <span class="comment">// 1-2-3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2、push-和pop"><a href="#2、push-和pop" class="headerlink" title="2、push()和pop()"></a>2、push()和pop()</h1><ul>
<li>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</li>
<li>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack", "Sean"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Sean</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="3、shift-和-unshift"><a href="#3、shift-和-unshift" class="headerlink" title="3、shift() 和 unshift()"></a>3、shift() 和 unshift()</h1><ul>
<li>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。</li>
<li>unshift:将参数添加到原数组开头，并返回数组的长度 。<br>这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//["Jack", "Sean", "Lily", "lucy", "Tom"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Sean", "Lily", "lucy", "Tom"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="4、sort"><a href="#4、sort" class="headerlink" title="4、sort()"></a>4、sort()</h1><p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。<br>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort()); <span class="comment">// ["a", "b", "c", "d"]</span></span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [13, 24, 3, 51]</span></span><br><span class="line"><span class="comment">//[1,2,3,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [13, 24, 3, 51](原数组被改变)</span></span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>
<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [51, 24, 13, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果我们现再想在Vue实战中使用到sort写法，我们可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">'#app'</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                items:[<span class="number">20</span>,<span class="number">23</span>,<span class="number">18</span>,<span class="number">65</span>,<span class="number">32</span>,<span class="number">19</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">41</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            methods:&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> a-b</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            computed:&#123;</span><br><span class="line">                sortItems:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.items.sort(sortNumber);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="5、reverse"><a href="#5、reverse" class="headerlink" title="5、reverse()"></a>5、reverse()</h1><p>reverse()：反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); <span class="comment">//[3, 51, 24, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure>
<h1 id="6、concat"><a href="#6、concat" class="headerlink" title="6、concat()"></a>6、concat()</h1><p>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.concat(<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); <span class="comment">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure>
<p>从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrCopy2 = arr.concat([<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2); <span class="comment">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2[<span class="number">5</span>]); <span class="comment">//[11, 13]</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p>
<hr>
<h1 id="7、slice"><a href="#7、slice" class="headerlink" title="7、slice()"></a>7、slice()</h1><ul>
<li>slice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</li>
<li>使用 start（包含） 和 end（不包含） 参数来指定字符串提取的部分。</li>
<li>字符串中第一个字符位置为 0, 第二个字符位置为 1, 以此类推。</li>
</ul>
<p>提示： 如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取所有字符串:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//Hello world! </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置提取字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo world! </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置到第8个位置直接的字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo wo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只提取第1个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//H </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取最后一个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//!</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="8、splice"><a href="#8、splice" class="headerlink" title="8、splice()"></a>8、splice()</h1><p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。<br>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrRemoved = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved); <span class="comment">//[1, 3]</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 7, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved2); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved3); <span class="comment">//[7]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="9、indexOf-和-lastIndexOf"><a href="#9、indexOf-和-lastIndexOf" class="headerlink" title="9、indexOf()和 lastIndexOf()"></a>9、indexOf()和 lastIndexOf()</h1><ul>
<li>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的开头（位置 0）开始向后查找。</li>
<li>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>)); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>,<span class="number">2</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>,<span class="number">4</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">"5"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="10、forEach"><a href="#10、forEach" class="headerlink" title="10、forEach()"></a>10、forEach()</h1><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：value(每个元素)；index（该元素索引）；arry（该数组本身）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11、map"><a href="#11、map" class="headerlink" title="11、map()"></a>11、map()</h1><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>下面代码利用map方法实现数组中每个数求平方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12、filter"><a href="#12、filter" class="headerlink" title="12、filter()"></a>12、filter()</h1><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || value &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="13、every"><a href="#13、every" class="headerlink" title="13、every()"></a>13、every()</h1><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">10</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="14、some"><a href="#14、some" class="headerlink" title="14、some()"></a>14、some()</h1><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">1</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="15、reduce-和-reduceRight"><a href="#15、reduce-和-reduceRight" class="headerlink" title="15、reduce()和 reduceRight()"></a>15、reduce()和 reduceRight()</h1><ul>
<li>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</li>
<li>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</li>
<li>传给 reduce()和 reduceRight()的函数接收 4 个参数：<strong>前一个值</strong>、<strong>当前值</strong>、<strong>项的索引</strong>和<strong>数组对象</strong>。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</li>
</ul>
<p>下面代码用reduce()实现数组求和，数组一开始<strong>加了一个初始值10</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的学习使用</title>
    <url>/MyBlog/2020/06/12/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%86%B2%E5%86%B2%E5%86%B2/</url>
    <content><![CDATA[<h1 id="杨雨翔"><a href="#杨雨翔" class="headerlink" title="杨雨翔"></a>杨雨翔</h1><h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>

<ul>
<li>列表1</li>
<li>列表2<br>  a 子列表<br>  b 子列表</li>
<li>列表3</li>
</ul>
<hr>
<hr>
<p><a href="https://gitee.com/yang_yu_xiang">我的gitee导航</a><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/psb.jpg" alt="插入图片"></p>
<p><em>字体变成斜的</em><br><strong>字体加粗了呀</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>哈哈嘻嘻</code></p>
<blockquote>
<p>我的内容是引用的哈哈</p>
</blockquote>
<p><code>在视频连接中插入 class=&quot;bilibili&quot;</code></p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=286039785&bvid=BV1mf4y1y7pp&cid=202160057&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化规范</title>
    <url>/MyBlog/2020/07/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h1><p>&emsp;&emsp;CommonJS的核心思想是通过require方法来同步加载依赖的其他模块，通过module.exports导出需要暴露的接口。根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<h2 id="module-exports和require"><a href="#module-exports和require" class="headerlink" title="module.exports和require"></a>module.exports和require</h2><p>采用 CommonJS 导入及导出的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入 </span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span> (<span class="string">'./moduleA'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; test，demo，flag &#125; = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> _mA = <span class="built_in">require</span>(<span class="string">' moduleA '</span>);</span><br><span class="line"><span class="keyword">let</span> test = _mA.test;</span><br><span class="line"><span class="keyword">let</span> demo = _mA.demo;</span><br><span class="line"><span class="keyword">let</span> flag = _mA.f1ag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出  </span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    flag: <span class="literal">true</span>,</span><br><span class="line">    test(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;，</span><br><span class="line">    demo(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="exoprts"><a href="#exoprts" class="headerlink" title="exoprts"></a>exoprts</h2><p>&emsp;&emsp;为了方便，Node为每个模块提供一个<strong>exports变量</strong>，<strong>指向module.exports</strong>。这等同在每个模块头部，有一行这样的命令。</p>
<blockquote>
<p>let exports = module.exports;</p>
</blockquote>
<p><strong>这里要注意！！！</strong><br>&emsp;&emsp;不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exports = <span class="built_in">module</span>.exports</span><br><span class="line"><span class="keyword">let</span> appid = <span class="string">'123456'</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">exports = &#123;</span><br><span class="line">	appid</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">exports.appid = appid</span><br></pre></td></tr></table></figure>

<h1 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h1><p>&emsp;&emsp;ES6模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以一个个导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">'leo'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1,mum2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以一起导出，两种写法都一样</span></span><br><span class="line"><span class="keyword">let</span> name= <span class="string">'leo'</span>;</span><br><span class="line"><span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,mum2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里为增强写法，原写法为name:name,age:age</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    name, </span><br><span class="line">    age,</span><br><span class="line">    sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入多个导出  名字必须为export的名字</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age ,sum&#125; <span class="keyword">from</span> <span class="string">'./模块名'</span> </span><br><span class="line"><span class="comment">//导入模块的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化多个导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mydata <span class="keyword">from</span> <span class="string">'./模块名'</span></span><br><span class="line"><span class="built_in">console</span>.log(mydata.name)</span><br><span class="line"><span class="built_in">console</span>.log(mydata.age)</span><br><span class="line"><span class="built_in">console</span>.log(mydata.sum(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="default-export"><a href="#default-export" class="headerlink" title="default export"></a>default export</h2><p>&emsp;&emsp;某些情况下，一个模块中包含某个的功能，在别的地方导入时必须以导出的名字命名，我们并不希望给这个功能命名，而且让导入者可以自己来按自己的想法命名。这个时候就可以使用export default</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="keyword">const</span> address =<span class="string">'福州市'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> address</span><br><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">'./模块名'</span><span class="comment">//可以不使用address</span></span><br><span class="line"><span class="built_in">console</span>.log(addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导入函数</span></span><br><span class="line"><span class="keyword">import</span> myfun <span class="keyword">from</span> <span class="string">'./模块名'</span></span><br><span class="line">myfun(<span class="string">'你好啊'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意！！！</strong></p>
<p>export default在同一个模块中，<strong>不允许同时存在多个</strong>。因为这样，导入的时候就不知道你命名的到底是哪个导出的东西。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化规范</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/MyBlog/2020/08/16/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul>
<li><strong>浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用。</strong></li>
</ul>
<p>来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们有个Object对象，我想把这个对象拷贝给另一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'andy'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="comment">//k是属性名   obj[k]是属性值</span></span><br><span class="line">    o[k]= obj[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure>
<p>这样就输出了obj中的值，但是如果我们有更深的一层数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'andy'</span></span><br><span class="line">    <span class="comment">//对象里面还有个对象</span></span><br><span class="line">    msg:&#123;</span><br><span class="line">        age:<span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="comment">//k是属性名   obj[k]是属性值</span></span><br><span class="line">    o[k]= obj[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure>
<p>这样拷贝虽然能拷贝成功输出msg，但是拷贝的是msg的地址。所以obj的msg和o的msg指向的是同一条数据，做个测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.msg.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(o.msg.age)<span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.msg.age)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>ES6中，为我们增加了浅拷贝的语法糖</p>
<blockquote>
<p>Object.assign(拷贝给谁，拷贝哪个对象)</p>
</blockquote>
<p>我们把上面的例子用语法糖的方法改写一下，就不需要for循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把obj对象浅拷贝给o</span></span><br><span class="line"><span class="built_in">Object</span>.assign(o,obj)</span><br></pre></td></tr></table></figure>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li><strong>深拷贝拷贝多层,每一级别的数据都会拷贝。</strong></li>
</ul>
<p>我们可以通过函数递归的方式来一层一层循环赋值，来实现深拷贝，我们可以封装一个<code>deepCopy</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'andy'</span>,</span><br><span class="line">    <span class="comment">//对象里面还有个对象</span></span><br><span class="line">    msg:&#123;</span><br><span class="line">        age:<span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    color:[<span class="string">'pink'</span>,<span class="string">'red'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newobj,oldobj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj) &#123;</span><br><span class="line">        <span class="comment">//判断我们的属性值属于那种数据类型</span></span><br><span class="line">        <span class="comment">// 1．获取属性值oldobj[k]</span></span><br><span class="line">        <span class="keyword">var</span> item = oldobj[k];</span><br><span class="line">        <span class="comment">// 2．判断这个值是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            newobj[k] = [];</span><br><span class="line">            deepCopy(newobj[k],item)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">            <span class="comment">// 3．判断这个值是否是对象</span></span><br><span class="line">            newobj[k]=&#123;&#125;;</span><br><span class="line">            deepCopy(newobj[k],item)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//属于简单数据类型</span></span><br><span class="line">            newobj[k] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o,obj)</span><br></pre></td></tr></table></figure>
<p>这样，我修改o中的msg中的值或者color中的值，obj不会受到影响</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解js的防抖和节流</title>
    <url>/MyBlog/2020/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>&emsp; 防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，处理不当或者放任不管就容易会加重浏览器和服务器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 </p>
<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p><code>函数防抖（debounce）</code>：当<strong>持续触发事件</strong>时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就<strong>重新开始延时</strong>。</p>
<p>一起来实现个简单的debounce</p>
<a id="more"></a>
<h2 id="防抖debounce代码："><a href="#防抖debounce代码：" class="headerlink" title="防抖debounce代码："></a>防抖debounce代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">"debounce"</span>);</span><br><span class="line">    myDebounce.addEventListener(<span class="string">"click"</span>,debounce(sayDebounce));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖功能函数，接受传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//每次当用户点击、输入的时候，把前一个定时器消除</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">//创建一个新的setTimeout，这样能保证点击按钮后的间隔内，</span></span><br><span class="line">        <span class="comment">//如果用户还点击的话，就不会执行fn函数</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖事件的处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p><code>函数节流（throttle）</code>：当<strong>持续触发事件</strong>时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如<strong>持续触发scroll事件时，并不立即执行scroll事件触发的函数，每隔一定时间才会执行一次scorll事件触发的函数</strong>。</p>
<h2 id="节流throttle代码（定时器）："><a href="#节流throttle代码（定时器）：" class="headerlink" title="节流throttle代码（定时器）："></a>节流throttle代码（定时器）：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">"throttle"</span>);</span><br><span class="line">    myThrottle.addEventListener(<span class="string">"click"</span>,throttle(sayThrottle));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在函数开头判断标志是否为true，不为true则中断函数</span></span><br><span class="line">        <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将canRun设置为false，防止执行之前再被执行</span></span><br><span class="line">        canRun  = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//定时器</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">//执行完事件(例如调用完接口)之后，重新将这个标志设true</span></span><br><span class="line">            canRun  = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要节流的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h1><p>讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景：</p>
<ul>
<li>搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。</li>
<li>页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）</li>
</ul>
<p>参考文章：<a href="https://segmentfault.com/a/1190000018428170" target="_blank" rel="noopener">浅谈js的防抖和节流</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域处理方法</title>
    <url>/MyBlog/2020/09/06/%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Node配置CORS"><a href="#Node配置CORS" class="headerlink" title="Node配置CORS"></a>Node配置CORS</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req,res，next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//请求源ajax http://localhost:8080</span></span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>，<span class="string">"*"</span>);</span><br><span class="line">    <span class="number">1</span>/请求头―x-token</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Headers"</span>,<span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//请求方法get post put del</span></span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Methods"</span>，<span class="string">"*"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(allowCrossDomain);</span><br></pre></td></tr></table></figure>

<h1 id="使用webpack代理"><a href="#使用webpack代理" class="headerlink" title="使用webpack代理"></a>使用webpack代理</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;//代理</span><br><span class="line">        '/api': &#123;</span><br><span class="line">            target: 'http://localhost:3000',</span><br><span class="line">            pathRewrite: &#123;'/api':''&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在ajax的url中把<code>http://localhost:3000</code>替换为<code>/api</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/api/user'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>跨域</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>rem布局</title>
    <url>/MyBlog/2020/10/04/rem%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="常见移动web布局适配方法"><a href="#常见移动web布局适配方法" class="headerlink" title="常见移动web布局适配方法"></a>常见移动web布局适配方法</h1><ul>
<li>固定高度，宽度百分比：这种方法只适合简单要求不高的webApp，几乎达不到大型项目的要求，属于过时的方法。</li>
<li>Media Query（媒体查询）：现在比较主流的适配方案，比如我们常用的样式框架Bootstrap就是靠这个起家的，它能完成大部分项目需求，但是编写过于复杂。</li>
<li>flex布局：主流的布局方式，不仅适用于移动Web，网页上也表现良好，这也是现在工作中用的最多的布局方式，那我们的项目尽量采用flex+rem的方式进行布局和完成移动端的适配。</li>
</ul>
<h1 id="rem单位介绍"><a href="#rem单位介绍" class="headerlink" title="rem单位介绍"></a>rem单位介绍</h1><p>&emsp;&emsp;rem（font size of the root element）是相对长度单位。相对于根元素（即html元素）font-size计算值的倍数。<br>&emsp;&emsp;适配原理：将px替换成rem，动态修改html的font-size适配。它可以很好的根据根元素的字体大小来进行变化，从而达到各种屏幕基本一直的效果体验。<br>现在我们作一个实验，你可以新建一个网页，并写入如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span>Hello <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后给html一个基本的样式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: bisque;</span><br><span class="line">    <span class="attribute">text-align</span>: text；</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hello</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>&emsp;&emsp;上边我们使用了还是传统的使用px作为单位，我们在移动端调试模式iphone5环境查看一下。会发现div的宽度是正好的，我们再查看一下字体，发现大小是16px。</p>
<p>&emsp;&emsp;我们现在可以把CSS中的px单位换成rem单位来进行测试。因为html根元素的字体大小是16px，那么换成rem单位，直接除以16就好。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20rem</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">10rem</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">text-align</span>: text；</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hello</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;页面并没有什么变化，也就是说我们掌握了换算关系。为了更好的说明这点，我们可以试着给html根样式加入字体大小，比如换成font-size:32px;。这时页面和字体都扩大了一倍。但是我们现在还是不能实现适配，因为我们根元素的字体是固定的。</p>
<h1 id="JS控制适配屏幕"><a href="#JS控制适配屏幕" class="headerlink" title="JS控制适配屏幕"></a>JS控制适配屏幕</h1><p>&emsp;&emsp;明白了REM的原理后，我们就可以使用这个特点来进行适应布局了，这也是现在比较主流的移动端web适配方案。 三行JS代码完成适配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到手机屏幕的宽度</span></span><br><span class="line"><span class="keyword">let</span> htmlWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="comment">//得到html的Dom元素</span></span><br><span class="line"><span class="keyword">let</span> htmlDom = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//设置根元素字体大小</span></span><br><span class="line">htmlDom.style.fontSize= htmlWidth/<span class="number">20</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure>

<p>搞定啦</p>
<p>tips：补充个小知识。在进行移动端布局的时候，在<code>meta</code>属性的<code>content</code>中加入<code>user-scalable=no</code>,即禁止用户缩放</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定原理</title>
    <url>/MyBlog/2020/10/06/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>先放一张图，这是响应原理的实现思路</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.png" alt=""></p>
<ul>
<li><p>在new出来的 Vue对象中，我们定义<code>data</code>来存放我们的数据</p>
</li>
<li><p>在<code>Observer</code>对象中，我们通过<code>Object.defineProperty</code>来劫持所有的data属性。其实就是给每一个属性放进其对应的<code>Dep</code>对象。当数据发生改变时，调用<code>Dep</code>中的<code>notify</code>方法通知<code>watcher</code>执行<code>update()</code>方法做出改变</p>
</li>
<li><p>在<code>Dep</code>对象中，有一个<code>subs</code>数组，数组中存放着所有监听着这个数据的<code>data</code>对象(watcher)</p>
</li>
<li><p>在<code>Complite</code>对象中，我们通过<code></code>来解析el模板中的指令。在每个使用的地方创建一个<code>watcher</code>对象,并把这个对象放到<code>Dep</code>中</p>
<a id="more"></a>
<h1 id="前提概念"><a href="#前提概念" class="headerlink" title="前提概念"></a>前提概念</h1></li>
</ul>
<p>想要知道数据的变化过程,我们需要知道:</p>
<ul>
<li>侦测数据的变化</li>
<li>收集视图依赖了哪些数据</li>
<li>数据变化时，自动“通知”需要更新的视图部分，并进行更新</li>
</ul>
<p>对应专业俗语分别是：</p>
<ul>
<li>数据劫持 / 数据代理</li>
<li>依赖收集</li>
<li>发布订阅模式</li>
</ul>
<p>为什么我们修改的数据能被侦听到？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    username:<span class="string">'yang'</span>,</span><br><span class="line">    type:<span class="string">'帅'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们修改<code>“帅”</code>时，我们修改的数据能被侦听到。这是因为我们利用了<code>Object.defineProperty</code>定义属性，我们通过这个方法让<strong>一个</strong>对象的属性变成可侦测的 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = <span class="string">'厚脸皮'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">'type'</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">true</span>,<span class="comment">//定义此属性是否出现在for in循环,以及object.keys()的便利中</span></span><br><span class="line">    configurable:<span class="literal">true</span>,<span class="comment">//定义此属性可以配置和删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取数据的描述符</span></span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'现在在取type属性的数据'</span>)</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'现在在存type属性的数据,存入的值是：'</span>+newValue)</span><br><span class="line">        content = newValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取数据</span></span><br><span class="line"><span class="keyword">let</span> str = user.type</span><br><span class="line"><span class="comment">//存数据</span></span><br><span class="line">user.type = <span class="string">'有钱'</span></span><br></pre></td></tr></table></figure>

<h1 id="侦测对象的所有属性"><a href="#侦测对象的所有属性" class="headerlink" title="侦测对象的所有属性"></a>侦测对象的所有属性</h1><p>现在，我们让一个对象的属性变成可侦测的，那么怎么让<strong>所有</strong>对象的属性都变成可侦测的呢？</p>
<p>我们可以通过定义一个<code>Observer</code>类，使用<strong>递归</strong>的方式让对象的所有属性变成可侦测的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们现在把user对象变成可侦测的，首先定义一个Observer类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">            <span class="comment">//value是数组的时候，用数组的侦听方式</span></span><br><span class="line">        &#125;elseif</span><br><span class="line">            <span class="comment">//当value是对象的时候调用walk实现循环侦测属性</span></span><br><span class="line">            <span class="keyword">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    walk(obj)&#123;</span><br><span class="line">        <span class="comment">//获取对象的所有属性列表</span></span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;keys.length;i++)&#123;</span><br><span class="line">            dedefineReactive(obj,key[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>)</span>&#123;<span class="comment">//对象，属性，改变的值(上个例子中的content)</span></span><br><span class="line">    <span class="comment">//当只传入2个值的时候，可以通过obj[key]直接获取到第三个参数value值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</span><br><span class="line">        value = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果属性的值value也是对象，那么也需要将其变为可侦测</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,<span class="comment">//定义此属性是否出现在for in循环,以 及object.keys()的便利中</span></span><br><span class="line">        configurable:<span class="literal">true</span>,<span class="comment">//定义此属性可以配置和删除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取数据的描述符</span></span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`现在在取<span class="subst">$&#123;key&#125;</span>属性的数据`</span>)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value===newValue)&#123;</span><br><span class="line">                <span class="comment">//值没变化，不做处理</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`现在在存<span class="subst">$&#123;key&#125;</span>属性的数据,存入的值是：`</span>+newValue)</span><br><span class="line">            value = newValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    username:<span class="string">'yang'</span>,</span><br><span class="line">    type:<span class="string">'帅'</span></span><br><span class="line">    friend:&#123;</span><br><span class="line">        username:<span class="string">'隔壁老王'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> Observer(user)</span><br></pre></td></tr></table></figure>

<h1 id="订阅者Dep"><a href="#订阅者Dep" class="headerlink" title="订阅者Dep"></a>订阅者Dep</h1><p>Dep收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep,它用来收集依赖、删除依赖和向依赖发送消息等。</p>
<p>于是我们先来实现一个订阅者 Dep 类，用于解耦属性的依赖收集和派发更新操作，说得具体点，它的主要作用是用来存放 Watcher 观察者对象。我们可以把<strong>Watcher理解成一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。</strong></p>
<p>Dep的简单实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要做两件事情：</p>
<ul>
<li>用 <code>addSub</code>方法可以在目前的 Dep 对象中增加一个<code>Watcher</code> 的订阅操作；</li>
<li>用 <code>notify</code> 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。<br>所以当需要依赖收集的时候调用 addSub，当需要派发更新的时候调用notify。调用也很简单：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">dp.addSub(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'emit here'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">dp.notify()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="观察者Watcher"><a href="#观察者Watcher" class="headerlink" title="观察者Watcher"></a>观察者Watcher</h1><p>当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch,这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方。</p>
<p>Watcher的简单实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;   </span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">      update() &#123;</span><br><span class="line">        <span class="comment">// 获得新值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="comment">// 我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图</span></span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>项目优化策略</title>
    <url>/MyBlog/2020/10/08/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="为开发模式与发布模式指定不同的打包入口"><a href="#为开发模式与发布模式指定不同的打包入口" class="headerlink" title="为开发模式与发布模式指定不同的打包入口"></a>为开发模式与发布模式指定不同的打包入口</h1><p>&emsp;&emsp;默认情况下，Vue项目的开发模式与发布模式，共用同一个打包的入口文件(<strong>即src/main.js</strong>)。为了将项目的开发过程与发布过程分离，我们可以为两种模式，各自指定打包的入口文件。</p>
<ul>
<li>开发模式的入口文件为src/main-dev.js</li>
<li>发布模式的入口文件为src/main-prod.js</li>
</ul>
<p>在<code>vue.config.js</code>导出的配置对象中，我们可以新增<code>configureWebpack</code>或<code>chainWebpack</code>节点，来自定义webpack的打包配置</p>
<p>在这里,configureWebpack和chainWebpack的作用相同，唯一的区别就是它们修改webpack配置的方式不同:</p>
<ul>
<li>chainWebpack通过<code>链式编程</code>的形式，来修改默认的webpack配置</li>
<li>configureWebpack通过<code>操作对象</code>的形式，来修改默认的webpack配置</li>
</ul>
<p>我们先删除main.js,把内容复制到<code>main-dev.js</code>和<code>main-prod.js</code>中<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/mainprodjs.png" alt=""></p>
<p>下面通过chainWebpack自定义打包入口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.exports暴露配置对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//chainwebpack声明了一个配置节点，config接收默认webpack配置对象</span></span><br><span class="line">    chainwebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断产品处于什么模式</span></span><br><span class="line">        config.when(process.env.NODE_ENV=== <span class="string">'production'</span>,config=&gt;&#123;</span><br><span class="line">            <span class="comment">//.entry得到默认的打包入口，clear清空默认的打包入口，add新增自己的打包入口</span></span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'development'</span>,config=&gt;&#123;</span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在发布阶段的修改就可以在<code>main-prod.js</code>中进行</p>
<a id="more"></a>

<h1 id="通过externals加载外部CDN资源"><a href="#通过externals加载外部CDN资源" class="headerlink" title="通过externals加载外部CDN资源"></a>通过externals加载外部CDN资源</h1><p>&emsp;&emsp;默认情况下，通过import语法导入的第三方依赖包，最终会被<strong>打包合并到同一个文件</strong>中，从而导致打包成功后，单文件体积过大的问题。<br>&emsp;&emsp;为了解决上述问题，可以通过webpack的<code>externals</code>节点，来配置并加载外部的CDN资源。凡是声明在externals中的第三方依赖包，都不会被打包。</p>
<p>具体配置代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在vue.config.js的发布模式中</span></span><br><span class="line">config.when(process.env.NODE_ENV=== <span class="string">'production'</span>,config=&gt;&#123;</span><br><span class="line">    <span class="comment">//修改打包入口</span></span><br><span class="line">    config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-projs'</span>)</span><br><span class="line">    <span class="comment">//主要代码</span></span><br><span class="line">    config.set(<span class="string">'externals'</span>,&#123;</span><br><span class="line">        vue:<span class="string">'vue'</span>,</span><br><span class="line">        <span class="string">'vue-router'</span>:<span class="string">'VueRouter'</span>,</span><br><span class="line">        axios: <span class="string">'axios'</span>,</span><br><span class="line">        echarts: <span class="string">'echarts'</span> ,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>同时，需要在<code>public/index.html</code>文件的头部，添加如下的CDN资源引用:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/vue/2.5.22/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://edn.staticfile.org/vue-router/3.0.1/ve-router.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/axios/0.18.0/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注意：如果有css资源也需要并且可以CDN引入的，也需要引入 --&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="通过CDN优化Element-UI的打包"><a href="#通过CDN优化Element-UI的打包" class="headerlink" title="通过CDN优化Element UI的打包"></a>通过CDN优化Element UI的打包</h1><p>&emsp;&emsp;ElementUI打包完体积也很大，但是配置稍微有点不一样，单独开一个大标题讲.由于体积问题，elementui是按需加载的，但是用了CDN我们就不需要按需加载，能很快的把elementui的所有资源都拿过来，所以操作流程如下：</p>
<ul>
<li>在main-prod.js中，注释掉element-ui按需加载的代码</li>
<li>在index.html的头部区域中，通过CDN加载element-ui的js和css样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- element-ui 的样式表文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- element-ui的js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/element-ui/2.8.2/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以把按需加载elementui的地方注释或删除掉了</p>
<h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>&emsp;&emsp;当打包构建项目时，JavaScript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>具体需要3步:</p>
<ul>
<li>安装<code>@babel/plugin-syntax-dynamic-import</code>包。</li>
<li>在<code>babel.config.js</code>配置文件中声明该插件。</li>
<li>将路由改为按需加载的形式，示例代码如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import中的内容为路由分组/路由组件存放路径</span></span><br><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo"*/</span> <span class="string">'./Foo.vue'</span> )</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackchunkName: "group-foo"*/</span> <span class="string">'./Bar.vue'</span> )</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-boo"*/</span> <span class="string">'./Baz.vue'</span>)</span><br><span class="line"><span class="comment">//Foo和Bar在同一个分组，打包后会被放到同一个js文件中，请求其中一个路由时，另一个也会顺便被请求回来</span></span><br></pre></td></tr></table></figure>
<p>然后，我们把普通的import导入方式删除就行了</p>
<p>具体参考链接：<br><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p>
<h1 id="通过优化css包并将其从js中分离"><a href="#通过优化css包并将其从js中分离" class="headerlink" title="通过优化css包并将其从js中分离"></a>通过优化css包并将其从js中分离</h1><p>详见 <a href="http://yang_yu_xiang.gitee.io/myblog/2020/07/30/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">Webpack（二）</a>中mode的生产模式中的优化策略</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接的三次握手与四次挥手</title>
    <url>/MyBlog/2020/10/23/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>&emsp;&emsp;客户端与服务器之间数据的发送和返回的过程当中需要创建一个叫<code>TCP connection</code>的东西；由于TCP不存在连接的概念，只存在请求和响应，请求和响应都是数据包，它们之间都是经过由TCP创建的一个从客户端发起，服务器接收的类似连接的通道，这个连接可以一直保持，http请求是在这个连接的基础上发送的。<br>在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样。</p>
<ul>
<li>在HTTP/1.0中这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，服务器端响应了之后，这个TCP连接就关闭了；</li>
<li>HTTP/1.1中可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。</li>
</ul>
<p>&emsp;&emsp;如果TCP连接保持，第二个请求发送就没有这“三次握手”的消耗。HTTP/2中同一个TCP连接里还可以并发地传输http请求。</p>
<h1 id="TCP报文格式简介"><a href="#TCP报文格式简介" class="headerlink" title="TCP报文格式简介"></a>TCP报文格式简介</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/TCp.png" alt=""></p>
<p>其中比较重要的字段有：</p>
<p> (1)序号 (sequence number )：Seq序号,占32位,用来标识从TCP源端向目的端发送的字节流,发起方发送数据时对此进行标记。</p>
<p> (2)确认号 (acknowledgement number )：Ack序号,占32位,只有ACK标志位为1时,确认序号字段才有效,Ack=Seq+1。</p>
<p> (3)标志位 (Flags )：共6个,即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p>
<ul>
<li>URG：紧急指针 (urgent pointer )有效。</li>
<li>ACK：确认序号有效。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
</ul>
<h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p>&emsp;&emsp;所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
<h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><ul>
<li>第一次：客户端发送初始序号x和syn=1请求标志</li>
<li>第二次：服务器发送请求标志syn，发送确认标志ACK，发送自己的序号seq=y，发送客户端的确认序号ack=x+1</li>
<li>第三次：客户端发送ACK确认号，发送自己的序号seq=x+1，发送对方的确认号ack=y+1</li>
</ul>
<h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><p>&emsp;&emsp;譬如发起请求遇到类似这样的情况：客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。<br>&emsp;&emsp;如果只有两次握手，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，因为这是一个已经废弃的请求，而服务端还在傻傻的等候佳音，造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><h2 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h2><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p>
<ul>
<li>第一次：由客户端向服务端发起，发送FIN,seq=u。<strong>服务端收到信息后就能确定客户端已经停止发送数据</strong>。</li>
<li>第二次：由服务端向客户端发起，<strong>客户端收到消息后就能确定服务端已经知道客户端不会再发送数据</strong>。发送ACK,ack=u+1,seq=v</li>
<li>第三次：服务器请求断开。由服务端向客户端发起，<strong>客户端收到消息后就能确定服务端已经停止发送数据</strong>。FIN,seq=w,ACK,ack=u+1</li>
<li>第四次：由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。<strong>客户端确认服务器的断开</strong>ACK,ack=w+1,seq=u+1</li>
</ul>
<h2 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h2><p>在客服端第1次挥手时，服务端可能还在发送数据。所以第2次挥手和第3次挥手不能合并。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack（三） devServer</title>
    <url>/MyBlog/2020/10/24/Webpack%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;在Webpack中，除了<code>entry、output、module、plugins、mode</code>这五大部分，我们还有一个部分是<code>devServer</code>(开发服务器)，它的作用是用来自动化（自动编译，自动打开浏览器，自动刷新浏览器，设置代理)等。</p>
<p>在启动之前，我们需要下载包</p>
<blockquote>
<p>npm install webpack-dev-server -D</p>
</blockquote>
<p>配置如下</p>
<pre><code class="js"><span class="built_in">module</span>.exports = {
    entry: <span class="string">'./ src/index.js '</span>,
    output: {},
    <span class="built_in">module</span>: {},
    plugins:[],
    mode: <span class="string">'development'</span>,

    <span class="comment">//启动devServer指令为:npx webpack-dev-server</span>
    <span class="comment">//特点:只会在内存中编译打包，不会有任何输出。即build文件在内存中给你弄好，原本的文件夹中不会出现build文件夹</span>

    devserver:{
        <span class="comment">//要运行的项目的根目录</span>
        contentBase: resolve(__dirname,<span class="string">' build'</span>),
        <span class="comment">//启动gzip压缩</span>
        compress:<span class="literal">true</span>,
        <span class="comment">//指定端口号</span>
        port:<span class="number">3000</span>,
        <span class="comment">//编译完成自动打开浏览器</span>
        open:<span class="literal">true</span>
    }
};

</code></pre>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
