<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js中字符串常用方法</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>1、toLowerCase(): 把字符串转为小写，返回新的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toLowerCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<p>2、toUpperCase(): 把字符串转为大写，返回新的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//HELLO WORLD</span></span><br></pre></td></tr></table></figure>
<hr>
<p>3、charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charAt(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>4、charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.charCodeAt(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.charCodeAt(<span class="number">-2</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//101</span></span><br></pre></td></tr></table></figure>
<hr>
<p>5、indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.indexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.indexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.indexOf(<span class="string">"o"</span>,str1+<span class="number">1</span>);<span class="comment">//注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//4 默认只找第一个关键字位置，从下标0开始查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1 没有找到</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<hr>
<p>6、lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.lastIndexOf(<span class="string">"o"</span>);</span><br><span class="line"><span class="keyword">var</span> str2=str.lastIndexOf(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.lastIndexOf(<span class="string">"o"</span>,str1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//注意：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>7、slice(): 返回字符串中提取的子字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.slice(<span class="number">2</span>); <span class="comment">//如果只有一个参数，则提取开始下标到结尾处的所有字符串</span></span><br><span class="line"><span class="keyword">var</span> str2=str.slice(<span class="number">2</span>,<span class="number">7</span>); <span class="comment">//两个参数，提取下标为2，到下标为7但不包含下标为7的字符串</span></span><br><span class="line"><span class="keyword">var</span> str3=str.slice(<span class="number">-7</span>,<span class="number">-2</span>); <span class="comment">//如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//llo W</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//o Wor</span></span><br></pre></td></tr></table></figure>
<hr>
<p>8、substring(): 提取字符串中介于两个指定下标之间的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substring(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substring(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substring(<span class="number">2</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//llo World</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//如果两个参数相等，返回长度为0的空串</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//llo W</span></span><br><span class="line"><span class="comment">//注意：substring()用法与slice()一样，但不接受负值的参数。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>9、substr(): 返回从指定下标开始指定长度的的子字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.substr(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> str2=str.substr(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> str3=str.substr(<span class="number">-3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//ello World </span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//ell</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//rl</span></span><br><span class="line"><span class="comment">//注意：如果没有指定length,返回从下标开始处结尾处的所有字符串。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>10、split(): 把字符串分割成字符串数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"AA BB CC DD"</span>;</span><br><span class="line"><span class="keyword">var</span> string1=<span class="string">"1:2:3:4:5"</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.split(<span class="string">""</span>);<span class="comment">//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割</span></span><br><span class="line"><span class="keyword">var</span> str2=str.split(<span class="string">" "</span>); <span class="comment">//以空格为分隔符</span></span><br><span class="line"><span class="keyword">var</span> str3=str.split(<span class="string">""</span>,<span class="number">4</span>); <span class="comment">//4指定返回数组的最大长度</span></span><br><span class="line"><span class="keyword">var</span> str4=string1.split(<span class="string">":"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//["AA" "BB" "CC" "DD"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">//["A", "A", " ", "B"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str4); <span class="comment">// ["1", "2", "3", "4", "5"]</span></span><br></pre></td></tr></table></figure>
<hr>
<p>11、replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello WORLD"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/o/ig</span>; <span class="comment">//o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。</span></span><br><span class="line"><span class="keyword">var</span> str1=str.replace(reg,<span class="string">"**"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//hell** W**RLD</span></span><br></pre></td></tr></table></figure>
<hr>
<p>12、match(): 返回所有查找的关键字内容的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"To be or not to be"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/to/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str1=str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//["To", "to"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="string">"Hello"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>原文地址：<a href="https://www.cnblogs.com/Yimi/p/10362214.html" target="_blank" rel="noopener">JS字符串常用方法总结</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/MyBlog/2020/06/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>js中的原型和原型链</title>
    <url>/MyBlog/2020/06/16/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>在ES6之前，面向对象是通过构造函数来实现的。构造函数的方法很好用，但是存在一个<strong>浪费内存</strong>的问题。</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/gouzaohanshu.png" alt=""></p>
<p>如图，每创建一个对象，都要开辟一个新的内存区域，<strong>我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？</strong></p>
<h1 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h1><a id="more"></a>
<p> &emsp;&emsp;构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。<br> JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。称为<strong><em>原型对象</em></strong></p>
<p> &emsp;&emsp;我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。这就是原型的作用</p>
<p> &emsp;&emsp;举个栗子<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决构造函数的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">star</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把sing方法挂载到原型上</span></span><br><span class="line">star.prototype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> star(<span class="string">'张学友'</span>, <span class="number">18</span>);</span><br><span class="line">ldh.sing()</span><br><span class="line">zxy.sing()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型<strong>proto</strong></h1><p> &emsp;&emsp;对象都会有一个属性<strong>proto</strong>指向构造数的prototype原型对象，之 以我们对可以使用构造函数prototype原型对象的性和方法，就是因为对象 <strong>proto</strong>原型的存在。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(ldh.__proto__===star.prototype);</span><br><span class="line"> <span class="comment">//输出结果为true</span></span><br><span class="line"> <span class="comment">//方法的查找规则：首先先看1dh对象身上是否有sing方法，如果有就执行这个对象上的sing</span></span><br><span class="line"><span class="comment">//如果么有sing这个方法，因为有_proto的存在，就去构造函数原型对象prototype身上去查找sing这个方法I</span></span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;proto对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/proto.png" alt=""></p>
<hr>
<h1 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h1><p>&emsp;&emsp;对象原型（ <em>proto</em> ）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(star.prototype.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(ldh.__proto__.constructor);</span><br><span class="line"><span class="comment">//输出的都是star这个构造函数</span></span><br></pre></td></tr></table></figure>
<p>当我们想在prototype上添加多个方法的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.prototype=&#123;</span><br><span class="line">    sing:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会唱歌'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    movie:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会演电影'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个时候，protptype被完全覆盖掉了</strong><br>我们就要添加一个语句让prototype重新指回构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>: star</span><br><span class="line">//如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用<span class="keyword">constructor</span>指回原来的构造函数</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h1><p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png" alt=""></p>
<hr>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>&emsp;&emsp;<strong>只要是对象就有_proto原型，指向原型对象</strong></p>
<p>一张图看懂原型链：<br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li><p>我们star原型对象里面的_proto_原型指向的是Object.prototype</p>
</li>
<li><p>我们object.prototype原型对象里面的_proto_原型指向为null</p>
</li>
</ul>
<hr>
<h1 id="JavaScript的成员查找机制（规则）"><a href="#JavaScript的成员查找机制（规则）" class="headerlink" title="JavaScript的成员查找机制（规则）"></a>JavaScript的成员查找机制（规则）</h1><ul>
<li><p>当访问一个对象的属性（包括方法）时，首先找这个<strong>对象自身</strong>有没有该属性。</p>
</li>
<li><p>如果没有就查找它的原型（也就是_proto_指向的（<strong>prototype原型对象</strong>）。</p>
</li>
<li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p>
</li>
<li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p>
</li>
</ul>
<hr>
<h1 id="原型对象中的this指向问题"><a href="#原型对象中的this指向问题" class="headerlink" title="原型对象中的this指向问题"></a>原型对象中的this指向问题</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">star.protptype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sing'</span>)</span><br><span class="line">    that = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> star(<span class="string">'刘德华'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment">//在构造函数中，里面this指向的是对象实例ldh</span></span><br><span class="line">ldh.sing();</span><br><span class="line"><span class="built_in">console</span>.log(that === <span class="keyword">this</span>) </span><br><span class="line"><span class="comment">//输出结果为true</span></span><br><span class="line"><span class="comment">//原型对象函数里面的this 指向的是实例对象ldh</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的常用数组方法</title>
    <url>/MyBlog/2020/06/18/js%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>JavaScript中创建数组有两种方式</strong></p>
<ul>
<li>使用 Array 构造函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// 创建一个包含20项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(“lily”,“lucy”,“Tom”); <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
<li>使用数组字面量表示法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = []; <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">20</span>]; <span class="comment">// 创建一个包含1项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [“lily”,“lucy”,“Tom”]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数组的方法有数组原型方法，也有从object对象继承来的方法，这里我们只介绍数组的原型方法，数组原型方法主要有以下这些:</strong></p>
<a id="more"></a>
<h1 id="1、join"><a href="#1、join" class="headerlink" title="1、join()"></a>1、join()</h1><p>join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"-"</span>)); <span class="comment">// 1-2-3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2、push-和pop"><a href="#2、push-和pop" class="headerlink" title="2、push()和pop()"></a>2、push()和pop()</h1><ul>
<li>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</li>
<li>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack", "Sean"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Sean</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Lily", "lucy", "Tom", "Jack"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="3、shift-和-unshift"><a href="#3、shift-和-unshift" class="headerlink" title="3、shift() 和 unshift()"></a>3、shift() 和 unshift()</h1><ul>
<li>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。</li>
<li>unshift:将参数添加到原数组开头，并返回数组的长度 。<br>这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//["Jack", "Sean", "Lily", "lucy", "Tom"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["Sean", "Lily", "lucy", "Tom"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="4、sort"><a href="#4、sort" class="headerlink" title="4、sort()"></a>4、sort()</h1><p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。<br>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort()); <span class="comment">// ["a", "b", "c", "d"]</span></span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [13, 24, 3, 51]</span></span><br><span class="line"><span class="comment">//[1,2,3,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [13, 24, 3, 51](原数组被改变)</span></span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>
<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [51, 24, 13, 3]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="5、reverse"><a href="#5、reverse" class="headerlink" title="5、reverse()"></a>5、reverse()</h1><p>reverse()：反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); <span class="comment">//[3, 51, 24, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure>
<h1 id="6、concat"><a href="#6、concat" class="headerlink" title="6、concat()"></a>6、concat()</h1><p>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.concat(<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); <span class="comment">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure>
<p>从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrCopy2 = arr.concat([<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2); <span class="comment">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2[<span class="number">5</span>]); <span class="comment">//[11, 13]</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p>
<hr>
<h1 id="7、slice"><a href="#7、slice" class="headerlink" title="7、slice()"></a>7、slice()</h1><ul>
<li>slice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</li>
<li>使用 start（包含） 和 end（不包含） 参数来指定字符串提取的部分。</li>
<li>字符串中第一个字符位置为 0, 第二个字符位置为 1, 以此类推。</li>
</ul>
<p>提示： 如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取所有字符串:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//Hello world! </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置提取字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo world! </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串的第3个位置到第8个位置直接的字符串片段:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//lo wo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只提取第1个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//H </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取最后一个字符:</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> n=str.slice(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)<span class="comment">//!</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="8、splice"><a href="#8、splice" class="headerlink" title="8、splice()"></a>8、splice()</h1><p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。<br>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrRemoved = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved); <span class="comment">//[1, 3]</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 7, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved2); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved3); <span class="comment">//[7]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="9、indexOf-和-lastIndexOf"><a href="#9、indexOf-和-lastIndexOf" class="headerlink" title="9、indexOf()和 lastIndexOf()"></a>9、indexOf()和 lastIndexOf()</h1><ul>
<li>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的开头（位置 0）开始向后查找。</li>
<li>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>)); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>,<span class="number">2</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>,<span class="number">4</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">"5"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="10、forEach"><a href="#10、forEach" class="headerlink" title="10、forEach()"></a>10、forEach()</h1><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：value(每个元素)；index（该元素索引）；arry（该数组本身）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11、map"><a href="#11、map" class="headerlink" title="11、map()"></a>11、map()</h1><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>下面代码利用map方法实现数组中每个数求平方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12、filter"><a href="#12、filter" class="headerlink" title="12、filter()"></a>12、filter()</h1><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || value &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="13、every"><a href="#13、every" class="headerlink" title="13、every()"></a>13、every()</h1><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">10</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="14、some"><a href="#14、some" class="headerlink" title="14、some()"></a>14、some()</h1><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; <span class="number">1</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="15、reduce-和-reduceRight"><a href="#15、reduce-和-reduceRight" class="headerlink" title="15、reduce()和 reduceRight()"></a>15、reduce()和 reduceRight()</h1><ul>
<li>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</li>
<li>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</li>
<li>传给 reduce()和 reduceRight()的函数接收 4 个参数：<strong>前一个值</strong>、<strong>当前值</strong>、<strong>项的索引</strong>和<strong>数组对象</strong>。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</li>
</ul>
<p>下面代码用reduce()实现数组求和，数组一开始<strong>加了一个初始值10</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的学习使用</title>
    <url>/MyBlog/2020/06/12/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%86%B2%E5%86%B2%E5%86%B2/</url>
    <content><![CDATA[<h1 id="杨雨翔"><a href="#杨雨翔" class="headerlink" title="杨雨翔"></a>杨雨翔</h1><h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>

<ul>
<li>列表1</li>
<li>列表2<br>  a 子列表<br>  b 子列表</li>
<li>列表3</li>
</ul>
<hr>
<hr>
<p><a href="https://gitee.com/yang_yu_xiang">我的gitee导航</a><br><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/psb.jpg" alt="插入图片"></p>
<p><em>字体变成斜的</em><br><strong>字体加粗了呀</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>哈哈嘻嘻</code></p>
<blockquote>
<p>我的内容是引用的哈哈</p>
</blockquote>
<p><code>在视频连接中插入 class=&quot;bilibili&quot;</code></p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=286039785&bvid=BV1mf4y1y7pp&cid=202160057&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解js的防抖和节流</title>
    <url>/MyBlog/2020/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>&emsp; 防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，处理不当或者放任不管就容易会加重浏览器和服务器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 </p>
<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p><code>函数防抖（debounce）</code>：当<strong>持续触发事件</strong>时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就<strong>重新开始延时</strong>。</p>
<p>一起来实现个简单的debounce</p>
<a id="more"></a>
<h2 id="防抖debounce代码："><a href="#防抖debounce代码：" class="headerlink" title="防抖debounce代码："></a>防抖debounce代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">"debounce"</span>);</span><br><span class="line">    myDebounce.addEventListener(<span class="string">"click"</span>,debounce(sayDebounce));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖功能函数，接受传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//每次当用户点击、输入的时候，把前一个定时器消除</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">//创建一个新的setTimeout，这样能保证点击按钮后的间隔内，</span></span><br><span class="line">        <span class="comment">//如果用户还点击的话，就不会执行fn函数</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//防抖事件的处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p><code>函数节流（throttle）</code>：当<strong>持续触发事件</strong>时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如<strong>持续触发scroll事件时，并不立即执行scroll事件触发的函数，每隔一定时间才会执行一次scorll事件触发的函数</strong>。</p>
<h2 id="节流throttle代码（定时器）："><a href="#节流throttle代码（定时器）：" class="headerlink" title="节流throttle代码（定时器）："></a>节流throttle代码（定时器）：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取按钮并绑定事件</span></span><br><span class="line">    <span class="keyword">var</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">"throttle"</span>);</span><br><span class="line">    myThrottle.addEventListener(<span class="string">"click"</span>,throttle(sayThrottle));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在函数开头判断标志是否为true，不为true则中断函数</span></span><br><span class="line">        <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将canRun设置为false，防止执行之前再被执行</span></span><br><span class="line">        canRun  = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//定时器</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">//执行完事件(例如调用完接口)之后，重新将这个标志设true</span></span><br><span class="line">            canRun  = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要节流的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...有些需要防抖的工作，在这里进行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h1><p>讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景：</p>
<ul>
<li>搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。</li>
<li>页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）</li>
</ul>
<p>参考文章：<a href="https://segmentfault.com/a/1190000018428170" target="_blank" rel="noopener">浅谈js的防抖和节流</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的闭包</title>
    <url>/MyBlog/2020/06/19/%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量根据作用域的不同分为两种:全局变量和局部变量。</p>
<ul>
<li>1.函数内部可以使用全局变量。</li>
<li>2.函数外部不可以使用局部变量。</li>
<li>3.当函数执行完毕,本作用域内的局部变量会销毁。</li>
</ul>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p><strong>闭包( closure )</strong>指有权访问另一个函数作用域中变量的<strong>函数</strong>。—– JavaScript 高级程序设计</p>
<p>通俗点说，闭包就是一个函数（一个作用域可以访问另一个函数的局部变量）</p>
<p>简单理解就是,一个作用域可以访问另外一个函数内部的局部变量。<strong><em>被访问的局部变量所在的函数我们成为闭包函数</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);<span class="comment">//fun()访问到了fn()中的局部变量，满足闭包条件，产生闭包</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(); </span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>让fn外面的作用域可以访问fn内部的局部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">    retuen fun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>我们可以简化一下写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line"><span class="comment">//相当于 var f = function()&#123;</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p><strong>闭包的主要作用：延伸了变量的作用域</strong></p>
<h1 id="闭包案例1"><a href="#闭包案例1" class="headerlink" title="闭包案例1"></a>闭包案例1</h1><p>闭包应用-点击li输出当前li的索引号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>大猪蹄子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>臭豆腐<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>鲱鱼罐头<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1.我们可以利用动态添加属性的方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span> ). querySelectorAll( <span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].index = i</span><br><span class="line">    lis[i] .onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span><span class="number">.1</span>og(<span class="keyword">this</span>.index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.利用闭包方式得到 li 索引号<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用 for 循环创建了4个立即执行数</span></span><br><span class="line">    <span class="comment">// 立即执行函数 也称为小闭包  因立即执函数里面的任何一个函数都可使用他 的 i量</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;<span class="comment">//把当前循环到的i传入立即执行函数</span></span><br><span class="line">        <span class="comment">// console.log(i);</span></span><br><span class="line">        lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);<span class="comment">//这里必须写传入的参数，函数才能获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个例子中，点击事件触发的函数的i是从立即执行函数中获取来的，所以这个立即执行函数是一个闭包函数</span></span><br></pre></td></tr></table></figure>
需求更改：闭包应用-3秒钟之后，打印所有li 元素的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectornav<span class="string">').querySelectorAll('</span>li<span class="string">')</span></span><br><span class="line"><span class="string">for (var i = 0; i &lt; lis.length; i++) &#123;</span></span><br><span class="line"><span class="string">    (function(i) &#123;</span></span><br><span class="line"><span class="string">        setTimeout(function() &#123;</span></span><br><span class="line"><span class="string">            console.log(lis[i].innerHTML);</span></span><br><span class="line"><span class="string">        &#125;, 3000)</span></span><br><span class="line"><span class="string">    &#125;)(i);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="闭包案例2"><a href="#闭包案例2" class="headerlink" title="闭包案例2"></a>闭包案例2</h1></li>
<li>闭包应用-计算打车价格</li>
<li>打车起步价13（3公里内），之后每多一公里增加5块钱.用户输入公里数就可以计算打车价格</li>
<li>如果有拥堵情况，总价格多收取18块钱拥堵费<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">13</span>; <span class="comment">// 起步价 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>; <span class="comment">// 总价 局部变量</span></span><br><span class="line">        <span class="comment">// 正常的价格</span></span><br><span class="line">        price: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                total = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = start + (n <span class="number">3</span>) * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拥堵之后的价格</span></span><br><span class="line">        yd: <span class="function"><span class="keyword">function</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag ? total + <span class="number">1</span>: total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">5</span>)); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">true</span>)); <span class="comment">// 33</span></span><br><span class="line"><span class="built_in">console</span>.log(car.price(<span class="number">1</span>)); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(car.yd(<span class="literal">false</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
price和yd函数用了立即执行函数中的局部变量，所以立即执行函数是一个闭包函数</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</span><br></pre></td></tr></table></figure>
<p>有点乱？不要急  我们来拆解一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f =robject.getNameFunc( );</span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">f(),即</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;()<span class="comment">//这是一个立即执行函数，this指向window 那么this中的name就是window全局作用域下的name</span></span><br><span class="line"><span class="comment">//输出the window</span></span><br></pre></td></tr></table></figure>
<p>这段代码中没有访问到局部变量，没有闭包产生</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span> ;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My object"</span> ，</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span> ;<span class="comment">//此时，this指向object，即that=object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;<span class="comment">//that用了getNameFunc的局部变量，产生了闭包，这里getNameFunc是闭包函数</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log (object.getNameFunc()())<span class="comment">//my object</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Node中http请求与响应处理</title>
    <url>/MyBlog/2020/06/30/Node%E4%B8%ADhttp%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>首先，我们先来创建一个网站服务器</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/node%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt=""></p>
<p>其中，当有请求来的时候，会触发request这个事件，然后执行后面的事件处理函数。我们可以通过res.end对客户端进行响应</p>
<a id="more"></a>
<h1 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h1><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><ul>
<li>Get请求数据</li>
<li>Post请求数据<h2 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h2><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80.png" alt=""><br>我们可以通过<code>req.url</code>来获取客户端请求地址，通过<code>req.headers</code>获取请求报文，<code>req.methods</code>获取请求方法(get/post)</li>
</ul>
<h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><ul>
<li>200请求成功</li>
<li>404请求的资源没有被找到</li>
<li>500 服务器端错误</li>
<li>400客户端请求有语法错误<h2 id="响应内容类型"><a href="#响应内容类型" class="headerlink" title="响应内容类型"></a>响应内容类型</h2></li>
<li>text/html</li>
<li>text/css</li>
<li>application/javascript</li>
<li>image/jpeg</li>
<li>application/json</li>
</ul>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>客户端向服务器端发送请求时，有时需要携带一些客户信息, 客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p>
<h2 id="get请求参数"><a href="#get请求参数" class="headerlink" title="get请求参数"></a>get请求参数</h2><ul>
<li>参数被放置在浏览器地址栏中，例如: <a href="http://localhost:3000/?name=" target="_blank" rel="noopener">http://localhost:3000/?name=</a> zhangsan&amp;age= 20</li>
</ul>
<p>那么怎么拿到get的参数呢？<br>node为我们提供了一个内置模块</p>
<blockquote>
<p>const url = require(‘url)</p>
</blockquote>
<p>在url模块中，有一个parse()方法可以处理url，我们只需要将想解析的url传给url.parse()方法进行解析，最终，这个方法会返回一个对象。我们来console.log一下<code>url.parse(req.url)</code></p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/urlparse%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>现在，我们把查询参数转换成对象。</p>
<blockquote>
<p>url.parse(req.url,true)</p>
</blockquote>
<ul>
<li>第一个参数是要解析的url地址</li>
<li>第二个参数表示把查询参数解析成对象形式。</li>
</ul>
<p>此时，url.paesr中的query参数会变成一个对象 <code>query:&#39;name=zhangsan ,age=&#39;20&#39;</code><br>这个时候，我们就可以通过<code>url.parse(res.url,true).query</code>拿到这个对象</p>
<blockquote>
<p>let params = url.parse(res.url,true).query</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cocnsole.log(params.name)<span class="comment">//zhangsan</span></span><br><span class="line">cocnsole.log(params.age)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在parse()方法中，还有一个pathname属性可以帮我们获取到不包含请求参数的请求地址。这样，我们就可以通过对象结解构的方式拿到query和pathname</p>
<blockquote>
<p>let {query, pathname} = url.parse(res.url,true)</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/parse%E6%96%B9%E6%B3%95.png" alt=""></p>
<h2 id="post请求参数"><a href="#post请求参数" class="headerlink" title="post请求参数"></a>post请求参数</h2><p>我们可以通过表单方式提交一个post请求，post方式是通过事件的方式接收的。<strong>当请求传递参数时触发data事件</strong>，<strong>当传递完成时触发end事件</strong></p>
<p>我们通过querystring这个内置模块来处理post的请求参数</p>
<blockquote>
<p>const querystring = require(‘querystring’);</p>
</blockquote>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/querystring%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86post.png" alt=""></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p><a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a></p>
<p><a href="http://localhost:3000/login" target="_blank" rel="noopener">http://localhost:3000/login</a></p>
<p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p>
<p>实现路由的核心代码</p>
<p><img src="https://gitee.com/yang_yu_xiang/BlogImages/raw/master/img/%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81.png" alt=""></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
</search>
